<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  <subtitle>读书 + 赚钱 + 健身 = 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxm666.github.io/"/>
  <updated>2019-10-29T02:14:04.522Z</updated>
  <id>http://yxm666.github.io/</id>
  
  <author>
    <name>遠見卓識</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表</title>
    <link href="http://yxm666.github.io/2019/10/28/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yxm666.github.io/2019/10/28/链表/</id>
    <published>2019-10-28T14:55:07.000Z</published>
    <updated>2019-10-29T02:14:04.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>​    高产似母猪，我又来更新我的博客，今天学了链表呢，说实话还是有点绕呢，现在开始吧，奥利给！！！！</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><hr><h2 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h2><p>​    单链表是有序的列表，但地址不一定是相连的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12e59c1a7770b?w=952&h=762&f=png&s=245415" alt="单链表在计算机内存中的储存情况"><br>小结:</p><p>1) 链表是以节点的方式来存储,是链式存储<br>2) 每个节点包含 data 域， next 域:指向下一个节点.<br>3) 如图:发现链表的各个节点不一定是连续存储.<br>4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 </p><p>单链表(带头结点) 逻辑结构示意图如下</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e130b080cf9628?w=1142&h=374&f=png&s=93040" alt="单链表逻辑结构"></p><h2 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h2><p>​    使用带head头的单向链表实现 - 水浒英雄排行榜管理完成对英雄人物的增删改查操作。</p><p>1、 第一种方法在在添加英雄时，直接添加到链表的尾部</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e15107449377a8?w=1636&h=706&f=png&s=462594" alt="添加到链表的尾部"></p><p>2、 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</p><p>思路的分析示意图:</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e15128024e2fe4?w=1238&h=576&f=png&s=267965" alt="添加到指定位置"></p><p>3、 1）先找到该节点，通过遍历 2)temp.name = newHeroNode.name;temp.nickname = newHeroNode.nickname</p><p>4、 删除结点2</p><p>思路分析的示意图:</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e151567aa9e6bf?w=1484&h=554&f=png&s=332784" alt="删除结点"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈HeroNode 作为链表的一个节点〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="comment">// 英雄名称</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 英雄昵称</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈链表的实现〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) 链表是以节点的方式来存储,是链式存储</span></span><br><span class="line"><span class="comment"> * 2) 每个节点包含 data 域， next 域:指向下一个节点.</span></span><br><span class="line"><span class="comment"> * 3) 如图:发现链表的各个节点不一定是连续存储.</span></span><br><span class="line"><span class="comment"> * 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先初始化一个头结点 头结点不要动 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">    2、 将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为head 作为头结点 不能移动 因此我们需要一个辅助指针遍历 temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">// 遍历链表，找到最后 如果后续指针不为空 则继续遍历</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当退出while 循环时， temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">// 此时 将要加入的结点放入到temp的 next域 中</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方法在添加英雄时，根据英雄的排名将英雄插入到指定位置 如果有这个排名则显示添加失败 并给出提示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addbyOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点不能动，因此我们让然通过一个辅助指针来找到添加的位置</span></span><br><span class="line">        <span class="comment">// 因为单链表 我们找的temp是位于添加位置前的一个节点 否则插入不了</span></span><br><span class="line">        <span class="comment">// 添加节点 兴许一个节点都没 所以不需要后移</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">// flag标志添加的标志是否存在 默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 位置摘到 就在 temp的后面</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 说明希望添加的hearNode 的编号已经存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后移 遍历当前链表</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 表明 改heroNode的 No已经存在无法添加</span></span><br><span class="line">            System.out.printf(<span class="string">"准备插入的英雄编号%d 已经存在了 不能加入\n"</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插插入到链表中,temp 的后面 注意插入的顺序</span></span><br><span class="line">            <span class="comment">// 插入等操作先不动 temp 先动 插入的元素 将heroNode 放到 temp的 next 现在有两个元素在 temp的后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            <span class="comment">// 现在在切断 temp与原本的后面的元素的联系</span></span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改结点的信息，根据no编号来修改 no不能做修改</span></span><br><span class="line">    <span class="comment">// 根据newHeroNode 的 no来修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的结点 根据 no编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="comment">// 表示是否找到了该结点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到 改变标志</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号%d 的节点，不能修改"</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、 head不能动 因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">    2、 说明我们在比较时 是 temp.next.no 与 需要删除的节点的no进行比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志是否找到待删除的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 找到 可以删除</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>,no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为头结点不能动 因此我们需要一个辅助节点进行遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表面试题"><a href="#单链表面试题" class="headerlink" title="单链表面试题"></a>单链表面试题</h2><h3 id="去单链表中有效节点的个数"><a href="#去单链表中有效节点的个数" class="headerlink" title="去单链表中有效节点的个数"></a>去单链表中有效节点的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求单链表中有效结点的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法: 获取单链表的节点的个数(如果是带头结点的链表，需要不统计头结点)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空链表</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  定义一个辅助变量 这里没有统计头结点</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            <span class="comment">// 将cur向后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="查找单链表中的倒数第K个结点"><a href="#查找单链表中的倒数第K个结点" class="headerlink" title="查找单链表中的倒数第K个结点"></a>查找单链表中的倒数第K个结点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ 查找单链表中的倒数第K个结点</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、 编写一个方法 接受 head 节点 同时接受一个index</span></span><br><span class="line"><span class="comment">    2、 index 表示倒数第index 个节点</span></span><br><span class="line"><span class="comment">    3、 先把链表从头到尾遍历 得到链表的总长度 getLength</span></span><br><span class="line"><span class="comment">    4、 得到size后 我们从链表的第一个开始遍历(size-index)个 就可以得到</span></span><br><span class="line"><span class="comment">    5、 如果找到了，则返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果链表为空 返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="comment">// 第二次遍历 size-index 位置 就是我们倒数的第K个节点</span></span><br><span class="line">        <span class="comment">// 先做一个index的校验</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义辅助遍历 for循环定位到倒数的index</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e1529a9be2cd78?w=970&h=530&f=png&s=238434" alt="单链表的反转"></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e152a41dcaaa57?w=1298&h=708&f=png&s=455599" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的反转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、 先定义一个节点 reverHead = new HeroNode()</span></span><br><span class="line"><span class="comment">    2、 从头到尾遍历原来的链表 每遍历一个节点 就将其取出 并放出在新的链表reverse的最前端</span></span><br><span class="line"><span class="comment">    3、 原来的链表的head.next = reversehead.next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前链表为空 或者只有一个节点 无需反转 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个辅助指针 帮助我们遍历原来的链表</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">        HeroNode next = <span class="keyword">null</span>;</span><br><span class="line">        HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 遍历原来的链表 每遍历一个节点 就将其取出 并放在新的链表 reverseHead 的最前端</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 先暂时保存当前节点的下一节点 因为后面需要</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">// 将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            cur.next = reverseHead.next;</span><br><span class="line">            <span class="comment">// 将 cur 连接到新的链表上</span></span><br><span class="line">            reverseHead.next = cur;</span><br><span class="line">            <span class="comment">// 让cur后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将head.next 指向 reverseHead.next 实现单链表的反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>思路分析图解</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e152c2925ea660?w=1584&h=528&f=png&s=440239" alt="从尾到头打印"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈栈的模拟实现〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用栈这种数据结构 将各个节点压入到栈中 然后利用栈的先进后出的特点 实现了逆序打印的效果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 空链表 不能打印</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建要给一个栈 将各个节点压入栈</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// 后移 这样就可以压入下一个节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将栈中的节点打印 pop 出栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// stack 的特点是先进后出</span></span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="双向链表的操作分析和实现"><a href="#双向链表的操作分析和实现" class="headerlink" title="双向链表的操作分析和实现"></a>双向链表的操作分析和实现</h1><p>​    使用带head头的双向链表实现 -水浒英雄传</p><p>管理单向链表的缺点分析:</p><ol><li>单向链表，查找打方向只能是一个方向，而双向链表可以向前或者向后查找</li><li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，宗师找到temp,temp是待删除节点的前一个节点</li><li>分析了双向链表如何完成遍历，添加，修改和删除的思路</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e153208378a0c3?w=1914&h=470&f=png&s=402133" alt="双向链表"></p><p>对上图的说明:</p><ol><li>遍历 和单链表一样，只是可以向前 也可以向后查找</li><li>添加(默认添加到双向链表的最后)<ol><li>先找到双向链表的最后这个节点(通过辅助指针循环遍历 此时temp 指向最后一个节点)</li><li>temp.next = newHeroNode</li><li>newHeroNode.pre = temp</li></ol></li><li>修改 思路和原来的单向链表一样</li><li>删除<ol><li>因为是双向链表 因此我们可以实现自我删除某个节点</li><li>直接从要删除的这个节点，比如 temp</li><li>temp.pre.next = temp.next    (将temp的前一个节点的后指针指向temp的下一个)</li><li>temp.next.pre = temp.pre （temp的下一个节点的前指针指向temp的前一个节点）</li></ol></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈双向链表〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化一个头结点 头结点不要动 不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">// 显示链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为头结点 不能动 因此需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp 后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为head节点不能动 因此我们需要一个辅助节点temp 遍历</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">// 遍历链表 找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时 temp就指向了链表的最后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一个节点的内容 可以看大佬双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">// 只是 节点类型换成 HeroNode2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="comment">// 判断是否找到该节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到该节点</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1、 对于双向链表 我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">// 2、 找到后 自我删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">            System.out.println(<span class="string">"链表为空 无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助变量</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="comment">// 标志是否找到待删除的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no==no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 找到 可以删除</span></span><br><span class="line">            <span class="comment">// 单向链表 temp.next = temp.next.next</span></span><br><span class="line">            <span class="comment">// 前一个节点后一个节点指向 当前节点的后一个节点</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">// 如果是最后一个则不需要对后一个节点的前指针进行设置 否则会出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"要删除的%d 节点不存在\n"</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈双向链表的节点类〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="comment">// 指向下一个节点 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;</span><br><span class="line">    <span class="comment">// 指向前一个节点 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode2&#123;"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试双向链表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈双向链表测试〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加节点</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        DoubleLinkList doubleLinkList = <span class="keyword">new</span> DoubleLinkList();</span><br><span class="line">        doubleLinkList.add(hero1);</span><br><span class="line">        doubleLinkList.add(hero2);</span><br><span class="line">        doubleLinkList.add(hero3);</span><br><span class="line">        doubleLinkList.add(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkList.list();</span><br><span class="line"></span><br><span class="line">        HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">        doubleLinkList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">"修改后"</span>);</span><br><span class="line">        doubleLinkList.list();</span><br><span class="line"></span><br><span class="line">        doubleLinkList.del(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除后"</span>);</span><br><span class="line">        doubleLinkList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单向环形链表-应用场景"><a href="#单向环形链表-应用场景" class="headerlink" title="单向环形链表 应用场景"></a>单向环形链表 应用场景</h1><h2 id="Josephu-约瑟夫、约瑟夫环-问题"><a href="#Josephu-约瑟夫、约瑟夫环-问题" class="headerlink" title="Josephu(约瑟夫、约瑟夫环)问题"></a>Josephu(约瑟夫、约瑟夫环)问题</h2><p>Josephu 问题为:设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k(1&lt;=k&lt;=n)的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。<br>提示:用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。</p><h2 id="单向环形链表介绍"><a href="#单向环形链表介绍" class="headerlink" title="单向环形链表介绍"></a>单向环形链表介绍</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e153f7e9698797?w=606&h=434&f=png&s=89486" alt="单向环形链表"></p><h2 id="Josephu-问题"><a href="#Josephu-问题" class="headerlink" title="Josephu 问题"></a>Josephu 问题</h2><p>示意图:</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e15419d87eee57?w=1500&h=792&f=png&s=465655" alt></p><p>Josephu 问题为:</p><p>​    设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k(1&lt;=k&lt;=n)的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。</p><p>提示:</p><p>用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p><p>创建环形链表的思路图解</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e154570487fb0f?w=1408&h=654&f=png&s=390943" alt="UTOOLS1572314901527.png"></p><p>约瑟夫问题-小孩出圈的思路分析图</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/29/16e154885984e02f?w=1620&h=718&f=png&s=525301" alt="小孩出圈"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈约瑟夫问题 单向环形链表〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  测试一把 看看构建环形链表 遍历是否Ok</span></span><br><span class="line">        Josephu josephu = <span class="keyword">new</span> Josephu();</span><br><span class="line">        josephu.addBoy(<span class="number">5</span>);</span><br><span class="line">        josephu.showBoy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建first 节点 当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"num的值不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建辅助指针 帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 使用for循环创建我们的链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据编号创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">// 如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                <span class="comment">// 构成环</span></span><br><span class="line">                first.setNext(first);</span><br><span class="line">                <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是第一个小孩</span></span><br><span class="line">                <span class="comment">// 将新增的节点填入环形链表</span></span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                <span class="comment">// 将环重新连接起来</span></span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                <span class="comment">// 辅助变量后移</span></span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为first 不能动 因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"小孩的编号为%d\n"</span>, curBoy.getNo());</span><br><span class="line">            <span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// curBoy 后移</span></span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据用户的输入 计算出小孩出圈的顺序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @param : starNo 表示从第几个小孩开始数</span></span><br><span class="line"><span class="comment">    @ param : countNum 表示数几下</span></span><br><span class="line"><span class="comment">    @param: nims 表示最初由多少个小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">"参数输入有误"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给辅助指针，帮助小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">// 将helper 指向最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (helper.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小孩报数前 先让first 和 helper 移动 k-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当小孩报数时 让first 和 helper 指针同时的移动 m-1次 然后出圈</span></span><br><span class="line">        <span class="keyword">while</span> (helper != first) &#123;</span><br><span class="line">            <span class="comment">// 让 first 和 helper 指针同时移动 countNum-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 将 first 与 helper 后移 移动后的first节点即为要出圈的小孩</span></span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这时 first 指向的节点 就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line">            <span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">            <span class="comment">// first后移 helper 在一定意义上是前一个 将他的后指针指向移动后的first</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"最后留在圈中的小孩编号为%d\n"</span>, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈Boy类 作为单向环形链表的一个节点〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="comment">// 指向下一个节点 默认为null</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;​    高产似母猪，我又来更新我的博客，今天学了链表呢，说实话还是有点绕呢，现在开始吧，奥利给！！！！&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yxm666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组与队列</title>
    <link href="http://yxm666.github.io/2019/10/25/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yxm666.github.io/2019/10/25/稀疏数组与队列/</id>
    <published>2019-10-25T07:03:09.000Z</published>
    <updated>2019-10-28T14:59:55.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>​    好了，好久没有更新博客了，现在跟着韩顺平的数据结构学习，主要也是实验室太忙了，自己也有一些事，以后周更要坚持住。这次记录的是稀疏数组与队列，队列又分有普通队列与环形队列。</p><h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><hr><h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a><strong>适用情况</strong></h2><p>  <strong>在一些情况下，二维数组会有大部分的数据无用，比如没有意义的0，我们这时候可以使用稀疏数组进行存储该二维数组。</strong></p><h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a><strong>处理方法</strong></h2><ul><li><strong>记录数组一共有几行几列，有多少不同的值</strong></li><li><strong>把具有不同值得元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</strong></li></ul><p><strong><img src="https://s2.ax1x.com/2019/10/25/KddlNj.png" alt="稀疏数组转换"></strong></p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a><strong>应用实例</strong></h2><hr><ol><li><strong>使用稀疏数组，来保留类似的前面的二维数组(棋盘、地图)</strong></li><li><strong>把稀疏数组存盘，并且可以从新恢复原来的二维数组</strong></li></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><hr><h3 id="二维数组-转-稀疏数组的思路"><a href="#二维数组-转-稀疏数组的思路" class="headerlink" title="二维数组 转 稀疏数组的思路"></a><strong>二维数组 转 稀疏数组的思路</strong></h3><ol><li><strong>遍历原始二维数组，得到有效的数据个数 sum (因为创建的稀疏数组的大小需要根据有效个数进行创建)</strong></li><li><strong>根据sum就可以创建洗漱漱 sparseArr int[sum + 1] [3]      (sum+1 是因为第一行需要存储原二维数组的行 列 有效个数 3 作为列数是存储有效元素的信息 前2个是用来存储原二维数组的 行 列 的信息 第三个是存储元素的值)</strong></li><li><strong>将二维数组的有效数据存入稀疏数组</strong></li></ol><h3 id="稀疏数组转原始的二维数组的思路"><a href="#稀疏数组转原始的二维数组的思路" class="headerlink" title="稀疏数组转原始的二维数组的思路"></a>稀疏数组转原始的二维数组的思路</h3><ol><li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]</li><li>在读取稀疏数组后几行的数据，并赋值给原始的二维数组</li></ol><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.sparseArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈稀疏数组的实现〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</span></span><br><span class="line"><span class="comment">        稀疏数组的处理方法是:</span></span><br><span class="line"><span class="comment">        1) 记录数组一共有几行几列，有多少个不同的值</span></span><br><span class="line"><span class="comment">        2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</span></span><br><span class="line"><span class="comment"> 2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数</span></span><br><span class="line"><span class="comment">3) 整体思路分析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原始的二维数组11 * 11</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        <span class="comment">//设置其中不为0的值</span></span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先输出原始二维数组</span></span><br><span class="line">        <span class="comment">// 两次for循环 直接打印</span></span><br><span class="line">        System.out.println(<span class="string">"原始二维数组"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将二维数组转换为细数数组</span></span><br><span class="line">        <span class="comment">// 1、先遍历二维数组 得到非0的 数据个数 用来为新创建</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果这个元素不为0 则sum++</span></span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对应的稀疏数组</span></span><br><span class="line">        <span class="comment">// ssum+1 第一行 依次存储 多少行 多少列  有多少个数不为0</span></span><br><span class="line">        <span class="comment">// 3 : 依次存储为 行号 列号 值</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 将稀疏数组的第一行 存入</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// count 用来记录获取的是第几个非0数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//用来记录非0数据在二维数组中的位置</span></span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="comment">// 第3个值用来存值</span></span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印变换成功的稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"细数数组为:-------"</span>);</span><br><span class="line">        <span class="comment">// 从第一行打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在读取稀疏数组后几行的数据（从第二行开始),并赋值给原始的二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//现根据首行获取原始二维数组的情况</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行赋值 从第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将非0数据根据赋值给新的二维数组</span></span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组为:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><hr><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><hr><h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><ol><li>队列是一个有序列表，可以用数组或是链表来实现。</li><li>遵循先入先出的原则。即:先存入队列的数据，要先取出。后存入的妖后取出。</li><li>示意图<img src="https://s2.ax1x.com/2019/10/25/KdIqsO.png" alt="队列示意图"></li></ol><h3 id="数组模拟队列的思路"><a href="#数组模拟队列的思路" class="headerlink" title="数组模拟队列的思路"></a>数组模拟队列的思路</h3><hr><ul><li>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量</li><li>因为队列的输出、输入分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后的下标, front会随着数据输出而改变，而 rear 则是随着和数据输入而改变，如图所示:</li></ul><p><img src="https://s2.ax1x.com/2019/10/25/KdIqsO.png" alt="队列示意图"></p><ul><li>当我们将数据存入队列时成为”addQueue”,addQueue的处理需要</li></ul><p>思路分析:</p><ol><li>将尾指针后移: rear + 1 ，当 front == rear  表示队列为空</li><li>若尾指针 rear 小于队列的最大下标 maxSize -1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。</li><li>rear == maxSize - 1           [队列满]</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.Queues;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈队列的实现〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列本身是有序列表，若使用数组的结构来存储队列的数据，</span></span><br><span class="line"><span class="comment"> 其中 maxSize 是该队 列的最大容量。</span></span><br><span class="line"><span class="comment"> 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量</span></span><br><span class="line"><span class="comment">front 及 rear 分别记录队列前后端的下标，</span></span><br><span class="line"><span class="comment">front 会随着数据输出而改变，而 rear 则是随着数据输入而改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArrarQucue</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">        <span class="comment">// 队列头</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">        <span class="comment">// 队列尾</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">        <span class="comment">//该数据用于存放数据 模拟队列</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrarQucue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">            <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置</span></span><br><span class="line">            front = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 指向队列尾 指向队列尾的数据(就是队列最后一个数据)</span></span><br><span class="line">            rear = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否为满 因为是从0开始计数 所以需要maxSize-1</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否为空 当头跟尾巴想重 即满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据到队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueuc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断是否为满</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"队列满，不能加入数据"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向队列尾 初始值为-1 需要先加再 再存</span></span><br><span class="line">            rear++;</span><br><span class="line">            arr[rear] = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//判断队列是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 通过抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空 不能添加数据"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// front  后移 因为指向前一位 先++ 再获取</span></span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示队列的所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"队列尾空 无数据"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//判断是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空 没有数据"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h1><hr><p>​    对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的结构。(通过去模的方式来实现)</p><h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><ol><li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意(rear + 1)% maxSize == front (满)</li><li>rear == font (空)</li><li>示意图:<img src="https://user-gold-cdn.xitu.io/2019/10/25/16e021cfabedfc73?w=942&h=358&f=png&s=126501" alt="环形队列示意图"></li></ol><h2 id="思路如下"><a href="#思路如下" class="headerlink" title="思路如下"></a>思路如下</h2><ol><li>front变量的含义进行调整:front就指向队列的第一个元素，也就是一说arr[front] 就是队列的第一个元素 front 的初始值为0</li><li>Rear 变量的含义进行调整:rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值为0</li><li>当队列为满时，条件是(rear+1)%maxSzie = front     [满]</li><li>队列尾空的条件， rear == front [空]</li><li>当这样定义时候，队列中有效的数据个数为: (rear + maxSize - front)%maxSize   </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cxjd.Queues;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 〈数组实现环形队列〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yxm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</span></span><br><span class="line"><span class="comment">分析说明:</span></span><br><span class="line"><span class="comment">1) 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的</span></span><br><span class="line"><span class="comment">时候需要注意 (rear + 1) % maxSize == front 满]</span></span><br><span class="line"><span class="comment">2) rear == front [空]</span></span><br><span class="line"><span class="comment">判断有效个数 : (rear + maxSize)%maxSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">// front 指向队列的第一个元素 arr[front]表示为队列的第一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// rear指向队列的最后一个元素的后一个位置 因为喜欢空出一个空间做约定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">// 该数据用于存放数据 模拟队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断杜烈是否为满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先进行后移 并取余 如果等于 front 则表示满 因为约定进行一个空间的空余</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断队列是否为满</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列满 无法添加数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为rear指向的是最后一个元素的后一个位置 故直接进行添加操作</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//因为之前已经判断了是否为满 所以这里将rear后移没有问题 需要考虑到取余</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的数据 出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空 不能取数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">// 1、 首先把front对应的值保存到一个临时变量中</span></span><br><span class="line">        <span class="comment">// 2、 再将front后移 考虑取模</span></span><br><span class="line">        <span class="comment">// 返回之前保存的临时变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) / maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的所有的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先看判断空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空 没有数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 思路: 从 front 开始遍历 遍历 有效个数个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + <span class="keyword">this</span>.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 尽管是环形队列 下标索引还是不变的 所以 还需要进行去模得到正确的值</span></span><br><span class="line">            System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据 注意不是取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空 没有数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;​    好了，好久没有更新博客了，现在跟着韩顺平的数据结构学习，主要也是实验室太忙了，自己也有一些事，以
      
    
    </summary>
    
      <category term="数据结构与希望" scheme="http://yxm666.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B8%8C%E6%9C%9B/"/>
    
    
      <category term="数据结构与算法" scheme="http://yxm666.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构-线性表</title>
    <link href="http://yxm666.github.io/2019/09/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yxm666.github.io/2019/09/09/算法与数据结构-线性表/</id>
    <published>2019-09-09T08:21:23.000Z</published>
    <updated>2019-10-28T14:54:20.256Z</updated>
    
    <content type="html"><![CDATA[<p>#　前言</p><hr><blockquote><p> 线性表是零个或多个具有相同类型的数据元素的有限序列。主要分为：顺序存储结构、链式存储结构，在链式存储结构中又主要分为：单链表、静态链表、循环链表、双向链表</p></blockquote><p><img src="https://i.loli.net/2019/09/09/Diw7kV58EF9WhKU.png" alt="线性表结构图"></p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><hr><p>线性表(List):零个或多个数据元素的有限序列</p><p>序列：</p><ul><li>元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有切只有一个前驱和后继。</li></ul><p><img src="https://i.loli.net/2019/09/09/2E1KdbwhgXHoNuS.png" alt="线性表的数学定义"></p><p>所以 线性表元素的个数n（n&gt;=0）定义为线性表的长度。当n=0时，称为空表。</p><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><hr><blockquote><p>在讲这个地方之前我想对抽象数据类型进行一个解释，因为之前也不理解抽象数据类型</p><p>抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。抽象数据类型是与表示无关的数据类型，是一个数据模型及定义在该模型上的一组运算。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。</p><p>是不是感觉晦涩难懂，简单点，就是这个线性表应该具有哪样的操作</p></blockquote><p>线性表的数据类型定义如下：</p><p><img src="https://i.loli.net/2019/09/09/AwyXQltUBdoL2nb.png" alt></p><p><img src="https://i.loli.net/2019/09/09/dgfFO85mj7pqNAE.png" alt></p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><hr><h2 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h2><p>定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p><p><img src="https://i.loli.net/2019/09/09/cnxCt1dWyEG7S2s.png" alt="线性表的顺序存储示意图"></p><h2 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h2><p>  在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;<span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE];        <span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line"><span class="keyword">int</span> length;                    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表额最大存储容量：数组长度MaxSize。</li><li>线性表的当前长度：length</li></ul><p>##　数组长度与线性表长度区别</p><p>​    数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。</p><p>​    线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。    </p><h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><hr><h2 id="获取元素操作"><a href="#获取元素操作" class="headerlink" title="获取元素操作"></a>获取元素操作</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为空 或者数组下标越界</span></span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为只有传入指针才能对方法外变量的值做改变 故传入的是地址，</span></span><br><span class="line"><span class="comment">首先定义一个 int 类型变量 e 然后将其地址传入(&amp;e)</span></span><br><span class="line"><span class="comment">此时e指向了结构体中数组所在下标的地址</span></span><br><span class="line"><span class="comment">此时 方法外的变量e的值就进行了改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    ElemType e;</span><br><span class="line">   </span><br><span class="line">    GetElem(L,<span class="number">5</span>,&amp;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第5个元素的值为：%d\n"</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　##　插入操作</p><hr><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(创建一个新的数组，初始化长度加一，然后根据插入点，插入前复制原数组，插入后新数组下标加1)。</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。</li><li>将要插入元素填入位置i处。</li><li>表长加1</li></ul><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length==MAXSIZE)  <span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i&lt;=L-&gt;length)        <span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 从后往前移动</span></span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/* 将要插入位置之后的数据元素向后移动一位 */</span></span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;          <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">            i=ListInsert(&amp;L,<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在L的表头依次插入1～5后：L.data="</span>);</span><br><span class="line"><span class="comment">//在L的表头依次插入1～5后：L.data=5 4 3 2 1</span></span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><hr><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常</li><li>取出删除元素；</li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li><li>表长减1</li></ul><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length==<span class="number">0</span>)               <span class="comment">/* 线性表为空 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)         <span class="comment">/* 删除位置不正确 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i&lt;L-&gt;length)                <span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo</span></span><br><span class="line"> k=ListLength(L); <span class="comment">/* k为表长 */</span></span><br><span class="line">    <span class="keyword">for</span>(j=k+<span class="number">1</span>;j&gt;=k;j--)</span><br><span class="line">    &#123;</span><br><span class="line">            i=ListDelete(&amp;L,j,&amp;e); <span class="comment">/* 删除第j个数据 */</span></span><br><span class="line">            <span class="keyword">if</span>(i==ERROR)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"删除第%d个数据失败\n"</span>,j);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"删除第%d个的元素值为：%d\n"</span>,j,e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h2><hr><p><img src="https://s2.ax1x.com/2019/09/09/ntOaff.png" alt="优缺点"></p><h1 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h1><hr><h2 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h2><hr><p>​    线性表的链式存储结构的特点是用一组<u>任意</u>的存储单元存储线性表的存储元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些存储元素可以存在内存未被占用的任意位置。</p><p><img src="http://yanxuan.nosdn.127.net/59b6e49d78d061ed0d3a00867070b68c.png" alt="链式存储结构"></p><p><img src="https://s2.ax1x.com/2019/09/09/ntO77R.png" alt="链式存储结构"></p><p>​    在以前的顺序结构中，数据元素只需要存储数据元素信息就ok了，因为它们的地址是连续的，跟着地址找，一个连着一个，而链式存储结构中，除了要存储数据元素信息外，还要存储它的后续元素的存储地址。</p><p>​    因此，为了表示每个数据元素ai与其直接后续数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后续的信息(即直接后续的存储位置)。</p><p>​    存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。指针域中存储的信息呗称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。</p><p>​    n个结点（ai的存储映像）链结成一个链表，即为线性表(a1,a2…..an)的链式存储结构，因为此链表中的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。</p><p><img src="https://s2.ax1x.com/2019/09/09/nNSbAH.png" alt="链式存储结构示意图"></p><ul><li>链表中第一个结点的存储位置叫做头指针</li><li>线性链表中的最后一个结点指针为NULL(“^”)</li></ul><p><img src="https://s2.ax1x.com/2019/09/09/nNpVg0.png" alt="无头结点的头指针"></p><p><img src="https://s2.ax1x.com/2019/09/09/nNpl59.png" alt="带头结点的头指针"></p><p>(注：头指针是指向第一个结点的 而不是第一个结点的指针域，说白了 头指针是第一个结点的地址)</p><p>​    有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点称为头结点，头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针(就是头指针)。</p><p><img src="http://yanxuan.nosdn.127.net/552e2bbe034fe13d2b5118829b281893.png" alt></p><h2 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h2><p><img src="http://yanxuan.nosdn.127.net/82a72e174f28a9b9707dac5ee359785a.png" alt="异同"></p><p>​    我个人认为带有头结点的单链表图好像其中头指针的位置画错了，不敢确认，按照定义与理解，头指针应该是排除再链表外的东西(个人理解)，经过请教佩哥，佩哥牛鼻！！！！！，佩哥肯定了我的想法，爱他！！！，可以查看相关文章。</p><p><a href="https://blog.csdn.net/weixin_41413441/article/details/79063738" target="_blank" rel="noopener">相关文章</a></p><h2 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h2><hr><p><img src="http://yanxuan.nosdn.127.net/b9a8b219dcfe85bd6e924d339274c95a.png" alt="不带头结点的单链表"></p><p><img src="http://yanxuan.nosdn.127.net/5d2fc6d07ae72fd62e1aed7dde0d25bf.png" alt></p><p><img src="http://yanxuan.nosdn.127.net/504853f74a73204cfbe582412d49046b.png" alt></p><p>在单链表中，我们在C语言中可用结构指针来描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;<span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;<span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/* 定义LinkList */</span></span><br></pre></td></tr></table></figure><p>​    结点由存放数据元素的数据域和存放后续结点地址的指针域组成。假设 p 是指针域指向线性表第i个元素的指针(ai-1的指针域说白了)，则该结点ai的数据域我们可以用p-&gt;data表示，p-&gt;data的值是一个数据元素，结点ai的指针域可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向第i+1个元素，即指向ai+1的指针。</p><p>​    如果p-&gt;data=ai,那么p-&gt;next-&gt;data=ai+1。</p><p><img src="http://yanxuan.nosdn.127.net/4b90a93b3b685d5d8da52771011e44ff.png" alt></p><p>## </p><h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><hr><p>​    由于单链表的地址不是连续的，所以遍历单链表比较困难，实现获取第i个元素的数据的操作GetElem。</p><p>获得第i个数据的算法思路:</p><pre><code>- 声明一个指针p指向链表第一个结点，初始化j从1开始；- 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；- 若到链表末尾p为空，则说明第i个结点不存在；- 否则查找成功，返回结点p的数据。</code></pre><p>代码实现如下：O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p;<span class="comment">/* 声明一结点p */</span></span><br><span class="line">p = L-&gt;next;<span class="comment">/* 让p指向链表L的第一个结点 */</span></span><br><span class="line">j = <span class="number">1</span>;<span class="comment">/*  j为计数器 */</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j&lt;i)  <span class="comment">/* p不为空或者计数器j还没有等于i时，循环继续 */</span></span><br><span class="line">&#123;   </span><br><span class="line">p = p-&gt;next;  <span class="comment">/* 让p指向下一个结点 */</span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !p || j&gt;i ) </span><br><span class="line"><span class="keyword">return</span> ERROR;  <span class="comment">/*  第i个元素不存在 */</span></span><br><span class="line">*e = p-&gt;data;   <span class="comment">/*  取第i个元素的数据 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo</span></span><br><span class="line"> LinkList L;</span><br><span class="line"> ElemType e;</span><br><span class="line"> Status i;</span><br><span class="line"> <span class="keyword">int</span> j,k;</span><br><span class="line"> GetElem(L,<span class="number">5</span>,&amp;e);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"第5个元素的值为：%d\n"</span>,e);</span><br></pre></td></tr></table></figure><p>  由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就不方便使用for来控制循环。其主要核心思想就是“工作指针后移”，这其实也是很多算法的常用技术。</p><h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><hr><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>  链表的插入与删除的效率是非常高的，插入只需要在插入点前结点的指针指向新插入的结点，将插入结点的指针指向后续结点即可，删除也是同样的道理，但我们要考虑到这些步骤的先后顺序，如果稍有顺序错误，可就GG了~</p><p>  假设存储元素e的结点是s，要实现结点p、p-&gt;next和s之间逻辑关系的变化，只需将结点s插入到结点p和p-&gt;next之间即可。</p><p><img src="https://s2.ax1x.com/2019/09/10/nNLY9K.png" alt="单链表的插入"></p><p>  不用惊动其他结点，只需要让s-&gt;next和p-&gt;next的指针做一点改变即可。</p><p><code>s-&gt;next=p-&gt;next; p-&gt;next=s</code></p><p>  第一句代码是让p的后继结点改成s的后继结点，再把结点s变成p的后继结点。</p><p>ok，看似很简单啊，但是我们先看看指向的关系，其实里面的顺序关系是非常重要的。</p><ul><li>在第一行代码执行完，有2个指针指向p-&gt;next</li></ul><p><img src="http://yanxuan.nosdn.127.net/76e85ca560e1ac0bc1c40f044dd5736c.png" alt="连个指针指向一个结点"></p><ul><li>当第二句代码执行完后，原本指向p-&gt;next的指针断开了与ai+1的链接，指向了s，成功将s插入。</li></ul><p><img src="http://yanxuan.nosdn.127.net/3a2e1e2cc24cf1d6efa7e3158d440c0d.png" alt="成功插入"></p><p>  ok，那么如果先执行第二句会怎么样呢，由于你把p-&gt;next指向了s，那么你就会找不到原本的p-&gt;next了，他就丢了，你无法去表示它了，哟呵，完犊子了，链表断了！</p><p>单链表第i个数据插入结点的算法思路：</p><ul><li>声明一指针p指向链表头结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累积加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，在系统中生成一个空结点；</li><li>将数据元素e赋值给s-&gt;data;</li><li>单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s</li><li>返回成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">  <span class="comment">// 指向单链表的头结点</span></span><br><span class="line">p = *L;   </span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i)     <span class="comment">/* 寻找第i个结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指针向后移动</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i) </span><br><span class="line"><span class="keyword">return</span> ERROR;   <span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">/*  生成新结点(C语言标准函数) */</span></span><br><span class="line">s-&gt;data = e;  </span><br><span class="line">s-&gt;next = p-&gt;next;      <span class="comment">/* 将p的后继结点赋值给s的后继  */</span></span><br><span class="line">p-&gt;next = s;          <span class="comment">/* 将s赋值给p的后继 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"初始化L后：ListLength(L)=%d\n"</span>,ListLength(L));</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">            i=ListInsert(&amp;L,<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在L的表头依次插入1～5后：L.data="</span>);</span><br><span class="line"><span class="comment">// 在L的表头依次插入1～5后：L.data=5 4 3 2 1</span></span><br><span class="line">    ListTraverse(L);</span><br></pre></td></tr></table></figure><p>  在这段算法代码中，我们用到了c语言的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中找了一块空地，准备用来存放数据e的s结点。</p><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><hr><p>  设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。</p><p><img src="http://yanxuan.nosdn.127.net/390e13dfac0970d384dbcd678fa60a00.png" alt="单链表的删除"></p><p>​    我们所要做的就是一步，p-&gt;next=p-&gt;next-&gt;next，用q来取代p-&gt;next,</p><p><img src="https://s2.ax1x.com/2019/09/10/nUS6de.png" alt="删除结点举例"></p><p>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，将想删除的结点p-&gt;next赋值给q;</li><li>单链表的删除标准语句p-&gt;next=q-&gt;next;</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点；</li><li>返回成功</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i)<span class="comment">/* 遍历寻找第i个元素 */</span></span><br><span class="line">&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i) </span><br><span class="line">    <span class="keyword">return</span> ERROR;           <span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;<span class="comment">/* 将q的后继赋值给p的后继 */</span></span><br><span class="line">*e = q-&gt;data;               <span class="comment">/* 将q结点中的数据给e */</span></span><br><span class="line"><span class="built_in">free</span>(q);                    <span class="comment">/* 让系统回收此结点，释放内存 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo</span></span><br><span class="line">k=ListLength(L); <span class="comment">/* k为表长 */</span></span><br><span class="line">    <span class="keyword">for</span>(j=k+<span class="number">1</span>;j&gt;=k;j--)</span><br><span class="line">    &#123;</span><br><span class="line">            i=ListDelete(&amp;L,j,&amp;e); <span class="comment">/* 删除第j个数据 */</span></span><br><span class="line">            <span class="keyword">if</span>(i==ERROR)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"删除第%d个数据失败\n"</span>,j);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"删除第%d个的元素值为：%d\n"</span>,j,e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    这段算法代码里，我们又用到了另一个C语言的标准很熟free。它的作用就是让系统回收一个Node结点，释放内存。分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。</p><p>​    我们发现增删都需要进行查询，但是链表的查询的时间复杂度都是O(n),这样比起来可能它们并没有什么优势，但是当我们进行多个结点的插入时，对于顺序构造需要移动n-i个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。</p><p>​    显然，对于插入或删除数据越复杂的操作，单链表的效率优势就越明显。</p><h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><hr><p>​    之前的顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。对于每个单链表来说，它所占用空间的大小和位置是不需要预先分配规定的，可以根据系统的情况和实际的需求即使生成。</p><p>​    所以，创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始化状态起，依次建立各元素结点，并逐个插入链表。</p><p>​    单链表整表的创建算法思路:</p><ol><li><p>声明一指针p和计数器变量i；</p></li><li><p>初始化一空链表L;</p></li><li><p>让L的头结点的指针指向NULL，即建立一个带头结点的单链表;</p></li><li><p>循环:</p><ul><li>生成一个新结点赋值给P；</li><li>随机生成一数字赋值给p的数字域p-&gt;data;</li><li>将p插入到头结点与前一 新结点之间。</li></ul></li></ol><p>   实现代码算法如下：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   LinkList p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   srand(time(<span class="number">0</span>));                         <span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">   *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">   (*L)-&gt;next = <span class="literal">NULL</span>;                      <span class="comment">/*  先建立一个带头结点的单链表 */</span></span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">   &#123;</span><br><span class="line">   p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span></span><br><span class="line">   p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;             <span class="comment">/*  随机生成100以内的数字 */</span></span><br><span class="line">           <span class="comment">// 将新插入的结点链接到之前结点的前面</span></span><br><span class="line">   p-&gt;next = (*L)-&gt;next;</span><br><span class="line">           <span class="comment">//由此判断一个链表的地址指向应该是头指针的指向</span></span><br><span class="line">           <span class="comment">// 是通过头指针往后插 </span></span><br><span class="line">   (*L)-&gt;next = p;<span class="comment">/*  插入到表头 */</span></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Demo</span></span><br><span class="line">CreateListHead(&amp;L,<span class="number">20</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"整体创建L的元素(头插法)："</span>);</span><br><span class="line">   <span class="comment">//清空L后：ListLength(L)=0</span></span><br><span class="line">   <span class="comment">// 整体创建L的元素(头插法)：4 96 47 38 31 9 95 91 70 77 84 67 96 79 21 83 78 88 29 46</span></span><br></pre></td></tr></table></figure><p>   ​    这段算法代码里，我们其实用的插队的方法，就是始终让新结点在第一的位置。我也可以把这种算法简称为头插法。这个算法主要是通过p-&gt;next = (<em>L)-&gt;next  将新创建结点与前一结点想链，并接到前一结点前面，通过 (</em>L)-&gt;next = p 将头结点与先加入结点相链</p><p>   <img src="https://s2.ax1x.com/2019/09/10/nUYV39.png" alt="头插法"></p><p>   ​    但是我们通常是将新结点放到最后。我们吧每次新结点都插在终端结点的后面，这种算法称之为尾插法。</p><p>实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));                      <span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* L为整个线性表 */</span></span><br><span class="line">    <span class="comment">// 现在应该没元素 所以是头指针 也是末尾 没毛病</span></span><br><span class="line">r=*L;                                <span class="comment">/* r为指向尾部的结点 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/*  生成新结点 */</span></span><br><span class="line">p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;           <span class="comment">/*  随机生成100以内的数字 */</span></span><br><span class="line">r-&gt;next=p;                        <span class="comment">/* 将表尾终端结点的指针指向新结点 */</span></span><br><span class="line">        <span class="comment">// 这是将r这个结点后移了</span></span><br><span class="line">r = p;                            <span class="comment">/* 将当前的新结点定义为表尾终端结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;                       <span class="comment">/* 表示当前链表结束 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">   </span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo</span></span><br><span class="line">i=ClearList(&amp;L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除L后：ListLength(L)=%d\n"</span>,ListLength(L));</span><br><span class="line">    CreateListTail(&amp;L,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整体创建L的元素(尾插法)："</span>);</span><br><span class="line">    ListTraverse(L);</span><br><span class="line"><span class="comment">// 删除L后：ListLength(L)=0</span></span><br><span class="line"><span class="comment">// 整体创建L的元素(尾插法)：46 29 88 78 83 21 79 96 67 84 77 70 91 95 9 31 38 47 96 4</span></span><br></pre></td></tr></table></figure><p>​        注意L与r的关系，L是指整个单链表，而r是指向尾结点的变量，r会随着循环不断变化结点(r-&gt;next=pr = p;),而L则是随着循环增长尾一个多结点的链表。</p><p>​    r-&gt;next = p 的意思是将刚才的表尾终端结点r的指针指向新结点p，将新创建的结点接到后面。</p><p>​    </p><p><img src="http://yanxuan.nosdn.127.net/cfd37c9ffc79b7bcc22ecb7ee705066c.png" alt="将新创建结点接到尾部结点的后面"></p><p>​    而r-&gt;next=p可能不太好理解，ok，首先分析下执行完上面那条语句后的r p 关系，r现在不是最后一个了 p 才是，但是我们需要一直让r当最后一个，p又是每个循环新创建的东西，所以现在我们需要将r往后挪个窝，让r重新回到最后。这行代码就是这个目的了！</p><p><img src="http://yanxuan.nosdn.127.net/1391cbfbbd885a304dc92a50db0b0df5.png" alt="将r重新定位到尾结点"></p><p>​    本来r是在ai-1元素的结点，可现在它已经不是最后的结点了，现在最后的结点是ai，所以应该让将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。</p><p>​    循环结束后，应该让这个节点的指针域为NULL，因此有 “r-&gt;next = NULL”,以便以后遍历时可以确认其是尾部。</p><h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><hr><p>​    当我们不使用这个链表的时候，我们需要将它销毁，就是说白了释放内存空间。</p><p>​    单链表整表删除的算法思路如下:</p><pre><code>1. 声明一个结点p和q； 2. 将第一个结点复制给p; 3. 循环: - 将下一结点赋值给q; - 释放p; - 将q赋值给p;</code></pre><p>实现代码算法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">LinkList p,q;</span><br><span class="line">    <span class="comment">// 如果 p = (*L) 则为一个头指针 (指向第一个结点)</span></span><br><span class="line">p=(*L)-&gt;next;           <span class="comment">/*  p指向第一个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p)                <span class="comment">/*  没到表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next=<span class="literal">NULL</span>;        <span class="comment">/* 头结点指针域为空 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    q变量是作为一个临时变量存放p的，因为当执行”free(p)“时，p的指针域中的地址也没了，其他就比较简单，循环后依旧让尾指针的指针域为NULL。</p><h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><hr><p><img src="http://yanxuan.nosdn.127.net/b18c488abfb1c35050cffdb1a936e9c0.png" alt="对比"></p><p>结论:</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，使用顺序存储结构。</li><li>若要频繁插入和删除时，使用单链表节后</li><li>当线性表中元素个数变化较大或根本不知道有多大时，最好用单链表结构。</li><li>事先知道线性表的大致长处，使用顺序存储结构。</li></ul><p>##　循环链表</p><hr><p>​    单链表由于每个结点只存储了向后的指针，到了尾标识就停止了向后链的操作，当中某一结点就无法找到它的前驱结点，不能返回。</p><p>​    将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><p>​    循环链表的出现解决了如果我们不是从头指针指向第一结点仍然能访问每一个结点。</p><p>​    为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，并不是说循环链表必须要头结点。</p><p><img src="http://yanxuan.nosdn.127.net/fcee62ee89cd0dac30639410af14e522.png" alt></p><p>​    其实，循环链表和单链表的主要差异在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环为结束。</p><p>​    在单链表中，我们可以使用头结点，用O(1)的时间访问第一个节点，但对于要访问到最后一个结点，却需要O(n)时间，因为需要将链表全部扫描一遍。</p><p>​    我们通过指向终端结点的尾指针来循环链表，此时查找开始结点和终端结点都很方便。</p><p><img src="https://s2.ax1x.com/2019/09/10/naKWod.png" alt="尾指针"></p><p>​    从s图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其复杂度也为O(1)。</p><p>​    当我们要将两个循环链表合并成一个表时，有了尾指针就非常简单了。下面两个循环链表，它们的尾指针分别是rearA和rearB。</p><p><img src="https://s2.ax1x.com/2019/09/10/naKLwQ.png" alt></p><p>​    要想将它们合并，只需要如下操作。</p><p><img src="http://yanxuan.nosdn.127.net/59f621e1a2ec7dd947e42106510057b1.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=rearA-&gt;next;  <span class="comment">// 保存A表的头结点 即1</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next; <span class="comment">// 将本指向B表的第一个结点(不是头结点) 赋值给rearA-&gt;next 即2(头结点)</span></span><br><span class="line">q=rearB-&gt;next;</span><br><span class="line">rearB-&gt;next=p; <span class="comment">//将原A表的头结点赋值给rearB-&gt;next 即3</span></span><br><span class="line"><span class="built_in">free</span>(q)  <span class="comment">// 释放q</span></span><br></pre></td></tr></table></figure><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h2 id="双向l建表"><a href="#双向l建表" class="headerlink" title="双向l建表"></a>双向l建表</h2><hr><p>​    我们在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。</p><p>​    双向链表是在单链表的每个结点中，再设置一个指向其他前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">// 直接前驱指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">  <span class="comment">// 直接后继指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>=======</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><hr><p>​    我们在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="comment">// 直接前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="comment">// 直接后继指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DulNode *DuLinkList;</span><br></pre></td></tr></table></figure><p>​    既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。双向链表的循环带头结点的空链表与非空链表如图所示。</p><p><img src="http://yanxuan.nosdn.127.net/6a00f51770ea0b0715a7d01c00533496.png" alt></p><p>​    由于这是双向链表，那么对于链表中的某一个结点P，它的后继的前驱结点，与前驱的后继都是自己。</p><p><code>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</code></p><p>​    双向链表是单链表中拓展出来的结构，它的很多操作是和单链表相同的，例如：求长度的ListLength，查找元素的GetElem等，这些操作都只要设计一个方向的指针，但在插入与删除需要涉及一个结点的两边结点操作时，情况就不相同了。</p><p>​    插入操作不复杂，需要注意顺序。假设存储元素e的结点为s,要实现将结点s插入到结点p和p-&gt;next之间需要下面几步。</p><p><img src="http://yanxuan.nosdn.127.net/91c91dfb0cd72c3d4999fadf91927bfe.png" alt="双向链表插入操作"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior = p;   <span class="comment">// 把p赋值给s的前驱，如图1</span></span><br><span class="line">s -&gt; next = p -&gt; next <span class="comment">//把p-&gt;next赋值给s的后端，如图2</span></span><br><span class="line">p -&gt; next -&gt; prior = s   <span class="comment">// 把s赋值给p-&gt;next的前驱，如图3</span></span><br><span class="line">p -&gt; next = s <span class="comment">// 把s赋值给p的后端，如图4</span></span><br></pre></td></tr></table></figure><p>​    关键在于它们的顺序，由于第2步和第3步都用到了p-&gt;next。如果第4步先执行，则会使得p-&gt;next提前边变成了s，使得插入的工作完不成。 </p><p>​    顺序:(我感觉的话最先弄得是插入的结点自身的东西然后因为你获取的是p结点 所以先该跟p有关的也就是p-&gt;next 有关的东西，然后最后再改p本身，因为如果你先动了p,那么p-&gt;next就搞不定了)</p><pre><code>1. 先搞定s的前驱和后继  2. 搞定后结点的前驱  3. 解决前结点的后续</code></pre><p><img src="http://yanxuan.nosdn.127.net/cb528615b8d32d77f25e757fcbbb115f.png" alt="删除双向链表"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next=p-&gt;next <span class="comment">//把p-&gt;next赋值给我p-&gt;prior的后继 如图1</span></span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior <span class="comment">//把p-&gt;prior赋值给p-&gt;next的前驱 如图2</span></span><br><span class="line"><span class="built_in">free</span>(p)  <span class="comment">//释放结点p</span></span><br></pre></td></tr></table></figure><p>​    双向链表由于每个接待你都需要记录两份指针，所以再空间上要占用略多一些，但使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。</p><p>##　总结回顾</p><hr><p>​    <img src="http://yanxuan.nosdn.127.net/2ca04c187595ee43df213e15d546ae4e.png" alt></p><p>​    线性表是零个或多个具有相同类型的数据元素的有限序列。链表比较快速的插入与删除。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b68ff727ae8177de918a107402988034fe81212e</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#　前言&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 线性表是零个或多个具有相同类型的数据元素的有限序列。主要分为：顺序存储结构、链式存储结构，在链式存储结构中又主要分为：单链表、静态链表、循环链表、双向链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://yxm666.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法与数据结构" scheme="http://yxm666.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构-概述</title>
    <link href="http://yxm666.github.io/2019/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E8%BF%B0/"/>
    <id>http://yxm666.github.io/2019/09/01/算法与数据结构-概述/</id>
    <published>2019-09-01T01:24:55.000Z</published>
    <updated>2019-10-28T14:54:20.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>数据结构与算法算是程序的灵魂，本系列文章是根据《大话数据结构》与《算法》书本内容所写的内容总结的读书笔记，加上自己的一定理解。</strong></p></blockquote><hr><h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a><strong>数据结构绪论</strong></h1><ul><li><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></li></ul><h2 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a><strong>基本概念与术语</strong></h2><hr><ul><li><strong>数据：是描述客观事物的符号，是计算机中可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。</strong></li><li><strong>数据元素：书组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</strong></li><li><strong>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位</strong></li><li><strong>数据对象：是性质相同的数据元素的集合，是数据的子集。</strong></li><li><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</strong></li></ul><p><strong><img src="https://i.loli.net/2019/09/01/Z9uADXRG7HNpkbY.png" alt="数据结构相关概念"></strong></p><h2 id="逻辑结构与物理结构-存储结构"><a href="#逻辑结构与物理结构-存储结构" class="headerlink" title="逻辑结构与物理结构(存储结构)"></a><strong>逻辑结构与物理结构(存储结构)</strong></h2><hr><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a><strong>逻辑结构</strong></h3><ul><li><strong>逻辑结构：是指数据对象中数据元素之间的相互关系。</strong></li></ul><h4 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a><strong>集合结构</strong></h4><hr><ul><li><strong>集合结构中的数据元素除了通属于一个集合外，它们之间没有其他关系。各个数据元素是平等的，它们的共同属性是“同属于一个集合”，类比于数学中的集合</strong></li></ul><p><strong><img src="https://s2.ax1x.com/2019/09/01/nSlNb4.png" alt="集合结构"></strong></p><h4 id="线性结构-一对一"><a href="#线性结构-一对一" class="headerlink" title="线性结构(一对一)"></a><strong>线性结构(一对一)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS1gS0.png" alt="线性结构"></strong></p><h4 id="树形结构-一对多"><a href="#树形结构-一对多" class="headerlink" title="树形结构(一对多)"></a><strong>树形结构(一对多)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS12lV.png" alt="树形结构"></strong></p><h4 id="图形结构-多对多"><a href="#图形结构-多对多" class="headerlink" title="图形结构(多对多)"></a><strong>图形结构(多对多)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS1RyT.png" alt="图形结构"></strong></p><p><strong>注意事项：</strong></p><ol><li><strong>将每一个数据元素看做一个结点，用圆圈表示</strong></li><li><strong>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</strong></li></ol><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a><strong>物理结构</strong></h3><ul><li><strong>是指数据的逻辑结构在计算机中的存储形式。</strong></li></ul><p><strong>数据的存储结构应正确反映数据元素之间的逻辑关系，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</strong></p><p><strong>数据元素的存储结构形式有两种：顺序存储和链式存储</strong></p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a><strong>顺序存储结构</strong></h4><ul><li><strong>是把数据元素存放在 地址连续 的存储单元里，其数据之间的逻辑关系和物理关系是一致的。</strong></li></ul><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS3J74.png" alt="顺序存储结构"></strong></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a><strong>链式存储结构</strong></h4><ul><li><strong>是把元素存放在 任意 的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</strong></li></ul><p><strong>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到向管理数据元素的位置。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS3bNj.png" alt></strong></p><p><img src="https://s2.ax1x.com/2019/09/03/nkokKU.png" alt="nkokKU.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li><p>算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p></li><li><p>算法的特性：有穷性、确定性、可行性、输入、输出</p></li><li><p>算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求</p></li><li><p>算法的度量方法：<del>事后统计方法</del>、事前分析估算方法</p></li></ul><p><img src="https://s2.ax1x.com/2019/09/01/nS8IR1.png" alt></p><p>推导大O阶：(最高阶次方去常数项)</p><ul><li>用常数1取代运行时间中所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶段</li><li>如果最高阶项存在且不是1，则去除与整个项相乘的常数</li></ul><p><img src="https://s2.ax1x.com/2019/09/01/nSGMLT.png" alt></p><p>常见的时间复杂度多消耗时间的大小排序：</p><p><img src="https://s2.ax1x.com/2019/09/01/nSGleU.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据结构与算法算是程序的灵魂，本系列文章是根据《大话数据结构》与《算法》书本内容所写的内容总结的读
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://yxm666.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>holiday summary(3)</title>
    <link href="http://yxm666.github.io/2019/08/20/holiday-summary-3/"/>
    <id>http://yxm666.github.io/2019/08/20/holiday-summary-3/</id>
    <published>2019-08-20T10:24:55.000Z</published>
    <updated>2019-08-27T09:26:11.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote><p>​    <strong>在快乐了几天后决定今天把假期总结的东西写完，看看剩的技术还挺多的，就稍微提提好了。肥宅快乐，嗝~</strong></p></blockquote><h1 id="授权管理框架"><a href="#授权管理框架" class="headerlink" title="授权管理框架"></a><strong>授权管理框架</strong></h1><hr><h2 id="Shiro架构与功能介筛"><a href="#Shiro架构与功能介筛" class="headerlink" title="Shiro架构与功能介筛"></a><strong>Shiro架构与功能介筛</strong></h2><hr><p><strong>1.认证与授权相关基本概念</strong></p><p><strong>两个基本的概念</strong></p><p><strong>安全实体：系统需要保护的具体对象数据</strong></p><p><strong>权限：系统相关的功能操作，例如基本的CRUD</strong></p><p><strong>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</strong></p><p><strong>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</strong></p><p><strong>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</strong></p><p><strong>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</strong></p><p><strong>Web Support：Web支持，可以非常容易的集成到Web环境；</strong></p><p><strong>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</strong></p><p><strong>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</strong></p><p><strong>Testing：提供测试支持；</strong></p><p><strong>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</strong></p><p><strong>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</strong></p><p><strong>2.Shiro四大核心功能:Authentication,Authorization,Cryptography,Session Management</strong></p><p><strong><img src="http://p1.pstatp.com/large/37eb00020300d0856a0e" alt="Shiro结构"></strong></p><p><strong>3.Shiro三个核心组件：Subject, SecurityManager 和 Realms.</strong></p><p><strong>Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；</strong></p><p><strong>SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</strong></p><p><strong>Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</strong></p><h2 id="Spring-Security简介"><a href="#Spring-Security简介" class="headerlink" title="Spring Security简介"></a><strong>Spring Security简介</strong></h2><hr><p>​    <strong>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。它与Spring MVC有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。</strong></p><p><strong>它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。</strong></p><ul><li><p><strong>Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。</strong></p></li><li><p><strong>业务对象或者方法的安全：控制方法访问权限的。</strong></p></li><li><p><strong>AuthenticationManager：处理来自于框架其他部分的认证请求。</strong></p></li><li><p><strong>AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。</strong></p></li><li><p><strong>AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</strong></p></li><li><p><strong>UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</strong> </p></li></ul><h2 id="Spring-Security-简介"><a href="#Spring-Security-简介" class="headerlink" title="Spring Security 简介"></a><strong>Spring Security 简介</strong></h2><hr><p>​    <strong>Spring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于 Spring 的应用程序提供身份验证和授权支持。它与 Spring MVC 有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作 “认证” 与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。</strong></p><p><strong>它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。</strong></p><ul><li><strong>Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。</strong></li><li><strong>业务对象或者方法的安全：控制方法访问权限的。</strong></li><li><strong>AuthenticationManager：处理来自于框架其他部分的认证请求。</strong></li><li><strong>AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。</strong></li><li><strong>AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</strong></li><li><strong>UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</strong></li></ul><p><strong><img src="http://p3.pstatp.com/large/37e8000557281bce894c" alt></strong></p><h2 id="Shiro-和-Spring-Security-比较"><a href="#Shiro-和-Spring-Security-比较" class="headerlink" title="Shiro 和 Spring Security 比较"></a><strong>Shiro 和 Spring Security 比较</strong></h2><hr><ol><li><strong>Shiro 比 Spring 更容易使用，实现和最重要的理解</strong></li><li><strong>Spring Security 更加知名的唯一原因是因为品牌名称</strong></li><li><strong>“Spring” 以简单而闻名，但讽刺的是很多人发现安装 Spring Security 很难</strong></li><li><strong>然而，Spring Security 却有更好的社区支持</strong></li><li><strong>Apache Shiro 在 Spring Security 处理密码学方面有一个额外的模块</strong></li><li><strong>Spring-security 对 spring 结合较好，如果项目用的 springmvc ，使用起来很方便。但是如果项目中没有用到 spring，那就不要考虑它了。</strong></li><li><strong>Shiro 功能强大、且 简单、灵活。是 Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行</strong></li></ol><h1 id="Docker-跟Docker能装的一些能用到的技术"><a href="#Docker-跟Docker能装的一些能用到的技术" class="headerlink" title="Docker 跟Docker能装的一些能用到的技术"></a><strong>Docker 跟Docker能装的一些能用到的技术</strong></h1><hr><blockquote><p>​    <strong>这里就主要提一下Docker就好了，因为里面的几种技术我也没有过多的了解(<del>Docker也没咋玩会</del>)。那让我们先瞅瞅里面的几项技术好了</strong></p></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><hr><p><strong>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>，<a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>，<a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</strong></p><hr><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h3><hr><p><strong>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang" target="_blank" rel="noopener">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/开放电信平台" target="_blank" rel="noopener">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/库" target="_blank" rel="noopener">库</a>。</strong></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a><strong>MongoDB</strong></h3><hr><p><strong>MongoDB是一个基于分布式文件存储的数据库。由<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</strong></p><p><strong>MongoDB是一个介于<a href="https://baike.baidu.com/item/关系数据库" target="_blank" rel="noopener">关系数据库</a>和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似<a href="https://baike.baidu.com/item/json" target="_blank" rel="noopener">json</a>的<a href="https://baike.baidu.com/item/bson" target="_blank" rel="noopener">bson</a>格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立<a href="https://baike.baidu.com/item/索引" target="_blank" rel="noopener">索引</a>。</strong></p><h3 id="laticsearch"><a href="#laticsearch" class="headerlink" title="laticsearch"></a><strong>laticsearch</strong></h3><hr><p><strong>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</strong><br><strong>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</strong></p><hr><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><hr><blockquote><p>  <strong>工具这里根据功能两两分组，讲解一下，就好啦。</strong></p></blockquote><h3 id="Mybatis-Plus-amp-PageHelper"><a href="#Mybatis-Plus-amp-PageHelper" class="headerlink" title="Mybatis Plus &amp; PageHelper"></a><strong>Mybatis Plus &amp; PageHelper</strong></h3><hr><pre><code>&gt;​    **这两个工具都是对持久层框架Mybatis的增强，旨在简化持久层开发。**</code></pre><h4 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a><strong>Mybatis Plus</strong></h4><p>​    <strong>对于SPring Boot，官方提供了Start，较好的整合了Mybatis Plus，直接在pom.xml中导入对应的依赖即可。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus（简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生</strong></p><h4 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a><strong>PageHelper</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    <strong>为啥用这个插件呢？因为他代码实现分页就一行代码。在进行查询前插入一个静态方法即可。</strong></p><p><strong><code>PageHelper.startPage（pageNum ， pageSize</code>，这个方法就是类似我们数据库操作的limit start ， count</strong></p><p><strong>就完事了！</strong></p><h3 id="Swagger2-amp-amp-PostMan"><a href="#Swagger2-amp-amp-PostMan" class="headerlink" title="Swagger2 &amp;&amp; PostMan"></a><strong>Swagger2 &amp;&amp; PostMan</strong></h3><hr><h4 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a><strong>Swagger2</strong></h4><p>​    <strong>Swagger是根据我们写的接口动态生成一个html界面，供前台测试用，他不仅可以看接口(这里推荐用restful风格的接口！！！！)的作用，最关键是可以进行测试（<del>下面的一款是专门用来测接口的</del>）。而且动态生成的页面，改代码的时候，直接改对应注解就行了，对于后端来说比较友好~~</strong></p><p>​    <strong>首先是引入依赖，在pom.xml文件中引入依赖。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>然后是Swagger配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .pathMapping(<span class="string">"/"</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"cn.cxjd.demo.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build().apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .title(<span class="string">"轻大软创门户网站API文档"</span>)</span><br><span class="line">                        .description(<span class="string">"含有3大模块接口:管理员模块，新闻模块，新闻分类模块"</span>)</span><br><span class="line">                        .version(<span class="string">"1.0"</span>)</span><br><span class="line">                        .contact(<span class="keyword">new</span> Contact(<span class="string">"联系后端开发者"</span>, <span class="string">""</span>, <span class="string">"877495283@qq.com"</span>))</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类一定要写<code>@EnableSwagger2</code>这个注解哦，大概就是开启swagger的功能的意思吧。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>(value = <span class="string">"涉及用户的接口"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"用户注册"</span>, notes = <span class="string">"传入user对象(包含username与password即可)"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;<span class="meta">@ApiImplicitParam</span>(name = <span class="string">"user"</span>, value = <span class="string">"用户实体"</span>, required = <span class="keyword">true</span>,dataType = <span class="string">"User"</span>,paramType = <span class="string">"body"</span>)&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">addUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> register = userService.register(user);</span><br><span class="line">        <span class="keyword">if</span> (register == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="string">"error"</span>, <span class="string">"该用户名已存在"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (register == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="string">"success"</span>, <span class="string">"创建成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>具体的注解使用方法参考下<a href="https://blog.csdn.net/xupeng874395012/article/details/68946676" target="_blank" rel="noopener">这篇博客</a></strong></p><h4 id="postMan"><a href="#postMan" class="headerlink" title="postMan"></a><strong>postMan</strong></h4><p> <strong>postman是一款用来测试接口的软件，在Chrome中搜索下载就好了，具体就不在这里说了~~</strong></p><h3 id="FastJson-amp-amp-Druid"><a href="#FastJson-amp-amp-Druid" class="headerlink" title="FastJson &amp;&amp; Druid"></a><strong>FastJson &amp;&amp; Druid</strong></h3><hr><p>  <strong>来，先上一下这两个技术的maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- fastjson的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.59<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  <strong>从这依赖都可以看出来了，这属于阿里开发的东西喽，然后了解不多，都是跟着网上看的，网址放着，等开学用到了再仔细研究写心得好了。</strong></p><p><strong><a href="https://www.w3cschool.cn/fastjson/" target="_blank" rel="noopener">W3C fastJson</a></strong></p><p><strong><a href="https://segmentfault.com/a/1190000013997259" target="_blank" rel="noopener">druid教学</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;在快乐了几天后决定今天把假期总结的东西写完，看看剩的技
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Holiday summary(二)</title>
    <link href="http://yxm666.github.io/2019/08/17/Holiday-summary-%E4%BA%8C/"/>
    <id>http://yxm666.github.io/2019/08/17/Holiday-summary-二/</id>
    <published>2019-08-17T06:32:52.000Z</published>
    <updated>2019-08-19T04:06:42.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><blockquote><p><strong>跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我们看看都有啥吧。</strong></p></blockquote><hr><p><strong><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></strong></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><hr><p>​    <strong>Maven 、git 算是2个编程比较常用的工具吧，但是为了有区别一点还是单独拉出来了。</strong></p><hr><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h2><pre><code>**Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。**</code></pre><p><strong>Maven主要做了两件事：</strong></p><ol><li><strong>统一开发规范与工具</strong></li><li><strong>统一管理jar包</strong></li><li><strong>Maven常用指令</strong></li></ol><hr><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a><strong>Maven项目结构</strong></h3><p>​    <strong>若要使用 Maven，那么项目的目录结构必须符合 Maven 的规范，其目录结构如下：</strong></p><p>​    <strong><img src="https://img-blog.csdn.net/201808131239225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVxdWFucXVxbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Maven目录jΩΩΩ"></strong></p><h3 id="Maven-基本命令"><a href="#Maven-基本命令" class="headerlink" title="Maven 基本命令"></a><strong>Maven 基本命令</strong></h3><hr><ol><li><p><strong>-v: 查询 Maven 版本</strong></p><p><strong>本命令用于检查 maven 是否安装成功。</strong></p><p><strong>Maven 安装完成之后，在命令行输入 mvn -v，若出现 maven 信息，则说明安装成功。</strong></p></li><li><p><strong>compile：编译</strong></p><p><strong>将 java 源文件编译成 class 文件</strong></p></li><li><p><strong>test: 测试项目</strong></p><p><strong>执行 test 目录下的测试用例</strong></p></li><li><p><strong>package: 打包</strong></p><p><strong>将项目打成 jar 包</strong></p></li><li><p><strong>clean: 删除 target 文件夹</strong></p></li><li><p><strong>install: 安装</strong></p><p><strong>将当前项目放到 Maven 的本地仓库中。供其他项目使用</strong></p></li></ol><hr><h3 id="Maven的仓库"><a href="#Maven的仓库" class="headerlink" title="Maven的仓库"></a><strong>Maven的仓库</strong></h3><hr><p><strong>Maven 仓库用来存放 Maven 管理的所有 Jar 包。分为：本地仓库 和 中央仓库。</strong></p><ul><li><strong>本地仓库：Maven 本地的 Jar 包仓库。</strong></li><li><strong>中央仓库： Maven 官方提供的远程仓库。</strong></li></ul><p><strong><code>当项目编译时，Maven 首先从本地仓库中寻找项目所需的 Jar 包，若本地仓库没有，再到 Maven 的中央仓库下载所需 Jar 包。</code></strong></p><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a><strong>坐标</strong></h3><hr><p><strong>在 Maven 中，坐标是 Jar 包的唯一标识，Maven 通过坐标在仓库中找到项目所需的 Jar 包，通过<a href="https://mvnrepository.com/" target="_blank" rel="noopener">官方依赖仓库</a>去寻找</strong></p><p><strong>如下代码中，groupId 和 artifactId 构成了一个 Jar 包的坐标。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>groupId: 所需 Jar 包的项目名</strong></li><li><strong>artifactId: 所需 Jar 包的模块名</strong></li><li><strong>version: 所需 Jar 包的版本号</strong></li></ul><hr><h3 id="依赖范围-scope"><a href="#依赖范围-scope" class="headerlink" title="依赖范围 scope"></a><strong>依赖范围 scope</strong></h3><pre><code>在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </code></pre><ul><li><strong>compile ：默认范围，用于编译</strong>      </li><li><strong>provided：类似于编译，但支持你期待 jdk 或者容器提供，类似于 classpath</strong>      </li><li><strong>runtime: 在执行时需要使用</strong>      </li><li><strong>test:    用于 test 任务时使用</strong>      </li><li><strong>system: 需要外在提供相应的元素。通过 systemPath 来取得</strong>      </li><li><strong>systemPath: 仅用于范围为 system。提供相应的路径</strong>      </li><li><strong>optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用</strong></li></ul><h2 id="传递依赖-与-排除依赖"><a href="#传递依赖-与-排除依赖" class="headerlink" title="传递依赖 与 排除依赖"></a><strong>传递依赖 与 排除依赖</strong></h2><hr><ul><li><strong>传递依赖：如果我们的项目引用了一个 Jar 包，而该 Jar 包又引用了其他 Jar 包，那么在默认情况下项目编译时，Maven 会把直接引用和简洁引用的 Jar 包都下载到本地。</strong></li><li><strong>排除依赖：如果我们只想下载直接引用的 Jar 包，那么需要在 pom.xml 中做如下配置：(将需要排除的 Jar 包的坐标写在中)</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a><strong>依赖冲突</strong></h3><hr><p>​    <strong>若项目中多个 Jar 同时引用了相同的 Jar 时，会产生依赖冲突，但 Maven 采用了两种避免冲突的策略，因此在 Maven 中是不存在依赖冲突的。</strong></p><ul><li><strong>路径优先</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;C.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;C.jar——&gt;X.jar</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</code></strong></p></li><li><p><strong><code>本项目——&gt;C.jar——&gt;X.jar</code></strong></p></li></ul><p><strong><code>若本项目引用了 A.jar，A.jar 又引用了 B.jar，B.jar 又引用了 X.jar，并且 C.jar 也引用了 X.jar。</code></strong></p><p><strong><code>在此时，Maven 只会引用引用路径最短的 Jar。</code></strong></p><ul><li><p><strong>声明优先</strong></p><p><strong><code>若引用路径长度相同时，在 pom.xml 中谁先被声明，就使用谁。</code></strong></p></li></ul><hr><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h3><ul><li><strong>什么是聚合？</strong></li></ul><p><strong><code>将多个项目同时运行就称为聚合。</code></strong></p><ul><li><strong>如何实现聚合？</strong></li></ul><p><strong>只需在 pom 中作如下配置即可实现聚合：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><hr><ol><li><p><strong>什么是继承？</strong></p><p><strong>在聚合多个项目时，如果这些被聚合的项目中需要引入相同的 Jar，那么可以将这些 Jar 写入父 pom 中，各个子项目继承该 pom 即可。</strong></p></li><li><p><strong>如何实现继承？</strong></p></li></ol><ul><li><strong>父 pom 配置：将需要继承的 Jar 包的坐标放入标签即可。</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>子pom配置:</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><hr><h2 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a><strong>git是什么</strong></h2><p>​    <strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="工作原理-流程："><a href="#工作原理-流程：" class="headerlink" title="工作原理 / 流程："></a><strong>工作原理 / 流程：</strong></h2><p><strong><img src="https://img.mukewang.com/59c31e4400013bc911720340.png" alt="Git工作原理"></strong></p><p><strong>Workspace：工作区</strong><br><strong>Index / Stage：暂存区</strong><br><strong>Repository：仓库区（或本地仓库）</strong><br><strong>Remote：远程仓库</strong></p><h3 id="SVN与Git的最主要的区别"><a href="#SVN与Git的最主要的区别" class="headerlink" title="SVN与Git的最主要的区别"></a><strong>SVN与Git的最主要的区别</strong></h3><hr><p>​    <strong>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</strong></p><p>​    <strong>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</strong></p><h3 id="创建仓库-repository"><a href="#创建仓库-repository" class="headerlink" title="创建仓库(repository)"></a><strong>创建仓库(repository)</strong></h3><hr><p><strong>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</strong></p><ol><li><p><strong>首先创建一个空文件夹</strong></p></li><li><p><strong>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p><strong>执行后会在当前目录下生成.git文件(可能是以隐藏文件的形式)</strong></p></li></ol><h3 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a><strong>把文件添加到仓库</strong></h3><hr><ol><li><p><strong>第一步，在当前路径下创建文件 readme.txt</strong></p></li><li><p><strong>第二步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</strong></p><p><strong><code>$git add redme.txt</code></strong></p></li><li><p><strong>用命令<code>git commit</code>告诉Git，把文件提交到仓库：</strong></p><p><strong><code>$ git commit -m &#39;wrote a file&#39;</code></strong></p><p><strong>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</strong></p><p><strong>当然也可以通过<code>git add .</code>添加路径下的所用文件进入.git里 可以不用一个一个添加</strong></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>初始化一个Git仓库，使用<code>git init</code>命令。</strong></p><p><strong>添加文件到Git仓库，分两步：</strong></p><ol><li><strong>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</strong></li><li><strong>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</strong></li></ol><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a><strong>版本回滚</strong></h3><hr><p>​    <strong>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</strong></p><p><strong><code>使用git log查看提交</code></strong></p><hr><p><strong>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</strong></p><p><strong>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>：（如果用commit_id进行回滚操作，可以只用写部分id但要确定结果唯一）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><strong>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>现在总结一下：</strong></p><ul><li><strong><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</strong></li><li><strong>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</strong></li><li><strong>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</strong></li></ul><h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a><strong>工作区与暂存区</strong></h3><hr><ul><li><p><strong>工作区: 就是你在电脑里能看到的目录，就是你放在.git的同级目录下除了.git文件(<del>怎么有点拗口</del>)</strong></p></li><li><h4 id="版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。"><a href="#版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。" class="headerlink" title="版本库（Repository）:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。"></a><strong>版本库（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</strong></h4><p><strong>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</strong></p></li></ul><p>  <strong><img src="https://static.liaoxuefeng.com/files/attachments/919020037470528/0" alt="工作区与缓存区"></strong></p><p>  <strong>分支和<code>HEAD</code>的概念我们以后再讲。</strong></p><p>  <strong>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</strong></p><p>  <strong>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</strong></p><p>  <strong>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</strong></p><p>  <strong>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</strong></p><p>  <strong>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p><p>  <strong>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</strong></p><ul><li><p><strong><code>命令</code>git checkout – readme.txt<code>意思就是，把</code>readme.txt`文件在工作区的修改全部撤销，这里有两种情况：</strong></p><p><strong>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</strong></p><p><strong>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</strong></p><p><strong>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</strong></p></li><li><p><strong>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</strong></p><p><strong><code>$ rm test.txt</code></strong></p><p><strong>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</strong></p><p><strong>现在，文件就从版本库中被删除了。</strong></p><p><strong>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</strong></p><p><strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></p></li></ul><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a><strong>添加远程库</strong></h2><hr><p>​    <strong>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</strong></p><p>​    <strong>添加后，远程库的名字就是<code>origin</code>，这是 Git 默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</strong></p><p>​    <strong>关联后，使用命令<code>git push -u origin master</code>第一次推送 master 分支的所有内容；</strong></p><p><strong>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</strong></p><p><strong>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git 不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</strong></p><hr><p>​    <strong>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</strong></p><p>​    <strong>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</strong></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Holiday summary(一)</title>
    <link href="http://yxm666.github.io/2019/08/15/holiday%20summary(%E4%B8%80)/"/>
    <id>http://yxm666.github.io/2019/08/15/holiday summary(一)/</id>
    <published>2019-08-15T07:40:34.000Z</published>
    <updated>2019-08-17T06:21:38.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>  <strong>如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用来超越别人的(<del>我可不干这种事情，主要我太懒</del>)。暑假一个月，说少不少，说多不多，但在平常的学习上很少有时间可以进行这样集中的编程知识的学习，不时成为锤炼自己的好时机。假期确实提升了很多，有必要进行一些梳理，进行一些总结。当然本次只是给一些技术的进行大概的总结，涉及的知识不会太深。</strong></p></blockquote><h1 id="看看学了什么"><a href="#看看学了什么" class="headerlink" title="看看学了什么"></a>看看学了什么</h1><p>  <strong>让我们首先以一张思维导图开始这篇博文<del>哇 好专业 666鸭</del>,图里包含了这个暑假学到或者了解到<del>当然不可能面面俱到</del>。右边是框架的学习，左边是较为细一点<del>反正自己能理解的一个划分</del>东西还算比较多，够唠一会的了。</strong></p><p><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></p><hr><h1 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h1><hr><h2 id="框架学习之SSM框架"><a href="#框架学习之SSM框架" class="headerlink" title="框架学习之SSM框架"></a>框架学习之SSM框架</h2><p>​    <strong>作为一个9102年学框架的后端Java开发人员，当然要从SSM框架学起(<del>学校还在教着SSH</del>),SSM框架即为Spring、SPring MVC、Mybatis。框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。</strong></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>　　<strong>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。</strong></p><p>　　<strong>Spring的核心思想是IoC（控制反转），面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</strong></p><p>​    <strong>(<del>上面的粘贴自百度</del>)在我的理解里，Spring 主要分为2部分(IOC与AOP)，IOC就是帮你创建对象的，而不用每一个都自己new，通过依赖注入实现程序之间的解耦。框架的出现大多都是提供良好的封装性、实现程序的高内聚与低耦合。</strong></p><p>​    <strong>AOP 即 Aspect Oriented Program 面向切面编程。首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</strong></p><ul><li><p><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</p></li><li><p><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</p></li></ul><p>  <strong>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</strong></p><h4 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h4><p>  <strong>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性。</strong></p><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p>  ​    <strong>AOP的是让开发人员更专注于核心业务的处理，而不用在核心业务的周围围绕着周边业务，增大代码量，让代码的可读性变差，耦合度增加。</strong></p><p>  <img src="https://i.loli.net/2019/08/15/jQL21EqZiHlVzSC.png" alt="Spring特征"></p><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>​    <strong>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</strong></p><p>​    <strong>pring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。Spring MVC 是 Spring 产品组合的一部分，它享有 Spring IoC容器紧密结合Spring松耦合等特点，因此它有Spring的所有优点。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="Spring MVC 架构图"></p><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a><strong>mybatis</strong></h3><p>​    <strong>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</strong></p><p>　　<strong>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</strong></p><p>​    <strong>页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。(三层架构)</strong></p><hr><h2 id="框架学习之Spring-Boot"><a href="#框架学习之Spring-Boot" class="headerlink" title="框架学习之Spring Boot"></a>框架学习之Spring Boot</h2><blockquote><p><strong>Spring Boot 作为以后后端开发的使用框架，在Spring、Spring MVC 基础上减少了大量的配置，作为一种开箱即用的框架，大大简化了开发人员的开发流程。</strong></p></blockquote><h4 id="首先分享一些比较好的学习连接资源"><a href="#首先分享一些比较好的学习连接资源" class="headerlink" title="首先分享一些比较好的学习连接资源"></a><strong>首先分享一些比较好的学习连接资源</strong></h4><ul><li><p><a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Boot 官方文档</a></p></li><li><p><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引</a></p></li><li><p><a href="http://www.springboot.wiki/" target="_blank" rel="noopener">Spring Boot 教程汇总</a></p></li><li><p><a href="https://www.javaboy.org/springboot/" target="_blank" rel="noopener">江南一点雨 Spring Boot 系列文章</a></p></li><li><p><a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑 Spring Boot 系列文章</a></p><hr><h4 id="什么是Spring-Boot呢？"><a href="#什么是Spring-Boot呢？" class="headerlink" title="什么是Spring Boot呢？"></a>什么是Spring Boot呢？</h4><p>​    <strong>什么是Spring Boot？他跟SPring又有什么关系?怎么又来了一种新的框架？相信无数初学者都曾想过这些问题。首先Spring Boot并非是一种全新的框架。Boot即为启动的意思，旨在快速启动你的Spring项目并通过一些自动配置来减少人为的主动配置。并且Spring Boot 对一些主流框架都有整合的Start,他就像一个框架届的Maven，通过对框架的整合，让开发变得简单起来。</strong></p><p><img src="https://spring.io/img/homepage/icon-spring-boot.svg" alt="Spring Boot"></p></li></ul><h4 id="Spring-boot的四个主要特性"><a href="#Spring-boot的四个主要特性" class="headerlink" title="Spring boot的四个主要特性"></a>Spring boot的四个主要特性</h4><ul><li><p><strong>独立运行的Spring项目</strong>：Spring Boot可以以jar包的形式来运行，运行一个Spring Boot项目我们只需要通过java -jar xx.jar类运行。非常方便。</p></li><li><p><strong>内嵌Servlet容器</strong>：Spring Boot可以内嵌Tomcat，这样我们无需以war包的形式部署项目。</p></li><li><p><strong>提供starter简化Maven配置</strong>：使用Spring或者SpringMVC我们需要添加大量的依赖，而这些依赖很多都是固定的，这里Spring Boot 通过starter能够帮助我们简化Maven配置。</p></li><li><p><strong>自动配置Spring</strong></p></li><li><p><strong>准生产的应用监控</strong></p></li><li><p><strong>无代码生成和xml配置</strong></p><hr></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>暂时先大概的说下这2个后端框架吧，只是大概的讲讲这些框架的有什么作用以及它们的应用，之后再写写那些中间件,溜啦😉😉😉😉<del>~</del></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  &lt;strong&gt;如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>just one year</title>
    <link href="http://yxm666.github.io/2019/08/13/just-one-year/"/>
    <id>http://yxm666.github.io/2019/08/13/just-one-year/</id>
    <published>2019-08-13T10:19:50.000Z</published>
    <updated>2019-08-15T08:01:21.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>​    <strong>不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输出了“hello world”而开心不已，如今我已经开始写接口文档，进行前后端的分离开发。是时候在一个深夜(凌晨两点)去回忆一下，这一年的日子，去想想得失，想想时间带来了什么。</strong></p></blockquote><hr><p><img src="https://i.loli.net/2019/08/13/eZx8HOj4bs95of6.jpg" alt="梦想"></p><h2 id="去年暑假"><a href="#去年暑假" class="headerlink" title="去年暑假"></a>去年暑假</h2><p>​    <strong>为什么选做一个程序员呢？可能比较喜欢搞点好东西，获取一些酷酷的软件、插件就像如同获得了宝藏一样，让我开心不已，经常为了折腾某一个软件去折腾好几天(比如搞这个花里胡哨的博客折腾了我3天)。确定了想要学软件后，我开始私聊了一些学长咨询。可能这也是一切的起点吧，我知道了当时学校有一个实验室叫软件创新基地。当时的我就立志想进软创。故事就由此展开了。</strong><br>​    <strong>开始去B站上找了浙江大学的视频看，还傻傻的拿了笔记本写了笔记，后来因为去打工，算是搁置了，只看到了循环？之后打工的经历或许也改变了我，它让我变得现实了，待人接物也大不相同了。</strong>```</p><hr><h2 id="初识-（9月-11月"><a href="#初识-（9月-11月" class="headerlink" title="初识  （9月-11月)"></a>初识  （9月-11月)</h2><p>​    <strong>一切都那么新鲜，对什么事情都充满了好奇，什么都想尝试，比如吃一口苹果。这一次我为自己的新鲜感与欠妥当付出了代价，这个甜甜的苹果的滋味知道如今仍然在嘴中回荡只是略带苦涩。可一切都没有重来的余地，何况曾今的*也给过我满嘴的芬芳。</strong></p><p>​    <strong>聊些技术有关的吧。在知道软创有考核时，当时被安利买了 《C prime plus》的我每天都在6点钟去看书，默默为它做准备，是这一年来去图书馆最勤的时候。如我所愿，我通过了面试。可这不意味着安稳，一次一次考核，身边的空位开始变多，不敢松懈，不敢停下。一本厚厚的书也被我做足了笔记，没有电脑就自己推演结果，有电脑就在电脑上执行一次。一步一步，到了指针等什么乱七八糟的东西，令人头疼、头秃。之后进行了C语言实训项目的提前编程。说实话，刚开始的时候，我大概有 3、4天都不知道从何下手，翻翻CSDN、问问谷歌。先编写了骚气的功能界面(唉，骚气慢慢的我)，可是输入的验证却难住了我，判断用户的输入，进行提示反馈。从百度的加上我自己考虑的，大概脑子里有个谱了，添加、显示、更新、删除，最开始的CRUD的实现。万事开头难，这个项目费事程度比我以后碰到bug解决时间都长，可一切都值得的。</strong></p><p><img src="https://i.loli.net/2019/08/13/8xzAhus1pDJ24rB.jpg" alt="dva爱你哟"></p><hr><h2 id="Time-to-change-12月-2月"><a href="#Time-to-change-12月-2月" class="headerlink" title="Time to change(12月-2月)"></a>Time to change(12月-2月)</h2><p>​    <strong>初入茅庐的我，起初觉得学完了C语言，好像感到自己已经精通了编程一样，有些飘飘然。而Java作为一门以后用来吃饭的语言，显然不仅仅只需要掌握语法，编程也不仅仅只是编程语言的学习，事实上开发中的问题总会接踵而至。学习OOP语言，在没有面向对象思想的我一时间难以理解，尤其是构造方法，子父类等等。在接触新事物的时候，这些都是难免的，在自己试错自己找到解决方法后对知识的牢记与成就感是他人直接告诉你结果的感觉是截然不同的。诚然，试错是成长路上不可或缺的一部。</strong></p><p>​    <strong>在越过了OOP的坎后，后面几大章也并不轻松(虽然学校一点都不讲),IO、集合、多线程、网络编程，说实话，这些知识当时因为学的太快并没有留下很深印象(毕竟一个半月学会一门编程语音显得并没有那么轻松)，不过在当时也算是掌握的算不错，当然在下学期(大二上)，如果有功夫的话是需要好好回顾的，毕竟Java SE是基础。</strong></p><p>​        <strong>好了又到了做项目的时候。项目所需的知识总和你掌握的知识有一定的差距，这些短板也会在项目中补齐。当时刚做项目的时候，感觉链接数据库(JDBC)都是一个难点，索性找到了一个黑马的管家婆(这名字土爆了)的视频，跟着学习。我一直觉得程序猿跟画家一样，开始时候进行描摹，从别人的画中找到感觉，再进行自己的创作。收获颇多的可能不是会根据老师讲的可以完成自己的项目，而是视频中的MVC思想，让我对分层进行了了解(我想会抽个文章写一下MVC与三层架构的那些事)。虽说凭借着MAC的美学设计，不用加任何修饰，程序的界面简洁优雅(吹爆MBP)，也算是第一次进行了可视化程序。点点按按的总比命令行好，虽然程序员的原则是能用键盘的事情绝不用鼠标，笑。</strong></p><p>​    <strong>有些事情总算没有了挽回的余地，事实上，一些事情早都可以预料却不能坦然面对，总之，各自安好。可是真的安好了嘛？我开始不推心置腹，开始冷眼旁边，开始置身事外，我真的不明白或者看不透嘛？可能就是看的太透才会这样。一切的一切都Don’t Care，它好像一颗慢性毒药，一点一点再暗暗杀死我，而我却品尝着这令人上瘾的滋味。</strong></p><p><img src="https://i.loli.net/2019/08/13/SfIQpjAPlTytq96.jpg" alt="前路"></p><hr><h2 id="得失-3月-6月"><a href="#得失-3月-6月" class="headerlink" title="得失     (3月-6月)"></a>得失     (3月-6月)</h2><p>​    <strong>well，下学期就放一个章节说好了。学完了Java SE，开始了Java Web的内容。我觉得还是明确个方向学习Java Web 是比较好的(<del>我一辈子不要写标签！！！！</del>)，但是在Java web中也算踩坑严重吧，因为一些事情的耽误，学的比较拖拉，导致又反反复复学习，最后学了大概来来回回有3遍，可能加深印象了？web作为框架的基础，是有必要学习的，当时急切的想要有后端的开发能力(<del>框架方便啊</del>)，所以急于求成，现在也有点后悔，项目也做了稀巴烂，几个月都感觉压力与失望，比较丧。</strong></p><p><strong>不过也有好的一面不是嘛？失去了一些东西后，更有精力专注于自己的事情上，每天做规划，几点到几点锻炼腹肌，几点到几点撸铁，晚上每天带着耳机去看着带着晚霞的体育场，带着耳机跑5km,那种每天回想起来一切都按自己计划执行，每天没有辜负自己的完美生活令自己开心不已，每天都对明天充满期待，体脂率一点点下降，肌肉率一点点上升，感觉生活充满了期望。(<del>哦，看看现在，天天敲代码，摸着自己的小肚子</del>)</strong></p><p><img src="https://s2.ax1x.com/2019/08/14/mihcad.png" alt="傍晚的体育场"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一年的时光，感觉自己学会了很多，失去了很多，得到了许多，经历了许许多多的美好，也丧了很长时间。可这就是生活，起起伏伏伏伏伏伏伏伏伏伏伏伏，希望自己可以继续朝着自己向往的生活努力，向着自己想成为的人而努力。等待下一个一年。</strong></p><p><img src="https://i.loli.net/2019/08/13/5n49bWIwku1XctT.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="编程" scheme="http://yxm666.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
