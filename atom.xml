<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  <subtitle>读书 + 赚钱 + 健身 = 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxm666.github.io/"/>
  <updated>2019-08-19T04:06:42.630Z</updated>
  <id>http://yxm666.github.io/</id>
  
  <author>
    <name>遠見卓識</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Holiday summary(二)</title>
    <link href="http://yxm666.github.io/2019/08/17/Holiday-summary-%E4%BA%8C/"/>
    <id>http://yxm666.github.io/2019/08/17/Holiday-summary-二/</id>
    <published>2019-08-17T06:32:52.000Z</published>
    <updated>2019-08-19T04:06:42.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><blockquote><p><strong>跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我们看看都有啥吧。</strong></p></blockquote><hr><p><strong><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></strong></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><hr><p>​    <strong>Maven 、git 算是2个编程比较常用的工具吧，但是为了有区别一点还是单独拉出来了。</strong></p><hr><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h2><pre><code>**Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。**</code></pre><p><strong>Maven主要做了两件事：</strong></p><ol><li><strong>统一开发规范与工具</strong></li><li><strong>统一管理jar包</strong></li><li><strong>Maven常用指令</strong></li></ol><hr><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a><strong>Maven项目结构</strong></h3><p>​    <strong>若要使用 Maven，那么项目的目录结构必须符合 Maven 的规范，其目录结构如下：</strong></p><p>​    <strong><img src="https://img-blog.csdn.net/201808131239225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVxdWFucXVxbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Maven目录jΩΩΩ"></strong></p><h3 id="Maven-基本命令"><a href="#Maven-基本命令" class="headerlink" title="Maven 基本命令"></a><strong>Maven 基本命令</strong></h3><hr><ol><li><p><strong>-v: 查询 Maven 版本</strong></p><p><strong>本命令用于检查 maven 是否安装成功。</strong></p><p><strong>Maven 安装完成之后，在命令行输入 mvn -v，若出现 maven 信息，则说明安装成功。</strong></p></li><li><p><strong>compile：编译</strong></p><p><strong>将 java 源文件编译成 class 文件</strong></p></li><li><p><strong>test: 测试项目</strong></p><p><strong>执行 test 目录下的测试用例</strong></p></li><li><p><strong>package: 打包</strong></p><p><strong>将项目打成 jar 包</strong></p></li><li><p><strong>clean: 删除 target 文件夹</strong></p></li><li><p><strong>install: 安装</strong></p><p><strong>将当前项目放到 Maven 的本地仓库中。供其他项目使用</strong></p></li></ol><hr><h3 id="Maven的仓库"><a href="#Maven的仓库" class="headerlink" title="Maven的仓库"></a><strong>Maven的仓库</strong></h3><hr><p><strong>Maven 仓库用来存放 Maven 管理的所有 Jar 包。分为：本地仓库 和 中央仓库。</strong></p><ul><li><strong>本地仓库：Maven 本地的 Jar 包仓库。</strong></li><li><strong>中央仓库： Maven 官方提供的远程仓库。</strong></li></ul><p><strong><code>当项目编译时，Maven 首先从本地仓库中寻找项目所需的 Jar 包，若本地仓库没有，再到 Maven 的中央仓库下载所需 Jar 包。</code></strong></p><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a><strong>坐标</strong></h3><hr><p><strong>在 Maven 中，坐标是 Jar 包的唯一标识，Maven 通过坐标在仓库中找到项目所需的 Jar 包，通过<a href="https://mvnrepository.com/" target="_blank" rel="noopener">官方依赖仓库</a>去寻找</strong></p><p><strong>如下代码中，groupId 和 artifactId 构成了一个 Jar 包的坐标。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>groupId: 所需 Jar 包的项目名</strong></li><li><strong>artifactId: 所需 Jar 包的模块名</strong></li><li><strong>version: 所需 Jar 包的版本号</strong></li></ul><hr><h3 id="依赖范围-scope"><a href="#依赖范围-scope" class="headerlink" title="依赖范围 scope"></a><strong>依赖范围 scope</strong></h3><pre><code>在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </code></pre><ul><li><strong>compile ：默认范围，用于编译</strong>      </li><li><strong>provided：类似于编译，但支持你期待 jdk 或者容器提供，类似于 classpath</strong>      </li><li><strong>runtime: 在执行时需要使用</strong>      </li><li><strong>test:    用于 test 任务时使用</strong>      </li><li><strong>system: 需要外在提供相应的元素。通过 systemPath 来取得</strong>      </li><li><strong>systemPath: 仅用于范围为 system。提供相应的路径</strong>      </li><li><strong>optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用</strong></li></ul><h2 id="传递依赖-与-排除依赖"><a href="#传递依赖-与-排除依赖" class="headerlink" title="传递依赖 与 排除依赖"></a><strong>传递依赖 与 排除依赖</strong></h2><hr><ul><li><strong>传递依赖：如果我们的项目引用了一个 Jar 包，而该 Jar 包又引用了其他 Jar 包，那么在默认情况下项目编译时，Maven 会把直接引用和简洁引用的 Jar 包都下载到本地。</strong></li><li><strong>排除依赖：如果我们只想下载直接引用的 Jar 包，那么需要在 pom.xml 中做如下配置：(将需要排除的 Jar 包的坐标写在中)</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a><strong>依赖冲突</strong></h3><hr><p>​    <strong>若项目中多个 Jar 同时引用了相同的 Jar 时，会产生依赖冲突，但 Maven 采用了两种避免冲突的策略，因此在 Maven 中是不存在依赖冲突的。</strong></p><ul><li><strong>路径优先</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本项目——&gt;<span class="selector-tag">A</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">B</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">X</span><span class="selector-class">.jar</span></span><br><span class="line">本项目——&gt;<span class="selector-tag">C</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">X</span><span class="selector-class">.jar</span></span><br><span class="line">本项目——&gt;<span class="selector-tag">A</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">B</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">X</span><span class="selector-class">.jar</span></span><br><span class="line">本项目——&gt;<span class="selector-tag">C</span><span class="selector-class">.jar</span>——&gt;<span class="selector-tag">X</span><span class="selector-class">.jar</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</code></strong></p></li><li><p><strong><code>本项目——&gt;C.jar——&gt;X.jar</code></strong></p></li></ul><p><strong><code>若本项目引用了 A.jar，A.jar 又引用了 B.jar，B.jar 又引用了 X.jar，并且 C.jar 也引用了 X.jar。</code></strong></p><p><strong><code>在此时，Maven 只会引用引用路径最短的 Jar。</code></strong></p><ul><li><p><strong>声明优先</strong></p><p><strong><code>若引用路径长度相同时，在 pom.xml 中谁先被声明，就使用谁。</code></strong></p></li></ul><hr><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h3><ul><li><strong>什么是聚合？</strong></li></ul><p><strong><code>将多个项目同时运行就称为聚合。</code></strong></p><ul><li><strong>如何实现聚合？</strong></li></ul><p><strong>只需在 pom 中作如下配置即可实现聚合：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><hr><ol><li><p><strong>什么是继承？</strong></p><p><strong>在聚合多个项目时，如果这些被聚合的项目中需要引入相同的 Jar，那么可以将这些 Jar 写入父 pom 中，各个子项目继承该 pom 即可。</strong></p></li><li><p><strong>如何实现继承？</strong></p></li></ol><ul><li><strong>父 pom 配置：将需要继承的 Jar 包的坐标放入标签即可。</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>子pom配置:</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><hr><h2 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a><strong>git是什么</strong></h2><p>​    <strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="工作原理-流程："><a href="#工作原理-流程：" class="headerlink" title="工作原理 / 流程："></a><strong>工作原理 / 流程：</strong></h2><p><strong><img src="https://img.mukewang.com/59c31e4400013bc911720340.png" alt="Git工作原理"></strong></p><p><strong>Workspace：工作区</strong><br><strong>Index / Stage：暂存区</strong><br><strong>Repository：仓库区（或本地仓库）</strong><br><strong>Remote：远程仓库</strong></p><h3 id="SVN与Git的最主要的区别"><a href="#SVN与Git的最主要的区别" class="headerlink" title="SVN与Git的最主要的区别"></a><strong>SVN与Git的最主要的区别</strong></h3><hr><p>​    <strong>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</strong></p><p>​    <strong>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</strong></p><h3 id="创建仓库-repository"><a href="#创建仓库-repository" class="headerlink" title="创建仓库(repository)"></a><strong>创建仓库(repository)</strong></h3><hr><p><strong>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</strong></p><ol><li><p><strong>首先创建一个空文件夹</strong></p></li><li><p><strong>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/Users/mi</span>chael<span class="regexp">/learngit/</span>.git<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p><strong>执行后会在当前目录下生成.git文件(可能是以隐藏文件的形式)</strong></p></li></ol><h3 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a><strong>把文件添加到仓库</strong></h3><hr><ol><li><p><strong>第一步，在当前路径下创建文件 readme.txt</strong></p></li><li><p><strong>第二步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</strong></p><p><strong><code>$git add redme.txt</code></strong></p></li><li><p><strong>用命令<code>git commit</code>告诉Git，把文件提交到仓库：</strong></p><p><strong><code>$ git commit -m &#39;wrote a file&#39;</code></strong></p><p><strong>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</strong></p><p><strong>当然也可以通过<code>git add .</code>添加路径下的所用文件进入.git里 可以不用一个一个添加</strong></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>初始化一个Git仓库，使用<code>git init</code>命令。</strong></p><p><strong>添加文件到Git仓库，分两步：</strong></p><ol><li><strong>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</strong></li><li><strong>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</strong></li></ol><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a><strong>版本回滚</strong></h3><hr><p>​    <strong>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</strong></p><p><strong><code>使用git log查看提交</code></strong></p><hr><p><strong>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit <span class="number">1094</span>adb<span class="number">7</span>b<span class="number">9</span>b<span class="number">3807259</span>d<span class="number">8</span>cb<span class="number">349e7</span>df<span class="number">1</span>d<span class="number">4</span>d<span class="number">6477073</span> (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e<span class="number">475</span>afc<span class="number">93</span><span class="keyword">c</span><span class="number">209</span>a<span class="number">690</span><span class="keyword">c</span><span class="number">39</span><span class="keyword">c</span><span class="number">13</span>a<span class="number">46716e8</span>fa<span class="number">000</span><span class="keyword">c</span><span class="number">366</span></span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">36</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> distributed</span><br><span class="line"></span><br><span class="line">commit eaadf<span class="number">4e385</span>e<span class="number">865</span>d<span class="number">25</span><span class="keyword">c</span><span class="number">48e7</span>ca<span class="number">9</span><span class="keyword">c</span><span class="number">8395</span><span class="keyword">c</span><span class="number">3</span>f<span class="number">7</span>dfaef<span class="number">0</span></span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">18</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line"><span class="number">1094</span>adb<span class="number">7</span>b<span class="number">9</span>b<span class="number">3807259</span>d<span class="number">8</span>cb<span class="number">349e7</span>df<span class="number">1</span>d<span class="number">4</span>d<span class="number">6477073</span> (HEAD -&gt; master) append GPL</span><br><span class="line">e<span class="number">475</span>afc<span class="number">93</span><span class="keyword">c</span><span class="number">209</span>a<span class="number">690</span><span class="keyword">c</span><span class="number">39</span><span class="keyword">c</span><span class="number">13</span>a<span class="number">46716e8</span>fa<span class="number">000</span><span class="keyword">c</span><span class="number">366</span> <span class="keyword">add</span> distributed</span><br><span class="line">eaadf<span class="number">4e385</span>e<span class="number">865</span>d<span class="number">25</span><span class="keyword">c</span><span class="number">48e7</span>ca<span class="number">9</span><span class="keyword">c</span><span class="number">8395</span><span class="keyword">c</span><span class="number">3</span>f<span class="number">7</span>dfaef<span class="number">0</span> wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</strong></p><p><strong>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>：（如果用commit_id进行回滚操作，可以只用写部分id但要确定结果唯一）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span><br><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> e475afc <span class="keyword">add</span> <span class="keyword">distributed</span></span><br></pre></td></tr></table></figure><p><strong>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;<span class="number">1</span>&#125;: rese<span class="variable">t:</span> moving <span class="keyword">to</span> HEAD^</span><br><span class="line"><span class="number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="number">2</span>&#125;: commi<span class="variable">t:</span> <span class="keyword">append</span> GPL</span><br><span class="line">e475afc HEAD@&#123;<span class="number">3</span>&#125;: commi<span class="variable">t:</span> <span class="built_in">add</span> distributed</span><br><span class="line">eaadf4e HEAD@&#123;<span class="number">4</span>&#125;: commit (initial): wrote <span class="keyword">a</span> readme <span class="keyword">file</span></span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>现在总结一下：</strong></p><ul><li><strong><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</strong></li><li><strong>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</strong></li><li><strong>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</strong></li></ul><h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a><strong>工作区与暂存区</strong></h3><hr><ul><li><p><strong>工作区: 就是你在电脑里能看到的目录，就是你放在.git的同级目录下除了.git文件(<del>怎么有点拗口</del>)</strong></p></li><li><h4 id="版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。"><a href="#版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。" class="headerlink" title="版本库（Repository）:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。"></a><strong>版本库（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</strong></h4><p><strong>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</strong></p></li></ul><p>  <strong><img src="https://static.liaoxuefeng.com/files/attachments/919020037470528/0" alt="工作区与缓存区"></strong></p><p>  <strong>分支和<code>HEAD</code>的概念我们以后再讲。</strong></p><p>  <strong>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</strong></p><p>  <strong>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</strong></p><p>  <strong>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</strong></p><p>  <strong>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</strong></p><p>  <strong>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p><p>  <strong>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</strong></p><ul><li><p><strong><code>命令</code>git checkout – readme.txt<code>意思就是，把</code>readme.txt`文件在工作区的修改全部撤销，这里有两种情况：</strong></p><p><strong>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</strong></p><p><strong>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</strong></p><p><strong>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</strong></p></li><li><p><strong>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</strong></p><p><strong><code>$ rm test.txt</code></strong></p><p><strong>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</strong></p><p><strong>现在，文件就从版本库中被删除了。</strong></p><p><strong>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</strong></p><p><strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></p></li></ul><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a><strong>添加远程库</strong></h2><hr><p>​    <strong>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</strong></p><p>​    <strong>添加后，远程库的名字就是<code>origin</code>，这是 Git 默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</strong></p><p>​    <strong>关联后，使用命令<code>git push -u origin master</code>第一次推送 master 分支的所有内容；</strong></p><p><strong>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</strong></p><p><strong>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git 不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</strong></p><hr><p>​    <strong>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</strong></p><p>​    <strong>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</strong></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Holiday summary(一)</title>
    <link href="http://yxm666.github.io/2019/08/15/holiday%20summary(%E4%B8%80)/"/>
    <id>http://yxm666.github.io/2019/08/15/holiday summary(一)/</id>
    <published>2019-08-15T07:40:34.000Z</published>
    <updated>2019-08-17T06:21:38.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>  <strong>如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用来超越别人的(<del>我可不干这种事情，主要我太懒</del>)。暑假一个月，说少不少，说多不多，但在平常的学习上很少有时间可以进行这样集中的编程知识的学习，不时成为锤炼自己的好时机。假期确实提升了很多，有必要进行一些梳理，进行一些总结。当然本次只是给一些技术的进行大概的总结，涉及的知识不会太深。</strong></p></blockquote><h1 id="看看学了什么"><a href="#看看学了什么" class="headerlink" title="看看学了什么"></a>看看学了什么</h1><p>  <strong>让我们首先以一张思维导图开始这篇博文<del>哇 好专业 666鸭</del>,图里包含了这个暑假学到或者了解到<del>当然不可能面面俱到</del>。右边是框架的学习，左边是较为细一点<del>反正自己能理解的一个划分</del>东西还算比较多，够唠一会的了。</strong></p><p><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></p><hr><h1 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h1><hr><h2 id="框架学习之SSM框架"><a href="#框架学习之SSM框架" class="headerlink" title="框架学习之SSM框架"></a>框架学习之SSM框架</h2><p>​    <strong>作为一个9102年学框架的后端Java开发人员，当然要从SSM框架学起(<del>学校还在教着SSH</del>),SSM框架即为Spring、SPring MVC、Mybatis。框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。</strong></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>　　<strong>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。</strong></p><p>　　<strong>Spring的核心思想是IoC（控制反转），面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</strong></p><p>​    <strong>(<del>上面的粘贴自百度</del>)在我的理解里，Spring 主要分为2部分(IOC与AOP)，IOC就是帮你创建对象的，而不用每一个都自己new，通过依赖注入实现程序之间的解耦。框架的出现大多都是提供良好的封装性、实现程序的高内聚与低耦合。</strong></p><p>​    <strong>AOP 即 Aspect Oriented Program 面向切面编程。首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</strong></p><ul><li><p><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</p></li><li><p><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</p></li></ul><p>  <strong>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</strong></p><h4 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h4><p>  <strong>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性。</strong></p><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p>  ​    <strong>AOP的是让开发人员更专注于核心业务的处理，而不用在核心业务的周围围绕着周边业务，增大代码量，让代码的可读性变差，耦合度增加。</strong></p><p>  <img src="https://i.loli.net/2019/08/15/jQL21EqZiHlVzSC.png" alt="Spring特征"></p><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>​    <strong>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</strong></p><p>​    <strong>pring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。Spring MVC 是 Spring 产品组合的一部分，它享有 Spring IoC容器紧密结合Spring松耦合等特点，因此它有Spring的所有优点。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="Spring MVC 架构图"></p><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a><strong>mybatis</strong></h3><p>​    <strong>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</strong></p><p>　　<strong>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</strong></p><p>​    <strong>页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。(三层架构)</strong></p><hr><h2 id="框架学习之Spring-Boot"><a href="#框架学习之Spring-Boot" class="headerlink" title="框架学习之Spring Boot"></a>框架学习之Spring Boot</h2><blockquote><p><strong>Spring Boot 作为以后后端开发的使用框架，在Spring、Spring MVC 基础上减少了大量的配置，作为一种开箱即用的框架，大大简化了开发人员的开发流程。</strong></p></blockquote><h4 id="首先分享一些比较好的学习连接资源"><a href="#首先分享一些比较好的学习连接资源" class="headerlink" title="首先分享一些比较好的学习连接资源"></a><strong>首先分享一些比较好的学习连接资源</strong></h4><ul><li><p><a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Boot 官方文档</a></p></li><li><p><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引</a></p></li><li><p><a href="http://www.springboot.wiki/" target="_blank" rel="noopener">Spring Boot 教程汇总</a></p></li><li><p><a href="https://www.javaboy.org/springboot/" target="_blank" rel="noopener">江南一点雨 Spring Boot 系列文章</a></p></li><li><p><a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑 Spring Boot 系列文章</a></p><hr><h4 id="什么是Spring-Boot呢？"><a href="#什么是Spring-Boot呢？" class="headerlink" title="什么是Spring Boot呢？"></a>什么是Spring Boot呢？</h4><p>​    <strong>什么是Spring Boot？他跟SPring又有什么关系?怎么又来了一种新的框架？相信无数初学者都曾想过这些问题。首先Spring Boot并非是一种全新的框架。Boot即为启动的意思，旨在快速启动你的Spring项目并通过一些自动配置来减少人为的主动配置。并且Spring Boot 对一些主流框架都有整合的Start,他就像一个框架届的Maven，通过对框架的整合，让开发变得简单起来。</strong></p><p><img src="https://spring.io/img/homepage/icon-spring-boot.svg" alt="Spring Boot"></p></li></ul><h4 id="Spring-boot的四个主要特性"><a href="#Spring-boot的四个主要特性" class="headerlink" title="Spring boot的四个主要特性"></a>Spring boot的四个主要特性</h4><ul><li><p><strong>独立运行的Spring项目</strong>：Spring Boot可以以jar包的形式来运行，运行一个Spring Boot项目我们只需要通过java -jar xx.jar类运行。非常方便。</p></li><li><p><strong>内嵌Servlet容器</strong>：Spring Boot可以内嵌Tomcat，这样我们无需以war包的形式部署项目。</p></li><li><p><strong>提供starter简化Maven配置</strong>：使用Spring或者SpringMVC我们需要添加大量的依赖，而这些依赖很多都是固定的，这里Spring Boot 通过starter能够帮助我们简化Maven配置。</p></li><li><p><strong>自动配置Spring</strong></p></li><li><p><strong>准生产的应用监控</strong></p></li><li><p><strong>无代码生成和xml配置</strong></p><hr></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>暂时先大概的说下这2个后端框架吧，只是大概的讲讲这些框架的有什么作用以及它们的应用，之后再写写那些中间件,溜啦😉😉😉😉<del>~</del></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  &lt;strong&gt;如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>just one year</title>
    <link href="http://yxm666.github.io/2019/08/13/just-one-year/"/>
    <id>http://yxm666.github.io/2019/08/13/just-one-year/</id>
    <published>2019-08-13T10:19:50.000Z</published>
    <updated>2019-08-15T08:01:21.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>​    <strong>不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输出了“hello world”而开心不已，如今我已经开始写接口文档，进行前后端的分离开发。是时候在一个深夜(凌晨两点)去回忆一下，这一年的日子，去想想得失，想想时间带来了什么。</strong></p></blockquote><hr><p><img src="https://i.loli.net/2019/08/13/eZx8HOj4bs95of6.jpg" alt="梦想"></p><h2 id="去年暑假"><a href="#去年暑假" class="headerlink" title="去年暑假"></a>去年暑假</h2><p>​    <strong>为什么选做一个程序员呢？可能比较喜欢搞点好东西，获取一些酷酷的软件、插件就像如同获得了宝藏一样，让我开心不已，经常为了折腾某一个软件去折腾好几天(比如搞这个花里胡哨的博客折腾了我3天)。确定了想要学软件后，我开始私聊了一些学长咨询。可能这也是一切的起点吧，我知道了当时学校有一个实验室叫软件创新基地。当时的我就立志想进软创。故事就由此展开了。</strong><br>​    <strong>开始去B站上找了浙江大学的视频看，还傻傻的拿了笔记本写了笔记，后来因为去打工，算是搁置了，只看到了循环？之后打工的经历或许也改变了我，它让我变得现实了，待人接物也大不相同了。</strong>```</p><hr><h2 id="初识-（9月-11月"><a href="#初识-（9月-11月" class="headerlink" title="初识  （9月-11月)"></a>初识  （9月-11月)</h2><p>​    <strong>一切都那么新鲜，对什么事情都充满了好奇，什么都想尝试，比如吃一口苹果。这一次我为自己的新鲜感与欠妥当付出了代价，这个甜甜的苹果的滋味知道如今仍然在嘴中回荡只是略带苦涩。可一切都没有重来的余地，何况曾今的*也给过我满嘴的芬芳。</strong></p><p>​    <strong>聊些技术有关的吧。在知道软创有考核时，当时被安利买了 《C prime plus》的我每天都在6点钟去看书，默默为它做准备，是这一年来去图书馆最勤的时候。如我所愿，我通过了面试。可这不意味着安稳，一次一次考核，身边的空位开始变多，不敢松懈，不敢停下。一本厚厚的书也被我做足了笔记，没有电脑就自己推演结果，有电脑就在电脑上执行一次。一步一步，到了指针等什么乱七八糟的东西，令人头疼、头秃。之后进行了C语言实训项目的提前编程。说实话，刚开始的时候，我大概有 3、4天都不知道从何下手，翻翻CSDN、问问谷歌。先编写了骚气的功能界面(唉，骚气慢慢的我)，可是输入的验证却难住了我，判断用户的输入，进行提示反馈。从百度的加上我自己考虑的，大概脑子里有个谱了，添加、显示、更新、删除，最开始的CRUD的实现。万事开头难，这个项目费事程度比我以后碰到bug解决时间都长，可一切都值得的。</strong></p><p><img src="https://i.loli.net/2019/08/13/8xzAhus1pDJ24rB.jpg" alt="dva爱你哟"></p><hr><h2 id="Time-to-change-12月-2月"><a href="#Time-to-change-12月-2月" class="headerlink" title="Time to change(12月-2月)"></a>Time to change(12月-2月)</h2><p>​    <strong>初入茅庐的我，起初觉得学完了C语言，好像感到自己已经精通了编程一样，有些飘飘然。而Java作为一门以后用来吃饭的语言，显然不仅仅只需要掌握语法，编程也不仅仅只是编程语言的学习，事实上开发中的问题总会接踵而至。学习OOP语言，在没有面向对象思想的我一时间难以理解，尤其是构造方法，子父类等等。在接触新事物的时候，这些都是难免的，在自己试错自己找到解决方法后对知识的牢记与成就感是他人直接告诉你结果的感觉是截然不同的。诚然，试错是成长路上不可或缺的一部。</strong></p><p>​    <strong>在越过了OOP的坎后，后面几大章也并不轻松(虽然学校一点都不讲),IO、集合、多线程、网络编程，说实话，这些知识当时因为学的太快并没有留下很深印象(毕竟一个半月学会一门编程语音显得并没有那么轻松)，不过在当时也算是掌握的算不错，当然在下学期(大二上)，如果有功夫的话是需要好好回顾的，毕竟Java SE是基础。</strong></p><p>​        <strong>好了又到了做项目的时候。项目所需的知识总和你掌握的知识有一定的差距，这些短板也会在项目中补齐。当时刚做项目的时候，感觉链接数据库(JDBC)都是一个难点，索性找到了一个黑马的管家婆(这名字土爆了)的视频，跟着学习。我一直觉得程序猿跟画家一样，开始时候进行描摹，从别人的画中找到感觉，再进行自己的创作。收获颇多的可能不是会根据老师讲的可以完成自己的项目，而是视频中的MVC思想，让我对分层进行了了解(我想会抽个文章写一下MVC与三层架构的那些事)。虽说凭借着MAC的美学设计，不用加任何修饰，程序的界面简洁优雅(吹爆MBP)，也算是第一次进行了可视化程序。点点按按的总比命令行好，虽然程序员的原则是能用键盘的事情绝不用鼠标，笑。</strong></p><p>​    <strong>有些事情总算没有了挽回的余地，事实上，一些事情早都可以预料却不能坦然面对，总之，各自安好。可是真的安好了嘛？我开始不推心置腹，开始冷眼旁边，开始置身事外，我真的不明白或者看不透嘛？可能就是看的太透才会这样。一切的一切都Don’t Care，它好像一颗慢性毒药，一点一点再暗暗杀死我，而我却品尝着这令人上瘾的滋味。</strong></p><p><img src="https://i.loli.net/2019/08/13/SfIQpjAPlTytq96.jpg" alt="前路"></p><hr><h2 id="得失-3月-6月"><a href="#得失-3月-6月" class="headerlink" title="得失     (3月-6月)"></a>得失     (3月-6月)</h2><p>​    <strong>well，下学期就放一个章节说好了。学完了Java SE，开始了Java Web的内容。我觉得还是明确个方向学习Java Web 是比较好的(<del>我一辈子不要写标签！！！！</del>)，但是在Java web中也算踩坑严重吧，因为一些事情的耽误，学的比较拖拉，导致又反反复复学习，最后学了大概来来回回有3遍，可能加深印象了？web作为框架的基础，是有必要学习的，当时急切的想要有后端的开发能力(<del>框架方便啊</del>)，所以急于求成，现在也有点后悔，项目也做了稀巴烂，几个月都感觉压力与失望，比较丧。</strong></p><p><strong>不过也有好的一面不是嘛？失去了一些东西后，更有精力专注于自己的事情上，每天做规划，几点到几点锻炼腹肌，几点到几点撸铁，晚上每天带着耳机去看着带着晚霞的体育场，带着耳机跑5km,那种每天回想起来一切都按自己计划执行，每天没有辜负自己的完美生活令自己开心不已，每天都对明天充满期待，体脂率一点点下降，肌肉率一点点上升，感觉生活充满了期望。(<del>哦，看看现在，天天敲代码，摸着自己的小肚子</del>)</strong></p><p><img src="https://s2.ax1x.com/2019/08/14/mihcad.png" alt="傍晚的体育场"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一年的时光，感觉自己学会了很多，失去了很多，得到了许多，经历了许许多多的美好，也丧了很长时间。可这就是生活，起起伏伏伏伏伏伏伏伏伏伏伏伏，希望自己可以继续朝着自己向往的生活努力，向着自己想成为的人而努力。等待下一个一年。</strong></p><p><img src="https://i.loli.net/2019/08/13/5n49bWIwku1XctT.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="编程" scheme="http://yxm666.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
