<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  <subtitle>读书 + 赚钱 + 健身 = 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxm666.github.io/"/>
  <updated>2019-09-03T09:01:52.073Z</updated>
  <id>http://yxm666.github.io/</id>
  
  <author>
    <name>遠見卓識</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法与数据结构-概述</title>
    <link href="http://yxm666.github.io/2019/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E8%BF%B0/"/>
    <id>http://yxm666.github.io/2019/09/01/算法与数据结构-概述/</id>
    <published>2019-09-01T01:24:55.000Z</published>
    <updated>2019-09-03T09:01:52.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><blockquote><p><strong>数据结构与算法算是程序的灵魂，本系列文章是根据《大话数据结构》与《算法》书本内容所写的内容总结的读书笔记，加上自己的一定理解。</strong></p></blockquote><hr><h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a><strong>数据结构绪论</strong></h1><ul><li><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></li></ul><h2 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a><strong>基本概念与术语</strong></h2><hr><ul><li><strong>数据：是描述客观事物的符号，是计算机中可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。</strong></li><li><strong>数据元素：书组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</strong></li><li><strong>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位</strong></li><li><strong>数据对象：是性质相同的数据元素的集合，是数据的子集。</strong></li><li><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</strong></li></ul><p><strong><img src="https://i.loli.net/2019/09/01/Z9uADXRG7HNpkbY.png" alt="数据结构相关概念"></strong></p><h2 id="逻辑结构与物理结构-存储结构"><a href="#逻辑结构与物理结构-存储结构" class="headerlink" title="逻辑结构与物理结构(存储结构)"></a><strong>逻辑结构与物理结构(存储结构)</strong></h2><hr><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a><strong>逻辑结构</strong></h3><ul><li><strong>逻辑结构：是指数据对象中数据元素之间的相互关系。</strong></li></ul><h4 id="集合结构"><a href="#集合结构" class="headerlink" title="集合结构"></a><strong>集合结构</strong></h4><hr><ul><li><strong>集合结构中的数据元素除了通属于一个集合外，它们之间没有其他关系。各个数据元素是平等的，它们的共同属性是“同属于一个集合”，类比于数学中的集合</strong></li></ul><p><strong><img src="https://s2.ax1x.com/2019/09/01/nSlNb4.png" alt="集合结构"></strong></p><h4 id="线性结构-一对一"><a href="#线性结构-一对一" class="headerlink" title="线性结构(一对一)"></a><strong>线性结构(一对一)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS1gS0.png" alt="线性结构"></strong></p><h4 id="树形结构-一对多"><a href="#树形结构-一对多" class="headerlink" title="树形结构(一对多)"></a><strong>树形结构(一对多)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS12lV.png" alt="树形结构"></strong></p><h4 id="图形结构-多对多"><a href="#图形结构-多对多" class="headerlink" title="图形结构(多对多)"></a><strong>图形结构(多对多)</strong></h4><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS1RyT.png" alt="图形结构"></strong></p><p><strong>注意事项：</strong></p><ol><li><strong>将每一个数据元素看做一个结点，用圆圈表示</strong></li><li><strong>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</strong></li></ol><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a><strong>物理结构</strong></h3><ul><li><strong>是指数据的逻辑结构在计算机中的存储形式。</strong></li></ul><p><strong>数据的存储结构应正确反映数据元素之间的逻辑关系，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</strong></p><p><strong>数据元素的存储结构形式有两种：顺序存储和链式存储</strong></p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a><strong>顺序存储结构</strong></h4><ul><li><strong>是把数据元素存放在 地址连续 的存储单元里，其数据之间的逻辑关系和物理关系是一致的。</strong></li></ul><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS3J74.png" alt="顺序存储结构"></strong></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a><strong>链式存储结构</strong></h4><ul><li><strong>是把元素存放在 任意 的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</strong></li></ul><p><strong>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到向管理数据元素的位置。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/09/01/nS3bNj.png" alt></strong></p><p><img src="https://s2.ax1x.com/2019/09/03/nkokKU.png" alt="nkokKU.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li><p>算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p></li><li><p>算法的特性：有穷性、确定性、可行性、输入、输出</p></li><li><p>算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求</p></li><li><p>算法的度量方法：<del>事后统计方法</del>、事前分析估算方法</p></li></ul><p><img src="https://s2.ax1x.com/2019/09/01/nS8IR1.png" alt></p><p>推导大O阶：(最高阶次方去常数项)</p><ul><li>用常数1取代运行时间中所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶段</li><li>如果最高阶项存在且不是1，则去除与整个项相乘的常数</li></ul><p><img src="https://s2.ax1x.com/2019/09/01/nSGMLT.png" alt></p><p>常见的时间复杂度多消耗时间的大小排序：</p><p><img src="https://s2.ax1x.com/2019/09/01/nSGleU.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据结构与算法算是程序的灵魂，本系列文章是根据《大话数据结构》与
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://yxm666.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>holiday summary(3)</title>
    <link href="http://yxm666.github.io/2019/08/20/holiday-summary-3/"/>
    <id>http://yxm666.github.io/2019/08/20/holiday-summary-3/</id>
    <published>2019-08-20T10:24:55.000Z</published>
    <updated>2019-08-27T09:26:11.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote><p>​    <strong>在快乐了几天后决定今天把假期总结的东西写完，看看剩的技术还挺多的，就稍微提提好了。肥宅快乐，嗝~</strong></p></blockquote><h1 id="授权管理框架"><a href="#授权管理框架" class="headerlink" title="授权管理框架"></a><strong>授权管理框架</strong></h1><hr><h2 id="Shiro架构与功能介筛"><a href="#Shiro架构与功能介筛" class="headerlink" title="Shiro架构与功能介筛"></a><strong>Shiro架构与功能介筛</strong></h2><hr><p><strong>1.认证与授权相关基本概念</strong></p><p><strong>两个基本的概念</strong></p><p><strong>安全实体：系统需要保护的具体对象数据</strong></p><p><strong>权限：系统相关的功能操作，例如基本的CRUD</strong></p><p><strong>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</strong></p><p><strong>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</strong></p><p><strong>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</strong></p><p><strong>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</strong></p><p><strong>Web Support：Web支持，可以非常容易的集成到Web环境；</strong></p><p><strong>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</strong></p><p><strong>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</strong></p><p><strong>Testing：提供测试支持；</strong></p><p><strong>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</strong></p><p><strong>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</strong></p><p><strong>2.Shiro四大核心功能:Authentication,Authorization,Cryptography,Session Management</strong></p><p><strong><img src="http://p1.pstatp.com/large/37eb00020300d0856a0e" alt="Shiro结构"></strong></p><p><strong>3.Shiro三个核心组件：Subject, SecurityManager 和 Realms.</strong></p><p><strong>Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；</strong></p><p><strong>SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</strong></p><p><strong>Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</strong></p><h2 id="Spring-Security简介"><a href="#Spring-Security简介" class="headerlink" title="Spring Security简介"></a><strong>Spring Security简介</strong></h2><hr><p>​    <strong>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。它与Spring MVC有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。</strong></p><p><strong>它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。</strong></p><ul><li><p><strong>Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。</strong></p></li><li><p><strong>业务对象或者方法的安全：控制方法访问权限的。</strong></p></li><li><p><strong>AuthenticationManager：处理来自于框架其他部分的认证请求。</strong></p></li><li><p><strong>AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。</strong></p></li><li><p><strong>AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</strong></p></li><li><p><strong>UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</strong> </p></li></ul><h2 id="Spring-Security-简介"><a href="#Spring-Security-简介" class="headerlink" title="Spring Security 简介"></a><strong>Spring Security 简介</strong></h2><hr><p>​    <strong>Spring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于 Spring 的应用程序提供身份验证和授权支持。它与 Spring MVC 有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作 “认证” 与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。</strong></p><p><strong>它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。</strong></p><ul><li><strong>Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。</strong></li><li><strong>业务对象或者方法的安全：控制方法访问权限的。</strong></li><li><strong>AuthenticationManager：处理来自于框架其他部分的认证请求。</strong></li><li><strong>AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。</strong></li><li><strong>AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</strong></li><li><strong>UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</strong></li></ul><p><strong><img src="http://p3.pstatp.com/large/37e8000557281bce894c" alt></strong></p><h2 id="Shiro-和-Spring-Security-比较"><a href="#Shiro-和-Spring-Security-比较" class="headerlink" title="Shiro 和 Spring Security 比较"></a><strong>Shiro 和 Spring Security 比较</strong></h2><hr><ol><li><strong>Shiro 比 Spring 更容易使用，实现和最重要的理解</strong></li><li><strong>Spring Security 更加知名的唯一原因是因为品牌名称</strong></li><li><strong>“Spring” 以简单而闻名，但讽刺的是很多人发现安装 Spring Security 很难</strong></li><li><strong>然而，Spring Security 却有更好的社区支持</strong></li><li><strong>Apache Shiro 在 Spring Security 处理密码学方面有一个额外的模块</strong></li><li><strong>Spring-security 对 spring 结合较好，如果项目用的 springmvc ，使用起来很方便。但是如果项目中没有用到 spring，那就不要考虑它了。</strong></li><li><strong>Shiro 功能强大、且 简单、灵活。是 Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行</strong></li></ol><h1 id="Docker-跟Docker能装的一些能用到的技术"><a href="#Docker-跟Docker能装的一些能用到的技术" class="headerlink" title="Docker 跟Docker能装的一些能用到的技术"></a><strong>Docker 跟Docker能装的一些能用到的技术</strong></h1><hr><blockquote><p>​    <strong>这里就主要提一下Docker就好了，因为里面的几种技术我也没有过多的了解(<del>Docker也没咋玩会</del>)。那让我们先瞅瞅里面的几项技术好了</strong></p></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><hr><p><strong>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>，<a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>，<a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</strong></p><hr><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h3><hr><p><strong>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang" target="_blank" rel="noopener">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/开放电信平台" target="_blank" rel="noopener">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/库" target="_blank" rel="noopener">库</a>。</strong></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a><strong>MongoDB</strong></h3><hr><p><strong>MongoDB是一个基于分布式文件存储的数据库。由<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</strong></p><p><strong>MongoDB是一个介于<a href="https://baike.baidu.com/item/关系数据库" target="_blank" rel="noopener">关系数据库</a>和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似<a href="https://baike.baidu.com/item/json" target="_blank" rel="noopener">json</a>的<a href="https://baike.baidu.com/item/bson" target="_blank" rel="noopener">bson</a>格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立<a href="https://baike.baidu.com/item/索引" target="_blank" rel="noopener">索引</a>。</strong></p><h3 id="laticsearch"><a href="#laticsearch" class="headerlink" title="laticsearch"></a><strong>laticsearch</strong></h3><hr><p><strong>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</strong><br><strong>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</strong></p><hr><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><hr><blockquote><p>  <strong>工具这里根据功能两两分组，讲解一下，就好啦。</strong></p></blockquote><h3 id="Mybatis-Plus-amp-PageHelper"><a href="#Mybatis-Plus-amp-PageHelper" class="headerlink" title="Mybatis Plus &amp; PageHelper"></a><strong>Mybatis Plus &amp; PageHelper</strong></h3><hr><pre><code>&gt;​    **这两个工具都是对持久层框架Mybatis的增强，旨在简化持久层开发。**</code></pre><h4 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a><strong>Mybatis Plus</strong></h4><p>​    <strong>对于SPring Boot，官方提供了Start，较好的整合了Mybatis Plus，直接在pom.xml中导入对应的依赖即可。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus（简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生</strong></p><h4 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a><strong>PageHelper</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    <strong>为啥用这个插件呢？因为他代码实现分页就一行代码。在进行查询前插入一个静态方法即可。</strong></p><p><strong><code>PageHelper.startPage（pageNum ， pageSize</code>，这个方法就是类似我们数据库操作的limit start ， count</strong></p><p><strong>就完事了！</strong></p><h3 id="Swagger2-amp-amp-PostMan"><a href="#Swagger2-amp-amp-PostMan" class="headerlink" title="Swagger2 &amp;&amp; PostMan"></a><strong>Swagger2 &amp;&amp; PostMan</strong></h3><hr><h4 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a><strong>Swagger2</strong></h4><p>​    <strong>Swagger是根据我们写的接口动态生成一个html界面，供前台测试用，他不仅可以看接口(这里推荐用restful风格的接口！！！！)的作用，最关键是可以进行测试（<del>下面的一款是专门用来测接口的</del>）。而且动态生成的页面，改代码的时候，直接改对应注解就行了，对于后端来说比较友好~~</strong></p><p>​    <strong>首先是引入依赖，在pom.xml文件中引入依赖。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>然后是Swagger配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .pathMapping(<span class="string">"/"</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"cn.cxjd.demo.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build().apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .title(<span class="string">"轻大软创门户网站API文档"</span>)</span><br><span class="line">                        .description(<span class="string">"含有3大模块接口:管理员模块，新闻模块，新闻分类模块"</span>)</span><br><span class="line">                        .version(<span class="string">"1.0"</span>)</span><br><span class="line">                        .contact(<span class="keyword">new</span> Contact(<span class="string">"联系后端开发者"</span>, <span class="string">""</span>, <span class="string">"877495283@qq.com"</span>))</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类一定要写<code>@EnableSwagger2</code>这个注解哦，大概就是开启swagger的功能的意思吧。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>(value = <span class="string">"涉及用户的接口"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"用户注册"</span>, notes = <span class="string">"传入user对象(包含username与password即可)"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;<span class="meta">@ApiImplicitParam</span>(name = <span class="string">"user"</span>, value = <span class="string">"用户实体"</span>, required = <span class="keyword">true</span>,dataType = <span class="string">"User"</span>,paramType = <span class="string">"body"</span>)&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">addUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> register = userService.register(user);</span><br><span class="line">        <span class="keyword">if</span> (register == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="string">"error"</span>, <span class="string">"该用户名已存在"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (register == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RespBean(<span class="string">"success"</span>, <span class="string">"创建成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>具体的注解使用方法参考下<a href="https://blog.csdn.net/xupeng874395012/article/details/68946676" target="_blank" rel="noopener">这篇博客</a></strong></p><h4 id="postMan"><a href="#postMan" class="headerlink" title="postMan"></a><strong>postMan</strong></h4><p> <strong>postman是一款用来测试接口的软件，在Chrome中搜索下载就好了，具体就不在这里说了~~</strong></p><h3 id="FastJson-amp-amp-Druid"><a href="#FastJson-amp-amp-Druid" class="headerlink" title="FastJson &amp;&amp; Druid"></a><strong>FastJson &amp;&amp; Druid</strong></h3><hr><p>  <strong>来，先上一下这两个技术的maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- fastjson的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.59<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  <strong>从这依赖都可以看出来了，这属于阿里开发的东西喽，然后了解不多，都是跟着网上看的，网址放着，等开学用到了再仔细研究写心得好了。</strong></p><p><strong><a href="https://www.w3cschool.cn/fastjson/" target="_blank" rel="noopener">W3C fastJson</a></strong></p><p><strong><a href="https://segmentfault.com/a/1190000013997259" target="_blank" rel="noopener">druid教学</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;在快乐了几天后决定今天把假期总结的东西写完，看看剩的技
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Holiday summary(二)</title>
    <link href="http://yxm666.github.io/2019/08/17/Holiday-summary-%E4%BA%8C/"/>
    <id>http://yxm666.github.io/2019/08/17/Holiday-summary-二/</id>
    <published>2019-08-17T06:32:52.000Z</published>
    <updated>2019-08-19T04:06:42.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><blockquote><p><strong>跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我们看看都有啥吧。</strong></p></blockquote><hr><p><strong><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></strong></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><hr><p>​    <strong>Maven 、git 算是2个编程比较常用的工具吧，但是为了有区别一点还是单独拉出来了。</strong></p><hr><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h2><pre><code>**Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。**</code></pre><p><strong>Maven主要做了两件事：</strong></p><ol><li><strong>统一开发规范与工具</strong></li><li><strong>统一管理jar包</strong></li><li><strong>Maven常用指令</strong></li></ol><hr><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a><strong>Maven项目结构</strong></h3><p>​    <strong>若要使用 Maven，那么项目的目录结构必须符合 Maven 的规范，其目录结构如下：</strong></p><p>​    <strong><img src="https://img-blog.csdn.net/201808131239225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVxdWFucXVxbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Maven目录jΩΩΩ"></strong></p><h3 id="Maven-基本命令"><a href="#Maven-基本命令" class="headerlink" title="Maven 基本命令"></a><strong>Maven 基本命令</strong></h3><hr><ol><li><p><strong>-v: 查询 Maven 版本</strong></p><p><strong>本命令用于检查 maven 是否安装成功。</strong></p><p><strong>Maven 安装完成之后，在命令行输入 mvn -v，若出现 maven 信息，则说明安装成功。</strong></p></li><li><p><strong>compile：编译</strong></p><p><strong>将 java 源文件编译成 class 文件</strong></p></li><li><p><strong>test: 测试项目</strong></p><p><strong>执行 test 目录下的测试用例</strong></p></li><li><p><strong>package: 打包</strong></p><p><strong>将项目打成 jar 包</strong></p></li><li><p><strong>clean: 删除 target 文件夹</strong></p></li><li><p><strong>install: 安装</strong></p><p><strong>将当前项目放到 Maven 的本地仓库中。供其他项目使用</strong></p></li></ol><hr><h3 id="Maven的仓库"><a href="#Maven的仓库" class="headerlink" title="Maven的仓库"></a><strong>Maven的仓库</strong></h3><hr><p><strong>Maven 仓库用来存放 Maven 管理的所有 Jar 包。分为：本地仓库 和 中央仓库。</strong></p><ul><li><strong>本地仓库：Maven 本地的 Jar 包仓库。</strong></li><li><strong>中央仓库： Maven 官方提供的远程仓库。</strong></li></ul><p><strong><code>当项目编译时，Maven 首先从本地仓库中寻找项目所需的 Jar 包，若本地仓库没有，再到 Maven 的中央仓库下载所需 Jar 包。</code></strong></p><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a><strong>坐标</strong></h3><hr><p><strong>在 Maven 中，坐标是 Jar 包的唯一标识，Maven 通过坐标在仓库中找到项目所需的 Jar 包，通过<a href="https://mvnrepository.com/" target="_blank" rel="noopener">官方依赖仓库</a>去寻找</strong></p><p><strong>如下代码中，groupId 和 artifactId 构成了一个 Jar 包的坐标。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>groupId: 所需 Jar 包的项目名</strong></li><li><strong>artifactId: 所需 Jar 包的模块名</strong></li><li><strong>version: 所需 Jar 包的版本号</strong></li></ul><hr><h3 id="依赖范围-scope"><a href="#依赖范围-scope" class="headerlink" title="依赖范围 scope"></a><strong>依赖范围 scope</strong></h3><pre><code>在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </code></pre><ul><li><strong>compile ：默认范围，用于编译</strong>      </li><li><strong>provided：类似于编译，但支持你期待 jdk 或者容器提供，类似于 classpath</strong>      </li><li><strong>runtime: 在执行时需要使用</strong>      </li><li><strong>test:    用于 test 任务时使用</strong>      </li><li><strong>system: 需要外在提供相应的元素。通过 systemPath 来取得</strong>      </li><li><strong>systemPath: 仅用于范围为 system。提供相应的路径</strong>      </li><li><strong>optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用</strong></li></ul><h2 id="传递依赖-与-排除依赖"><a href="#传递依赖-与-排除依赖" class="headerlink" title="传递依赖 与 排除依赖"></a><strong>传递依赖 与 排除依赖</strong></h2><hr><ul><li><strong>传递依赖：如果我们的项目引用了一个 Jar 包，而该 Jar 包又引用了其他 Jar 包，那么在默认情况下项目编译时，Maven 会把直接引用和简洁引用的 Jar 包都下载到本地。</strong></li><li><strong>排除依赖：如果我们只想下载直接引用的 Jar 包，那么需要在 pom.xml 中做如下配置：(将需要排除的 Jar 包的坐标写在中)</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a><strong>依赖冲突</strong></h3><hr><p>​    <strong>若项目中多个 Jar 同时引用了相同的 Jar 时，会产生依赖冲突，但 Maven 采用了两种避免冲突的策略，因此在 Maven 中是不存在依赖冲突的。</strong></p><ul><li><strong>路径优先</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;C.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</span><br><span class="line">本项目——&gt;C.jar——&gt;X.jar</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar</code></strong></p></li><li><p><strong><code>本项目——&gt;C.jar——&gt;X.jar</code></strong></p></li></ul><p><strong><code>若本项目引用了 A.jar，A.jar 又引用了 B.jar，B.jar 又引用了 X.jar，并且 C.jar 也引用了 X.jar。</code></strong></p><p><strong><code>在此时，Maven 只会引用引用路径最短的 Jar。</code></strong></p><ul><li><p><strong>声明优先</strong></p><p><strong><code>若引用路径长度相同时，在 pom.xml 中谁先被声明，就使用谁。</code></strong></p></li></ul><hr><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h3><ul><li><strong>什么是聚合？</strong></li></ul><p><strong><code>将多个项目同时运行就称为聚合。</code></strong></p><ul><li><strong>如何实现聚合？</strong></li></ul><p><strong>只需在 pom 中作如下配置即可实现聚合：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-connection-pool<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web-java-crawler<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><hr><ol><li><p><strong>什么是继承？</strong></p><p><strong>在聚合多个项目时，如果这些被聚合的项目中需要引入相同的 Jar，那么可以将这些 Jar 写入父 pom 中，各个子项目继承该 pom 即可。</strong></p></li><li><p><strong>如何实现继承？</strong></p></li></ol><ul><li><strong>父 pom 配置：将需要继承的 Jar 包的坐标放入标签即可。</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>子pom配置:</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>父pom所在项目的groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>父pom所在项目的artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>父pom所在项目的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resource-search<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.missbe.web.search<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><hr><h2 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a><strong>git是什么</strong></h2><p>​    <strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="工作原理-流程："><a href="#工作原理-流程：" class="headerlink" title="工作原理 / 流程："></a><strong>工作原理 / 流程：</strong></h2><p><strong><img src="https://img.mukewang.com/59c31e4400013bc911720340.png" alt="Git工作原理"></strong></p><p><strong>Workspace：工作区</strong><br><strong>Index / Stage：暂存区</strong><br><strong>Repository：仓库区（或本地仓库）</strong><br><strong>Remote：远程仓库</strong></p><h3 id="SVN与Git的最主要的区别"><a href="#SVN与Git的最主要的区别" class="headerlink" title="SVN与Git的最主要的区别"></a><strong>SVN与Git的最主要的区别</strong></h3><hr><p>​    <strong>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</strong></p><p>​    <strong>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</strong></p><h3 id="创建仓库-repository"><a href="#创建仓库-repository" class="headerlink" title="创建仓库(repository)"></a><strong>创建仓库(repository)</strong></h3><hr><p><strong>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</strong></p><ol><li><p><strong>首先创建一个空文件夹</strong></p></li><li><p><strong>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p><strong>执行后会在当前目录下生成.git文件(可能是以隐藏文件的形式)</strong></p></li></ol><h3 id="把文件添加到仓库"><a href="#把文件添加到仓库" class="headerlink" title="把文件添加到仓库"></a><strong>把文件添加到仓库</strong></h3><hr><ol><li><p><strong>第一步，在当前路径下创建文件 readme.txt</strong></p></li><li><p><strong>第二步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</strong></p><p><strong><code>$git add redme.txt</code></strong></p></li><li><p><strong>用命令<code>git commit</code>告诉Git，把文件提交到仓库：</strong></p><p><strong><code>$ git commit -m &#39;wrote a file&#39;</code></strong></p><p><strong>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</strong></p><p><strong>当然也可以通过<code>git add .</code>添加路径下的所用文件进入.git里 可以不用一个一个添加</strong></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>初始化一个Git仓库，使用<code>git init</code>命令。</strong></p><p><strong>添加文件到Git仓库，分两步：</strong></p><ol><li><strong>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</strong></li><li><strong>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</strong></li></ol><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a><strong>版本回滚</strong></h3><hr><p>​    <strong>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</strong></p><p><strong><code>使用git log查看提交</code></strong></p><hr><p><strong>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p><strong>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</strong></p><p><strong>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>：（如果用commit_id进行回滚操作，可以只用写部分id但要确定结果唯一）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><strong>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>现在总结一下：</strong></p><ul><li><strong><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</strong></li><li><strong>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</strong></li><li><strong>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</strong></li></ul><h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a><strong>工作区与暂存区</strong></h3><hr><ul><li><p><strong>工作区: 就是你在电脑里能看到的目录，就是你放在.git的同级目录下除了.git文件(<del>怎么有点拗口</del>)</strong></p></li><li><h4 id="版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。"><a href="#版本库（Repository）-工作区有一个隐藏目录-git，这个不算工作区，而是Git的版本库。" class="headerlink" title="版本库（Repository）:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。"></a><strong>版本库（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</strong></h4><p><strong>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</strong></p></li></ul><p>  <strong><img src="https://static.liaoxuefeng.com/files/attachments/919020037470528/0" alt="工作区与缓存区"></strong></p><p>  <strong>分支和<code>HEAD</code>的概念我们以后再讲。</strong></p><p>  <strong>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</strong></p><p>  <strong>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</strong></p><p>  <strong>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</strong></p><p>  <strong>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</strong></p><p>  <strong>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p><p>  <strong>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</strong></p><ul><li><p><strong><code>命令</code>git checkout – readme.txt<code>意思就是，把</code>readme.txt`文件在工作区的修改全部撤销，这里有两种情况：</strong></p><p><strong>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</strong></p><p><strong>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</strong></p><p><strong>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</strong></p></li><li><p><strong>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</strong></p><p><strong><code>$ rm test.txt</code></strong></p><p><strong>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</strong></p><p><strong>现在，文件就从版本库中被删除了。</strong></p><p><strong>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</strong></p><p><strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></p></li></ul><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a><strong>添加远程库</strong></h2><hr><p>​    <strong>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</strong></p><p>​    <strong>添加后，远程库的名字就是<code>origin</code>，这是 Git 默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</strong></p><p>​    <strong>关联后，使用命令<code>git push -u origin master</code>第一次推送 master 分支的所有内容；</strong></p><p><strong>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</strong></p><p><strong>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git 不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</strong></p><hr><p>​    <strong>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</strong></p><p>​    <strong>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</strong></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Holiday summary(一)</title>
    <link href="http://yxm666.github.io/2019/08/15/holiday%20summary(%E4%B8%80)/"/>
    <id>http://yxm666.github.io/2019/08/15/holiday summary(一)/</id>
    <published>2019-08-15T07:40:34.000Z</published>
    <updated>2019-08-17T06:21:38.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>  <strong>如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用来超越别人的(<del>我可不干这种事情，主要我太懒</del>)。暑假一个月，说少不少，说多不多，但在平常的学习上很少有时间可以进行这样集中的编程知识的学习，不时成为锤炼自己的好时机。假期确实提升了很多，有必要进行一些梳理，进行一些总结。当然本次只是给一些技术的进行大概的总结，涉及的知识不会太深。</strong></p></blockquote><h1 id="看看学了什么"><a href="#看看学了什么" class="headerlink" title="看看学了什么"></a>看看学了什么</h1><p>  <strong>让我们首先以一张思维导图开始这篇博文<del>哇 好专业 666鸭</del>,图里包含了这个暑假学到或者了解到<del>当然不可能面面俱到</del>。右边是框架的学习，左边是较为细一点<del>反正自己能理解的一个划分</del>东西还算比较多，够唠一会的了。</strong></p><p><img src="https://i.loli.net/2019/08/15/fBMuJO9ct1ZxqbD.png" alt="暑假学习(后端)"></p><hr><h1 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h1><hr><h2 id="框架学习之SSM框架"><a href="#框架学习之SSM框架" class="headerlink" title="框架学习之SSM框架"></a>框架学习之SSM框架</h2><p>​    <strong>作为一个9102年学框架的后端Java开发人员，当然要从SSM框架学起(<del>学校还在教着SSH</del>),SSM框架即为Spring、SPring MVC、Mybatis。框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。</strong></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>　　<strong>Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。</strong></p><p>　　<strong>Spring的核心思想是IoC（控制反转），面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。即不再需要程序员去显式地<code>new</code>一个对象，而是让Spring框架帮你来完成这一切。</strong></p><p>​    <strong>(<del>上面的粘贴自百度</del>)在我的理解里，Spring 主要分为2部分(IOC与AOP)，IOC就是帮你创建对象的，而不用每一个都自己new，通过依赖注入实现程序之间的解耦。框架的出现大多都是提供良好的封装性、实现程序的高内聚与低耦合。</strong></p><p>​    <strong>AOP 即 Aspect Oriented Program 面向切面编程。首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</strong></p><ul><li><p><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</p></li><li><p><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</p></li></ul><p>  <strong>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</strong></p><h4 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h4><p>  <strong>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性。</strong></p><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p>  ​    <strong>AOP的是让开发人员更专注于核心业务的处理，而不用在核心业务的周围围绕着周边业务，增大代码量，让代码的可读性变差，耦合度增加。</strong></p><p>  <img src="https://i.loli.net/2019/08/15/jQL21EqZiHlVzSC.png" alt="Spring特征"></p><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>​    <strong>SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。</strong></p><p>​    <strong>pring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。Spring MVC 是 Spring 产品组合的一部分，它享有 Spring IoC容器紧密结合Spring松耦合等特点，因此它有Spring的所有优点。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70" alt="Spring MVC 架构图"></p><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a><strong>mybatis</strong></h3><p>​    <strong>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</strong></p><p>　　<strong>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</strong></p><p>​    <strong>页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。(三层架构)</strong></p><hr><h2 id="框架学习之Spring-Boot"><a href="#框架学习之Spring-Boot" class="headerlink" title="框架学习之Spring Boot"></a>框架学习之Spring Boot</h2><blockquote><p><strong>Spring Boot 作为以后后端开发的使用框架，在Spring、Spring MVC 基础上减少了大量的配置，作为一种开箱即用的框架，大大简化了开发人员的开发流程。</strong></p></blockquote><h4 id="首先分享一些比较好的学习连接资源"><a href="#首先分享一些比较好的学习连接资源" class="headerlink" title="首先分享一些比较好的学习连接资源"></a><strong>首先分享一些比较好的学习连接资源</strong></h4><ul><li><p><a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Boot 官方文档</a></p></li><li><p><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引</a></p></li><li><p><a href="http://www.springboot.wiki/" target="_blank" rel="noopener">Spring Boot 教程汇总</a></p></li><li><p><a href="https://www.javaboy.org/springboot/" target="_blank" rel="noopener">江南一点雨 Spring Boot 系列文章</a></p></li><li><p><a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑 Spring Boot 系列文章</a></p><hr><h4 id="什么是Spring-Boot呢？"><a href="#什么是Spring-Boot呢？" class="headerlink" title="什么是Spring Boot呢？"></a>什么是Spring Boot呢？</h4><p>​    <strong>什么是Spring Boot？他跟SPring又有什么关系?怎么又来了一种新的框架？相信无数初学者都曾想过这些问题。首先Spring Boot并非是一种全新的框架。Boot即为启动的意思，旨在快速启动你的Spring项目并通过一些自动配置来减少人为的主动配置。并且Spring Boot 对一些主流框架都有整合的Start,他就像一个框架届的Maven，通过对框架的整合，让开发变得简单起来。</strong></p><p><img src="https://spring.io/img/homepage/icon-spring-boot.svg" alt="Spring Boot"></p></li></ul><h4 id="Spring-boot的四个主要特性"><a href="#Spring-boot的四个主要特性" class="headerlink" title="Spring boot的四个主要特性"></a>Spring boot的四个主要特性</h4><ul><li><p><strong>独立运行的Spring项目</strong>：Spring Boot可以以jar包的形式来运行，运行一个Spring Boot项目我们只需要通过java -jar xx.jar类运行。非常方便。</p></li><li><p><strong>内嵌Servlet容器</strong>：Spring Boot可以内嵌Tomcat，这样我们无需以war包的形式部署项目。</p></li><li><p><strong>提供starter简化Maven配置</strong>：使用Spring或者SpringMVC我们需要添加大量的依赖，而这些依赖很多都是固定的，这里Spring Boot 通过starter能够帮助我们简化Maven配置。</p></li><li><p><strong>自动配置Spring</strong></p></li><li><p><strong>准生产的应用监控</strong></p></li><li><p><strong>无代码生成和xml配置</strong></p><hr></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>暂时先大概的说下这2个后端框架吧，只是大概的讲讲这些框架的有什么作用以及它们的应用，之后再写写那些中间件,溜啦😉😉😉😉<del>~</del></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  &lt;strong&gt;如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="总结" scheme="http://yxm666.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>just one year</title>
    <link href="http://yxm666.github.io/2019/08/13/just-one-year/"/>
    <id>http://yxm666.github.io/2019/08/13/just-one-year/</id>
    <published>2019-08-13T10:19:50.000Z</published>
    <updated>2019-08-15T08:01:21.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>​    <strong>不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输出了“hello world”而开心不已，如今我已经开始写接口文档，进行前后端的分离开发。是时候在一个深夜(凌晨两点)去回忆一下，这一年的日子，去想想得失，想想时间带来了什么。</strong></p></blockquote><hr><p><img src="https://i.loli.net/2019/08/13/eZx8HOj4bs95of6.jpg" alt="梦想"></p><h2 id="去年暑假"><a href="#去年暑假" class="headerlink" title="去年暑假"></a>去年暑假</h2><p>​    <strong>为什么选做一个程序员呢？可能比较喜欢搞点好东西，获取一些酷酷的软件、插件就像如同获得了宝藏一样，让我开心不已，经常为了折腾某一个软件去折腾好几天(比如搞这个花里胡哨的博客折腾了我3天)。确定了想要学软件后，我开始私聊了一些学长咨询。可能这也是一切的起点吧，我知道了当时学校有一个实验室叫软件创新基地。当时的我就立志想进软创。故事就由此展开了。</strong><br>​    <strong>开始去B站上找了浙江大学的视频看，还傻傻的拿了笔记本写了笔记，后来因为去打工，算是搁置了，只看到了循环？之后打工的经历或许也改变了我，它让我变得现实了，待人接物也大不相同了。</strong>```</p><hr><h2 id="初识-（9月-11月"><a href="#初识-（9月-11月" class="headerlink" title="初识  （9月-11月)"></a>初识  （9月-11月)</h2><p>​    <strong>一切都那么新鲜，对什么事情都充满了好奇，什么都想尝试，比如吃一口苹果。这一次我为自己的新鲜感与欠妥当付出了代价，这个甜甜的苹果的滋味知道如今仍然在嘴中回荡只是略带苦涩。可一切都没有重来的余地，何况曾今的*也给过我满嘴的芬芳。</strong></p><p>​    <strong>聊些技术有关的吧。在知道软创有考核时，当时被安利买了 《C prime plus》的我每天都在6点钟去看书，默默为它做准备，是这一年来去图书馆最勤的时候。如我所愿，我通过了面试。可这不意味着安稳，一次一次考核，身边的空位开始变多，不敢松懈，不敢停下。一本厚厚的书也被我做足了笔记，没有电脑就自己推演结果，有电脑就在电脑上执行一次。一步一步，到了指针等什么乱七八糟的东西，令人头疼、头秃。之后进行了C语言实训项目的提前编程。说实话，刚开始的时候，我大概有 3、4天都不知道从何下手，翻翻CSDN、问问谷歌。先编写了骚气的功能界面(唉，骚气慢慢的我)，可是输入的验证却难住了我，判断用户的输入，进行提示反馈。从百度的加上我自己考虑的，大概脑子里有个谱了，添加、显示、更新、删除，最开始的CRUD的实现。万事开头难，这个项目费事程度比我以后碰到bug解决时间都长，可一切都值得的。</strong></p><p><img src="https://i.loli.net/2019/08/13/8xzAhus1pDJ24rB.jpg" alt="dva爱你哟"></p><hr><h2 id="Time-to-change-12月-2月"><a href="#Time-to-change-12月-2月" class="headerlink" title="Time to change(12月-2月)"></a>Time to change(12月-2月)</h2><p>​    <strong>初入茅庐的我，起初觉得学完了C语言，好像感到自己已经精通了编程一样，有些飘飘然。而Java作为一门以后用来吃饭的语言，显然不仅仅只需要掌握语法，编程也不仅仅只是编程语言的学习，事实上开发中的问题总会接踵而至。学习OOP语言，在没有面向对象思想的我一时间难以理解，尤其是构造方法，子父类等等。在接触新事物的时候，这些都是难免的，在自己试错自己找到解决方法后对知识的牢记与成就感是他人直接告诉你结果的感觉是截然不同的。诚然，试错是成长路上不可或缺的一部。</strong></p><p>​    <strong>在越过了OOP的坎后，后面几大章也并不轻松(虽然学校一点都不讲),IO、集合、多线程、网络编程，说实话，这些知识当时因为学的太快并没有留下很深印象(毕竟一个半月学会一门编程语音显得并没有那么轻松)，不过在当时也算是掌握的算不错，当然在下学期(大二上)，如果有功夫的话是需要好好回顾的，毕竟Java SE是基础。</strong></p><p>​        <strong>好了又到了做项目的时候。项目所需的知识总和你掌握的知识有一定的差距，这些短板也会在项目中补齐。当时刚做项目的时候，感觉链接数据库(JDBC)都是一个难点，索性找到了一个黑马的管家婆(这名字土爆了)的视频，跟着学习。我一直觉得程序猿跟画家一样，开始时候进行描摹，从别人的画中找到感觉，再进行自己的创作。收获颇多的可能不是会根据老师讲的可以完成自己的项目，而是视频中的MVC思想，让我对分层进行了了解(我想会抽个文章写一下MVC与三层架构的那些事)。虽说凭借着MAC的美学设计，不用加任何修饰，程序的界面简洁优雅(吹爆MBP)，也算是第一次进行了可视化程序。点点按按的总比命令行好，虽然程序员的原则是能用键盘的事情绝不用鼠标，笑。</strong></p><p>​    <strong>有些事情总算没有了挽回的余地，事实上，一些事情早都可以预料却不能坦然面对，总之，各自安好。可是真的安好了嘛？我开始不推心置腹，开始冷眼旁边，开始置身事外，我真的不明白或者看不透嘛？可能就是看的太透才会这样。一切的一切都Don’t Care，它好像一颗慢性毒药，一点一点再暗暗杀死我，而我却品尝着这令人上瘾的滋味。</strong></p><p><img src="https://i.loli.net/2019/08/13/SfIQpjAPlTytq96.jpg" alt="前路"></p><hr><h2 id="得失-3月-6月"><a href="#得失-3月-6月" class="headerlink" title="得失     (3月-6月)"></a>得失     (3月-6月)</h2><p>​    <strong>well，下学期就放一个章节说好了。学完了Java SE，开始了Java Web的内容。我觉得还是明确个方向学习Java Web 是比较好的(<del>我一辈子不要写标签！！！！</del>)，但是在Java web中也算踩坑严重吧，因为一些事情的耽误，学的比较拖拉，导致又反反复复学习，最后学了大概来来回回有3遍，可能加深印象了？web作为框架的基础，是有必要学习的，当时急切的想要有后端的开发能力(<del>框架方便啊</del>)，所以急于求成，现在也有点后悔，项目也做了稀巴烂，几个月都感觉压力与失望，比较丧。</strong></p><p><strong>不过也有好的一面不是嘛？失去了一些东西后，更有精力专注于自己的事情上，每天做规划，几点到几点锻炼腹肌，几点到几点撸铁，晚上每天带着耳机去看着带着晚霞的体育场，带着耳机跑5km,那种每天回想起来一切都按自己计划执行，每天没有辜负自己的完美生活令自己开心不已，每天都对明天充满期待，体脂率一点点下降，肌肉率一点点上升，感觉生活充满了期望。(<del>哦，看看现在，天天敲代码，摸着自己的小肚子</del>)</strong></p><p><img src="https://s2.ax1x.com/2019/08/14/mihcad.png" alt="傍晚的体育场"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一年的时光，感觉自己学会了很多，失去了很多，得到了许多，经历了许许多多的美好，也丧了很长时间。可这就是生活，起起伏伏伏伏伏伏伏伏伏伏伏伏，希望自己可以继续朝着自己向往的生活努力，向着自己想成为的人而努力。等待下一个一年。</strong></p><p><img src="https://i.loli.net/2019/08/13/5n49bWIwku1XctT.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输
      
    
    </summary>
    
      <category term="总结" scheme="http://yxm666.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="http://yxm666.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="编程" scheme="http://yxm666.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
