<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2019%2F11%2F04%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[前言 递归是一种依靠Java语言特性的一种栈操作，因为在Java中，方法被下压入栈 然后再被取出，只要理解了栈的先进后出原理，觉得理解递归并不是很难。 递归递归的应用场景迷宫问题(回溯)、递归(Recursion) 递归的概念简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。 递归调用机制1) 打印问题2) 阶乘问题3) 使用图解方式说明了递归的调用机制 个人理解: 当main线程进行时，会在栈中下压一个main线程，main中调用了test(4)方法，test(4)方法进行下压入栈、之后依次为test(3)、test2，此时调用完成 再从test(2)进行执行方法体直到结束，此时test(2)应为出栈，依次再将test(3)、test(4)、main出栈，此时，程序结束。 当传入的参数为基础对象,只会进行值传递，变量不传递，当传递为数组等引用变量，则会类似于C中的指针传递。 代码演示1234567891011121314151617package com.atguigu.recursion; public class RecursionTest &#123;public static void main(String[] args) &#123;// TODO Auto-generated method stub //通过打印问题，回顾递归调用机制 //test(4);int res = factorial(3);System.out.println("res=" + res); &#125;//打印问题. public static void test(int n) &#123; if (n &gt; 2) &#123;test(n - 1); &#125; //else &#123;System.out.println("n=" + n); // &#125;&#125;//阶乘问题public static int factorial(int n) &#123;if (n == 1) &#123; return 1;&#125; else &#123;return factorial(n - 1) * n; // 1 * 2 * 3&#125; &#125;&#125; 递归能解决什么样的问题递归用于解决什么样的问题1) 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 2) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.3) 将用栈解决的问题–&gt;第归代码比较简洁 递归需要遵守的重要规则递归需要遵守的重要规则1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)2) 方法的局部变量是独立的，不会相互影响,比如n变量3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)5) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.cxjd.recursion;/** * 〈一句话功能简述〉&lt;br&gt; * 〈迷宫回溯问题〉 * * @author yxm * @create 2019-11-04 * @since 1.0.0 */public class MiGong &#123; public static void main(String[] args) &#123; // 创建一个二维数组 模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1表示墙 // 上下全部设置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部设置为1 for (int i = 1; i &lt; 7; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; map[3][1] = 1; map[3][2] = 1; System.out.println("地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; &#125; /** * @Author: 远见卓识 * @Description: * 1、 map表示地图 * 2、 i j 表示从地图的哪个位置开始出发(1,1) * 3、如果小球能到map[6][5] 位置 则说明通路找到 * 4、约定: 当map[i][j]为0表示该点没有走过 当为1表示为墙 2 表示通路可走 3 表示该店已经走过 但不走不通 * 5、在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 如果该点走不通 再回溯 * @Date: 2019-11-04 * @Param map: 表示地图 * @Param i: 从哪个位置开始找 * @Param j: * @return: boolean 如果找到通路 就返回true 否则返回false **/ public static boolean setWay(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123; // 通路已经找到 return true; &#125; else &#123; if (map[i][j] == 0) &#123; //如果当前这个节点还没有走过 // 按照策略： 下-&gt;右-&gt;上-&gt;左 走 // 假定 该点是可以走通 map[i][j] = 2; // 向下走 if (setWay(map, i + 1, j)) &#123; return true; // 向右走 &#125; else if (setWay(map, i, j + 1)) &#123; return true; // 向上走 &#125; else if (setWay(map, i - 1, j)) &#123; return true; // 向左走 &#125; else if (setWay(map, i, j - 1)) &#123; return true; &#125; else &#123; // 说明该点是走不通 是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 可能是1 ， 2 ，3 return false; &#125; &#125; &#125;&#125; 对迷宫问题的讨论1) 小球得到的路径，和程序员设置的找路策略有关即:找路的上下左右的顺序相关2) 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 3) 测试回溯现象4) 思考: 如何求出最短路径? 思路-》代码实现。 递归-八皇后问题(回溯算法)八皇后问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出:在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。 八皇后问题算法思路分析1) 第一个皇后先放第一行第一列2) 第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适3) 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.5) 然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤6) 示意图: 说明理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] ={0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.cxjd.recursion;/** * 〈一句话功能简述〉&lt;br&gt; * 〈八皇后问题〉 * * @author yxm * @create 2019-11-04 * @since 1.0.0 */public class Queen8 &#123; // 定义一个max表示共有多少个皇后 int max = 8; // 定义数组 array 保存皇后位置的结果 比如 arr=&#123;0,4,7,5,2,6,1,3&#125; int[] array = new int[max]; static int count = 0; static int judgeCount = 0; public static void main(String[] args) &#123; //测试一把 ， 8 皇后是否正确 Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf("一共有%d 解法", count); System.out.printf("一共判断冲突的次数%d 次", judgeCount); // 1.5w &#125; /** * @Author: 远见卓识 * @Description: 编写一个方法 放置第n个皇后 * @Date: 2019-11-04 * @Param n: 放置第n个皇后 * @return: void **/// check 是 每依次递归时，进入到check中都有for(int i = 0;i&lt;max; i++) private void check(int n) &#123; // n = 8 n 从 0开始 表示已经放置到第9个皇后 if (n == max) &#123; print(); return; &#125; // 依次放入到皇后 并判断是否冲突 for (int i = 0; i &lt; max; i++) &#123; // 先把当前这个皇后n，放到该行的第1列 array[n] = i; //判断当前放置第n个皇后到第i列时 是否冲突 // 不冲突 if (judge(n)) &#123; // 接着放n+1个皇后 即开始递归 check(n + 1); &#125; // 如果冲突 就继续执行 array[n] = i 即 将第n个皇后 放置在本行的的后移一个位置 &#125; &#125; private void print() &#123; // 只有每次将8个皇后都排序完成后 才调用print方法 所以用来累加次数 count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + ""); &#125; System.out.println(); &#125; /** * @Author: 远见卓识 * @Description: 查看当我们放置第n个皇后 就去检测该皇后是否和前面已经摆放的皇后冲突 * @Date: 2019-11-04 * @Param n: 表示第n个皇后 * @return: boolean **/ private boolean judge(int n) &#123; // 判断进行了多少次调用 judgeCount++; for (int i = 0; i &lt; n; i++) &#123; /** * 1、 array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 * 2、 Math.abs(n - i) == Math.abs(array[n] - array[i] * 表示判断第n个皇后是否和第i个皇后是否在同一斜线 类似于求k 求45度的tan * 因为没一个n都在递增 所以没有必要判断统一化 */ if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125;&#125; 个人理解: 主要算法部分在其中的check()方法上 看似没有进行回溯，但是每当8个皇后进行完毕后，会通过for循环将最后一个皇后位置遍历移动 当最后一个移动完后 会依次出栈，最终第一个位置也会移动 最后得到所有的结果]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F11%2F03%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[前言栈确实学了半天，倒不是栈难，是各种计算器听起来头比较大，所以，今天梳理下好了。 栈的介绍1) 栈的英文为(stack)2) 栈是一个先入后出(FILO-FirstInLastOut)的有序列表。3) 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。4) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除5) 图解方式说明出栈(pop)和入栈(push)的概念 栈的应用场景1) 子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。2) 处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。4) 二叉树的遍历。5) 图形的深度优先(depth一first)搜索法。 栈的快速入门1) 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。2) 实现思路分析,并画出示意图 一点解释: 栈为先入后出 通过一个指针来进行遍历 入栈的时候 先将栈顶上移再填入元素 出栈操作时需要返回出栈元素 所以需要一个临时变量记录元素 再将栈顶下移 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.cxjd.stack;/** * 〈一句话功能简述〉&lt;br&gt; * 〈数组模拟栈结构〉 * * @author yxm * @create 2019-10-29 * @since 1.0.0 */public class ArrayStack &#123; private int maxSize; private int[] stack; private int top = -1; public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; this.stack = new int[maxSize]; &#125; // 判断栈是否为满 public boolean isFull() &#123; return top == maxSize - 1; &#125; // 判断栈空 public boolean isEmpty() &#123; return top == -1; &#125; // 入栈 public void push(int value) &#123; // 先判断栈是否满 if (this.isFull()) &#123; System.out.println("栈满"); return; &#125; stack[++top] = value; &#125; // 出栈 -pop public int pop() &#123; if (this.isEmpty()) &#123; throw new RuntimeException("栈为空"); &#125; return stack[top--]; &#125; // 遍历栈 public void list() &#123; // 判断是否为空 if (this.isEmpty()) &#123; System.out.println("没有数据"); return; &#125; for (int i = top; i &gt;= 0; i--) &#123; System.out.printf("stack[%d] = %d\n", i, stack[i]); &#125; &#125;&#125; 栈实现综合计算器(中缀表达式) 思路: - 如果是一个数字，则进行入数字栈的操作 如果是一个符号栈:- 如果栈为空 就直接入栈 如果符号栈有操作符 进行比较 :- 如果当前操作符的优先级小于或等于栈中的操作符 从数栈中POP出两个数 再从符号栈中pop出一个符号 进行运算 将得到的结果入数栈 将当前的操作符入符号栈 - 如果当前的操作符的优先级大于栈中的操作符 就直接入符号栈 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行 最后在数栈只有一个数字，就是表达式的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.atguigu.stack; public class Calculator &#123;public static void main(String[] args) &#123; //根据前面老师思路，完成表达式的运算String expression = "7*2*2-5+1-5+3-4"; // 15//如何处理多位数的问题? //创建两个栈，数栈，一个符号栈ArrayStack2 numStack = new ArrayStack2(10);ArrayStack2 operStack = new ArrayStack2(10);//定义需要的相关变量int index = 0;//用于扫描int num1 = 0;int num2 = 0; int oper = 0;int res = 0;char ch = ' '; //将每次扫描得到 char 保存到 ch String keepNum = ""; //用于拼接 多位数 //开始 while 循环的扫描 expression while(true) &#123;//依次得到 expression 的每一个字符ch = expression.substring(index, index+1).charAt(0); //判断 ch 是什么，然后做相应的处理 if(operStack.isOper(ch)) &#123;//如果是运算符//判断当前的符号栈是否为空 if(!operStack.isEmpty()) &#123;//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符, 就需要从数栈中 pop 出两个数,号栈//在从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符if(operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123; num1 = numStack.pop();num2 = numStack.pop();oper = operStack.pop();res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch);&#125; else &#123; //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.operStack.push(ch); &#125;&#125;else &#123; //如果为空直接入符号栈.. operStack.push(ch); // 1 + 3&#125;&#125; else &#123; //如果是数，则直接入数栈//numStack.push(ch - 48); //? "1+3" '1' =&gt; 1//分析思路//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数//2. 在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号//3. 因此我们需要定义一个变量 字符串，用于拼接 //处理多位数keepNum += ch;//如果 ch 已经是 expression 的最后一位，就直接入栈 if (index == expression.length() - 1) &#123;numStack.push(Integer.parseInt(keepNum)); &#125;else&#123;//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是 index++ if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) &#123; //如果后一位是运算符，则入栈 keepNum = "1" 或者 "123" numStack.push(Integer.parseInt(keepNum));//重要的!!!!!!, keepNum 清空keepNum = "";&#125; &#125;&#125;//让 index + 1, 并判断是否扫描到 expression 最后. index++;if (index &gt;= expression.length()) &#123;break; &#125;&#125;//当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行. while(true) &#123;//如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if(operStack.isEmpty()) &#123;break; &#125;num1 = numStack.pop();num2 = numStack.pop();oper = operStack.pop();res = numStack.cal(num1, num2, oper);numStack.push(res);//入栈 &#125;//将数栈的最后数，pop 出，就是结果int res2 = numStack.pop();System.out.printf("表达式 %s = %d", expression, res2);&#125; &#125;//先创建一个栈,直接使用前面创建好 //定义一个 ArrayStack2 表示栈, 需要扩展功能 class ArrayStack2 &#123;private int maxSize; // 栈的大小private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top 表示栈顶，初始化为-1//构造器public ArrayStack2(int maxSize) &#123;this.maxSize = maxSize;stack = new int[this.maxSize]; &#125;//增加一个方法，可以返回当前栈顶的值, 但是不是真正的 pop public int peek() &#123;return stack[top]; &#125;//栈满public boolean isFull() &#123;return top == maxSize - 1; &#125;//栈空public boolean isEmpty() &#123;return top == -1; &#125;//入栈-pushpublic void push(int value) &#123;//先判断栈是否满 if(isFull()) &#123;System.out.println("栈满");return; &#125;top++;stack[top] = value; &#125;//出栈-pop, 将栈顶的数据返回 public int pop() &#123;//先判断栈是否空 if(isEmpty()) &#123;//抛出异常throw new RuntimeException("栈空，没有数据~"); &#125;int value = stack[top]; top--;return value;&#125;//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() &#123;if(isEmpty()) &#123; System.out.println("栈空，没有数据~~"); return;&#125; //需要从栈顶开始显示数据 for(int i = top; i &gt;= 0 ; i--) &#123;System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125;&#125;//返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 //数字越大，则优先级就越高.public int priority(int oper) &#123;if(oper == '*' || oper == '/')&#123; return 1;&#125; else if (oper == '+' || oper == '-') &#123; return 0;&#125; else &#123;return -1; // 假定目前的表达式只有 +, - , * , /&#125; &#125;//判断是不是一个运算符 public boolean isOper(char val) &#123;return val == '+' || val == '-' || val == '*' || val == '/'; &#125;//计算方法public int cal(int num1, int num2, int oper) &#123;int res = 0; // res 用于存放计算的结果 switch (oper) &#123;case '+':res = num1 + num2;break; case '-':res = num2 - num1;// 注意顺序break; case '*':res = num1 * num2;break; case '/':res = num2 / num1;break; default:break; &#125;return res; &#125;&#125; 逆波兰计算器1) 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 3) 思路分析 123456例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:1.从左至右扫描，将 3 和 4 压入堆栈;2.遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3.将 5 入栈;4.接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;5.将 6 入栈;6.最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.stack;import java.util.ArrayList; import java.util.List; import java.util.Stack;public class PolandNotation &#123;public static void main(String[] args) &#123; //先定义给逆波兰表达式//(30+4)×5-6 =&gt;304+5 × 6-=&gt;164// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + //测试//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -";String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76//思路//1. 先将 "34+5 × 6-"=&gt; 放到ArrayList中//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算List&lt;String&gt; list = getListString(suffixExpression); System.out.println("rpnList=" + list);int res = calculate(list); System.out.println("计算的结果是=" + res);&#125;//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中 public static List&lt;String&gt; getListString(String suffixExpression) &#123;//将 suffixExpression 分割String[] split = suffixExpression.split(" "); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele: split) &#123; list.add(ele);&#125;return list;&#125;//完成对逆波兰表达式的运算 /** 1)从左至右扫描，将 3 和 4 压入堆栈;2)遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3)将 5 入栈;4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;5)将 6 入栈;6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果*/public static int calculate(List&lt;String&gt; ls) &#123;// 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 lsfor (String item : ls) &#123;// 这里使用正则表达式来取出数if (item.matches("\\d+")) &#123; // 匹配的是多位数// 入栈 stack.push(item); &#125; else &#123;// pop 出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0;if (item.equals("+")) &#123;res = num1 + num2;&#125; else if (item.equals("-")) &#123;res = num1 - num2;&#125; else if (item.equals("*")) &#123; res = num1 * num2;&#125; else if (item.equals("/")) &#123; res = num1 / num2;&#125; else &#123;throw new RuntimeException("运算符有误");&#125;//把 res 入栈 stack.push("" + res);&#125;&#125;//最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop());&#125; &#125; 中缀表达式转换为后缀表达式具体步骤如下1) 初始化两个栈:运算符栈 s1 和储存中间结果的栈 s2; 2) 从左至右扫描中缀表达式;3) 遇到操作数时，将其压 s2;4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级:1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈; 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1;3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较;5) 遇到括号时:(1) 如果是左括号“(”，则直接压入 s1(2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 6) 重复步骤 2 至 5，直到表达式的最右边7) 将 s1 中剩余的运算符依次弹出并压入 s28) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.atguigu.stack;import java.util.ArrayList; import java.util.List; import java.util.Stack;public class PolandNotation &#123;public static void main(String[] args) &#123;//完成将一个中缀表达式转成后缀表达式的功能 //说明//1.1+((2+3)×4)-5=&gt; 转成 123+4 × +5 – //2. 因为直接对 str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的 List // 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]//3. 将得到的中缀表达式对应的 List =&gt; 后缀表达式对应的 List// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]String expression = "1+((2+3)*4)-5";//注意表达式List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression); System.out.println("中缀表达式对应的 List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList); System.out.println("后缀表达式对应的 List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–]System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ?/*//先定义给逆波兰表达式//(30+4)×5-6 =&gt;304+5 × 6-=&gt;164// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / +//测试//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -";String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76//思路//1. 先将 "34+5 × 6-"=&gt; 放到ArrayList中//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算List&lt;String&gt; list = getListString(suffixExpression); System.out.println("rpnList=" + list);int res = calculate(list); System.out.println("计算的结果是=" + res);*/ &#125;//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] //方法:将得到的中缀表达式对应的 List =&gt; 后缀表达式对应的 List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123;//定义两个栈Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈//说明:因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈 s2List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 储存中间结果的 Lists2//遍历 lsfor(String item: ls) &#123;//如果是一个数，加入 s2 if(item.matches("\\d+")) &#123; s2.add(item);&#125; else if (item.equals("(")) &#123;s1.push(item);&#125; else if (item.equals(")")) &#123;//如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这while(!s1.peek().equals("(")) &#123; s2.add(s1.pop());&#125;s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号 &#125; else &#123;//当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1) 与 s1 中新的栈顶运算符相比较//问题:我们缺少一个比较优先级高低的方法while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123;s2.add(s1.pop()); &#125;//还需要将 item 压入栈s1.push(item); &#125;&#125;//将 s1 中剩余的运算符依次弹出并加入 s2 while(s1.size() != 0) &#123;s2.add(s1.pop()); &#125;return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List &#125;//方法:将 中缀表达式转成对应的 List// s="1+((2+3)×4)-5";public static List&lt;String&gt; toInfixExpressionList(String s) &#123;//定义一个 List,存放中缀表达式 对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;();int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串 String str; // 对多位数的拼接char c; // 每遍历到一个字符，就放入到 cdo &#123;//如果 c 是一个非数字，我需要加入到 ls if((c=s.charAt(i)) &lt; 48 || (c=s.charAt(i)) &gt; 57) &#123;ls.add("" + c);i++; //i 需要后移&#125; else &#123; //如果是一个数，需要考虑多位数str = ""; //先将 str 置成"" '0'[48]-&gt;'9'[57]while(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= 48 &amp;&amp; (c=s.charAt(i)) &lt;= 57) &#123;str += c;//拼接i++; &#125;ls.add(str); &#125; &#125;while(i &lt; s.length());return ls;//返回 &#125;//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中 public static List&lt;String&gt; getListString(String suffixExpression) &#123;//将 suffixExpression 分割String[] split = suffixExpression.split(" "); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele: split) &#123;list.add(ele); &#125;return list; &#125;//完成对逆波兰表达式的运算 /** 1)从左至右扫描，将 3 和 4 压入堆栈;2)遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3)将 5 入栈;4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;5)将 6 入栈;6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果*/public static int calculate(List&lt;String&gt; ls) &#123;// 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 lsfor (String item : ls) &#123;// 这里使用正则表达式来取出数if (item.matches("\\d+")) &#123; // 匹配的是多位数// 入栈stack.push(item); &#125; else &#123;// pop 出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0;if (item.equals("+")) &#123;res = num1 + num2;&#125; else if (item.equals("-")) &#123;res = num1 - num2;&#125; else if (item.equals("*")) &#123; res = num1 * num2;&#125; else if (item.equals("/")) &#123; res = num1 / num2;&#125; else &#123;throw new RuntimeException("运算符有误");&#125;//把 res 入栈 stack.push("" + res); &#125;&#125;//最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop());&#125; &#125;//编写一个类 Operation 可以返回一个运算符 对应的优先级 class Operation &#123;private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2;//写一个方法，返回对应的优先级数字 public static int getValue(String operation) &#123;int result = 0; switch (operation) &#123; case "+":result = ADD;break; case "-":result = SUB; break; case "*":result = MUL;break; case "/":result = DIV;break; default:System.out.println("不存在该运算符");break; &#125;return result; &#125;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F10%2F28%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言 ​ 高产似母猪，我又来更新我的博客，今天学了链表呢，说实话还是有点绕呢，现在开始吧，奥利给！！！！ 链表 链表简介​ 单链表是有序的列表，但地址不一定是相连的。 小结: 1) 链表是以节点的方式来存储,是链式存储2) 每个节点包含 data 域， next 域:指向下一个节点.3) 如图:发现链表的各个节点不一定是连续存储.4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表(带头结点) 逻辑结构示意图如下 单链表的应用实例​ 使用带head头的单向链表实现 - 水浒英雄排行榜管理完成对英雄人物的增删改查操作。 1、 第一种方法在在添加英雄时，直接添加到链表的尾部 2、 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图: 3、 1）先找到该节点，通过遍历 2)temp.name = newHeroNode.name;temp.nickname = newHeroNode.nickname 4、 删除结点2 思路分析的示意图: 代码实现1234567891011121314151617181920212223242526272829303132333435package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈HeroNode 作为链表的一个节点〉 * * @author yxm * @create 2019-10-26 * @since 1.0.0 */public class HeroNode &#123; // 序号 public int no; // 英雄名称 public String name; // 英雄昵称 public String nickname; // 指向下一个节点 public HeroNode next; public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return "HeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈链表的实现〉 * * @author yxm * @create 2019-10-26 * @since 1.0.0 * * 1) 链表是以节点的方式来存储,是链式存储 * 2) 每个节点包含 data 域， next 域:指向下一个节点. * 3) 如图:发现链表的各个节点不一定是连续存储. * 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 */public class LinkedList &#123; // 先初始化一个头结点 头结点不要动 不存放具体的数据 private HeroNode head = new HeroNode(0, "", ""); //添加节点到单向链表 /* 1、 找到当前链表的最后节点 2、 将最后这个节点的next指向新的节点 */ public void add(HeroNode heroNode) &#123; // 因为head 作为头结点 不能移动 因此我们需要一个辅助指针遍历 temp HeroNode temp = head; // 遍历链表，找到最后 如果后续指针不为空 则继续遍历 while (temp.next != null) &#123; // 将temp后移 temp = temp.next; &#125; // 当退出while 循环时， temp就指向了链表的最后 // 此时 将要加入的结点放入到temp的 next域 中 temp.next = heroNode; &#125; // 第二种方法在添加英雄时，根据英雄的排名将英雄插入到指定位置 如果有这个排名则显示添加失败 并给出提示 public void addbyOrder(HeroNode heroNode) &#123; // 因为头节点不能动，因此我们让然通过一个辅助指针来找到添加的位置 // 因为单链表 我们找的temp是位于添加位置前的一个节点 否则插入不了 // 添加节点 兴许一个节点都没 所以不需要后移 HeroNode temp = head; // flag标志添加的标志是否存在 默认为false boolean flag = false; while (temp.next != null) &#123; // 位置摘到 就在 temp的后面 if (temp.next.no &gt; heroNode.no) &#123; break; // 说明希望添加的hearNode 的编号已经存在 &#125; else if (temp.next.no == heroNode.no) &#123; flag = true; break; &#125; // 后移 遍历当前链表 temp = temp.next; &#125; // 判断flag的值 if (flag) &#123; // 表明 改heroNode的 No已经存在无法添加 System.out.printf("准备插入的英雄编号%d 已经存在了 不能加入\n", heroNode.no); &#125; else &#123; // 插插入到链表中,temp 的后面 注意插入的顺序 // 插入等操作先不动 temp 先动 插入的元素 将heroNode 放到 temp的 next 现在有两个元素在 temp的后面 heroNode.next = temp.next; // 现在在切断 temp与原本的后面的元素的联系 temp.next = heroNode; &#125; &#125; // 修改结点的信息，根据no编号来修改 no不能做修改 // 根据newHeroNode 的 no来修改 public void update(HeroNode newHeroNode) &#123; // 判断是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 找到需要修改的结点 根据 no编号 // 定义一个辅助变量 HeroNode temp = head.next; // 表示是否找到了该结点 boolean flag = false; while (temp != null) &#123; if (temp.no == newHeroNode.no) &#123; // 找到 改变标志 flag = true; break; &#125; temp = temp.next; &#125; // 根据 flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; System.out.printf("没有找到 编号%d 的节点，不能修改", newHeroNode.no); &#125; &#125; //删除节点 /* 1、 head不能动 因此我们需要一个temp辅助节点找到待删除节点的前一个节点 2、 说明我们在比较时 是 temp.next.no 与 需要删除的节点的no进行比较 */ public void del(int no) &#123; HeroNode temp = head; //标志是否找到待删除的节点 boolean flag = false; while (temp.next == null) &#123; if (temp.next.no == no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; // temp后移 temp = temp.next; &#125; if (flag) &#123; // 找到 可以删除 temp.next = temp.next.next; &#125; else &#123; System.out.printf("要删除的 %d 节点不存在\n",no); &#125; &#125; // 显示链表 public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 因为头结点不能动 因此我们需要一个辅助节点进行遍历 HeroNode temp = head.next; while (temp != null) &#123; // 输出节点信息 System.out.println(temp); temp = temp.next; &#125; &#125;&#125; 单链表面试题去单链表中有效节点的个数12345678910111213141516171819// 求单链表中有效结点的个数 // 方法: 获取单链表的节点的个数(如果是带头结点的链表，需要不统计头结点) public static int getLength(HeroNode head) &#123; // 空链表 if (head.next == null) &#123; return 0; &#125; int length = 0; // 定义一个辅助变量 这里没有统计头结点 HeroNode cur = head.next; while (cur != null) &#123; length++; // 将cur向后移 cur = cur.next; &#125; return length; &#125; 查找单链表中的倒数第K个结点1234567891011121314151617181920212223242526272829/ 查找单链表中的倒数第K个结点 /* 1、 编写一个方法 接受 head 节点 同时接受一个index 2、 index 表示倒数第index 个节点 3、 先把链表从头到尾遍历 得到链表的总长度 getLength 4、 得到size后 我们从链表的第一个开始遍历(size-index)个 就可以得到 5、 如果找到了，则返回该结点，否则返回null */ public static HeroNode findLastIndexNode(HeroNode head, int index) &#123; // 如果链表为空 返回null if (head.next == null) &#123; return null; &#125; // 第一个遍历得到链表的长度(节点个数) int size = getLength(head); // 第二次遍历 size-index 位置 就是我们倒数的第K个节点 // 先做一个index的校验 if (index &lt;= 0 || index &gt; size) &#123; return null; &#125; // 定义辅助遍历 for循环定位到倒数的index HeroNode cur = head.next; for (int i = 0; i &lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; &#125; 单链表的反转 12345678910111213141516171819202122232425262728293031323334//单链表的反转 /* 1、 先定义一个节点 reverHead = new HeroNode() 2、 从头到尾遍历原来的链表 每遍历一个节点 就将其取出 并放出在新的链表reverse的最前端 3、 原来的链表的head.next = reversehead.next */ public static void reverseList(HeroNode head) &#123; // 如果当前链表为空 或者只有一个节点 无需反转 直接返回 if (head.next == null || head.next.next == null) &#123; return; &#125; // 定义一个辅助指针 帮助我们遍历原来的链表 HeroNode cur = head.next; // 指向当前节点[cur]的下一个节点 HeroNode next = null; HeroNode reverseHead = new HeroNode(0, "", ""); // 遍历原来的链表 每遍历一个节点 就将其取出 并放在新的链表 reverseHead 的最前端 while (cur != null) &#123; // 先暂时保存当前节点的下一节点 因为后面需要 next = cur.next; // 将cur的下一个节点指向新的链表的最前端 cur.next = reverseHead.next; // 将 cur 连接到新的链表上 reverseHead.next = cur; // 让cur后移 cur = next; &#125; // 将head.next 指向 reverseHead.next 实现单链表的反转 head.next = reverseHead.next; &#125; 从尾到头打印链表思路分析图解 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.cxjd.LinkedList;import java.util.Stack;/** * 〈一句话功能简述〉&lt;br&gt; * 〈栈的模拟实现〉 * * @author yxm * @create 2019-10-27 * @since 1.0.0 */public class StackTest &#123; public static void main(String[] args) &#123; &#125; // 利用栈这种数据结构 将各个节点压入到栈中 然后利用栈的先进后出的特点 实现了逆序打印的效果 public static void reversePrint(HeroNode head) &#123; if (head.next == null) &#123; // 空链表 不能打印 return; &#125; // 创建要给一个栈 将各个节点压入栈 Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;(); HeroNode cur = head.next; // 将链表的所有节点压入栈 while (cur != null) &#123; stack.push(cur); // 后移 这样就可以压入下一个节点 cur = cur.next; &#125; // 将栈中的节点打印 pop 出栈 while (stack.size() &gt; 0) &#123; // stack 的特点是先进后出 System.out.println(stack.pop()); &#125; &#125;&#125; 双向链表的操作分析和实现​ 使用带head头的双向链表实现 -水浒英雄传 管理单向链表的缺点分析: 单向链表，查找打方向只能是一个方向，而双向链表可以向前或者向后查找 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，宗师找到temp,temp是待删除节点的前一个节点 分析了双向链表如何完成遍历，添加，修改和删除的思路 对上图的说明: 遍历 和单链表一样，只是可以向前 也可以向后查找 添加(默认添加到双向链表的最后) 先找到双向链表的最后这个节点(通过辅助指针循环遍历 此时temp 指向最后一个节点) temp.next = newHeroNode newHeroNode.pre = temp 修改 思路和原来的单向链表一样 删除 因为是双向链表 因此我们可以实现自我删除某个节点 直接从要删除的这个节点，比如 temp temp.pre.next = temp.next (将temp的前一个节点的后指针指向temp的下一个) temp.next.pre = temp.pre （temp的下一个节点的前指针指向temp的前一个节点） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈双向链表〉 * * @author yxm * @create 2019-10-27 * @since 1.0.0 */public class DoubleLinkList &#123; // 先初始化一个头结点 头结点不要动 不存放具体数据 private HeroNode2 head = new HeroNode2(0, "", ""); // 返回头结点 public HeroNode2 getHead() &#123; return head; &#125; // 遍历双向链表的方法 // 显示链表 public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 因为头结点 不能动 因此需要一个辅助变量来遍历 HeroNode2 temp = head.next; while (temp != null) &#123; System.out.println(temp); // 将temp 后移 temp = temp.next; &#125; &#125; // 添加一个节点到双向链表的最后 public void add(HeroNode2 heroNode) &#123; // 因为head节点不能动 因此我们需要一个辅助节点temp 遍历 HeroNode2 temp = head; // 遍历链表 找到最后 while (temp.next != null) &#123; temp = temp.next; &#125; // 当退出while循环时 temp就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; &#125; // 修改一个节点的内容 可以看大佬双向链表的节点内容修改和单向链表一样 // 只是 节点类型换成 HeroNode2 public void update(HeroNode2 newHeroNode) &#123; //判断是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 找到需要修改的节点 根据no编号 // 定义一个辅助变量 HeroNode2 temp = head.next; // 判断是否找到该节点 boolean flag = false; while (temp != null) &#123; if (temp.no == newHeroNode.no) &#123; // 找到该节点 flag = true; break; &#125; temp = temp.next; &#125; // 根据 flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; //没有找到 System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; // 从双向链表中删除一个节点 // 说明 // 1、 对于双向链表 我们可以直接找到要删除的这个节点 // 2、 找到后 自我删除即可 public void del(int no) &#123; if (head.next == null) &#123; // 判断当前链表是否为空 System.out.println("链表为空 无法删除"); return; &#125; // 辅助变量 HeroNode2 temp = head.next; // 标志是否找到待删除的节点 boolean flag = false; while (temp != null) &#123; if (temp.no==no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; &#125; // 判断flag if (flag) &#123; // 找到 可以删除 // 单向链表 temp.next = temp.next.next // 前一个节点后一个节点指向 当前节点的后一个节点 temp.pre.next = temp.next; // 如果是最后一个则不需要对后一个节点的前指针进行设置 否则会出现空指针异常 if (temp.next != null) &#123; temp.next.pre = temp.pre; &#125; &#125; else &#123; System.out.printf("要删除的%d 节点不存在\n", no); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈双向链表的节点类〉 * * @author yxm * @create 2019-10-27 * @since 1.0.0 */public class HeroNode2 &#123; public int no; public String name; public String nickname; // 指向下一个节点 默认为null public HeroNode2 next; // 指向前一个节点 默认为null public HeroNode2 pre; public HeroNode2(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return "HeroNode2&#123;" + "no=" + no + ", name='" + name + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 测试双向链表: 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈双向链表测试〉 * * @author yxm * @create 2019-10-28 * @since 1.0.0 */public class DoubleLinkListTest &#123; public static void main(String[] args) &#123; System.out.println("测试"); // 添加节点 HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨"); HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟"); HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星"); HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头"); // 创建一个双向链表 DoubleLinkList doubleLinkList = new DoubleLinkList(); doubleLinkList.add(hero1); doubleLinkList.add(hero2); doubleLinkList.add(hero3); doubleLinkList.add(hero4); doubleLinkList.list(); HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙"); doubleLinkList.update(newHeroNode); System.out.println("修改后"); doubleLinkList.list(); doubleLinkList.del(4); System.out.println("删除后"); doubleLinkList.list(); &#125;&#125; 单向环形链表 应用场景Josephu(约瑟夫、约瑟夫环)问题Josephu 问题为:设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k(1&lt;=k&lt;=n)的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。提示:用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。 单向环形链表介绍 Josephu 问题示意图: Josephu 问题为: ​ 设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k(1&lt;=k&lt;=n)的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。 提示: 用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。 创建环形链表的思路图解 约瑟夫问题-小孩出圈的思路分析图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈约瑟夫问题 单向环形链表〉 * * @author yxm * @create 2019-10-28 * @since 1.0.0 */public class Josephu &#123; public static void main(String[] args) &#123; // 测试一把 看看构建环形链表 遍历是否Ok Josephu josephu = new Josephu(); josephu.addBoy(5); josephu.showBoy(); &#125; // 创建first 节点 当前没有编号 private Boy first = null; public void addBoy(int nums) &#123; if (nums &lt; 1) &#123; System.out.println("num的值不正确"); return; &#125; // 创建辅助指针 帮助构建环形链表 Boy curBoy = null; // 使用for循环创建我们的链表 for (int i = 0; i &lt; nums; i++) &#123; // 根据编号创建小孩节点 Boy boy = new Boy(i); // 如果是第一个小孩 if (i == 0) &#123; first = boy; // 构成环 first.setNext(first); // 让curBoy指向第一个小孩 curBoy = first; &#125; else &#123; // 如果不是第一个小孩 // 将新增的节点填入环形链表 curBoy.setNext(boy); // 将环重新连接起来 boy.setNext(first); // 辅助变量后移 curBoy = boy; &#125; &#125; &#125; // 遍历当前环形链表 public void showBoy() &#123; // 判断链表是否为空 if (first == null) &#123; System.out.println("链表为空"); return; &#125; // 因为first 不能动 因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) &#123; System.out.printf("小孩的编号为%d\n", curBoy.getNo()); // 说明已经遍历完毕 if (curBoy.getNext() == first) &#123; break; &#125; // curBoy 后移 curBoy = curBoy.getNext(); &#125; &#125; // 根据用户的输入 计算出小孩出圈的顺序 /* @param : starNo 表示从第几个小孩开始数 @ param : countNum 表示数几下 @param: nims 表示最初由多少个小孩在圈中 */ public void countBoy(int startNo, int countNum, int nums) &#123; if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println("参数输入有误"); return; &#125; // 创建要给辅助指针，帮助小孩出圈 Boy helper = first; // 将helper 指向最后一个节点 while (helper.getNext() != null) &#123; helper = helper.getNext(); &#125; // 小孩报数前 先让first 和 helper 移动 k-1次 for (int i = 0; i &lt; startNo - 1; i++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; // 当小孩报数时 让first 和 helper 指针同时的移动 m-1次 然后出圈 while (helper != first) &#123; // 让 first 和 helper 指针同时移动 countNum-1 for (int i = 0; i &lt; countNum - 1; i++) &#123; // 将 first 与 helper 后移 移动后的first节点即为要出圈的小孩 first = first.getNext(); helper = helper.getNext(); &#125; // 这时 first 指向的节点 就是要出圈的小孩节点 System.out.printf("小孩%d出圈\n", first.getNo()); // 这时将first指向的小孩节点出圈 // first后移 helper 在一定意义上是前一个 将他的后指针指向移动后的first first = first.getNext(); helper.setNext(first); &#125; System.out.printf("最后留在圈中的小孩编号为%d\n", first.getNo()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package cn.cxjd.LinkedList;/** * 〈一句话功能简述〉&lt;br&gt; * 〈Boy类 作为单向环形链表的一个节点〉 * * @author yxm * @create 2019-10-28 * @since 1.0.0 */public class Boy &#123; // 编号 private int no; // 指向下一个节点 默认为null private Boy next; public Boy(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组与队列]]></title>
    <url>%2F2019%2F10%2F25%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言​ 好了，好久没有更新博客了，现在跟着韩顺平的数据结构学习，主要也是实验室太忙了，自己也有一些事，以后周更要坚持住。这次记录的是稀疏数组与队列，队列又分有普通队列与环形队列。 稀疏数组 适用情况 在一些情况下，二维数组会有大部分的数据无用，比如没有意义的0，我们这时候可以使用稀疏数组进行存储该二维数组。 处理方法 记录数组一共有几行几列，有多少不同的值 把具有不同值得元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 应用实例 使用稀疏数组，来保留类似的前面的二维数组(棋盘、地图) 把稀疏数组存盘，并且可以从新恢复原来的二维数组 思路分析 二维数组 转 稀疏数组的思路 遍历原始二维数组，得到有效的数据个数 sum (因为创建的稀疏数组的大小需要根据有效个数进行创建) 根据sum就可以创建洗漱漱 sparseArr int[sum + 1] [3] (sum+1 是因为第一行需要存储原二维数组的行 列 有效个数 3 作为列数是存储有效元素的信息 前2个是用来存储原二维数组的 行 列 的信息 第三个是存储元素的值) 将二维数组的有效数据存入稀疏数组 稀疏数组转原始的二维数组的思路 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11] 在读取稀疏数组后几行的数据，并赋值给原始的二维数组 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package cn.cxjd.sparseArray;/** * 〈一句话功能简述〉&lt;br&gt; * 〈稀疏数组的实现〉 * * @author yxm * @create 2019-10-23 * @since 1.0.0 *//*当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 1) 记录数组一共有几行几列，有多少个不同的值 2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数3) 整体思路分析 */public class SparseArray &#123; public static void main(String[] args) &#123; // 创建一个原始的二维数组11 * 11 int[][] chessArr1 = new int[11][11]; //设置其中不为0的值 chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 先输出原始二维数组 // 两次for循环 直接打印 System.out.println("原始二维数组"); for (int[] ints : chessArr1) &#123; for (int i : ints) &#123; System.out.printf("%d\t", i); &#125; System.out.println(); &#125; // 将二维数组转换为细数数组 // 1、先遍历二维数组 得到非0的 数据个数 用来为新创建 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; // 如果这个元素不为0 则sum++ if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; // 创建对应的稀疏数组 // ssum+1 第一行 依次存储 多少行 多少列 有多少个数不为0 // 3 : 依次存储为 行号 列号 值 int[][] sparseArr = new int[sum + 1][3]; // 将稀疏数组的第一行 存入 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; //遍历二维数组，将非0的值存放到sparseArr中 // count 用来记录获取的是第几个非0数据 int count = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; //用来记录非0数据在二维数组中的位置 sparseArr[count][0] = i; sparseArr[count][1] = j; // 第3个值用来存值 sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //打印变换成功的稀疏数组 System.out.println(); System.out.println("细数数组为:-------"); // 从第一行打印 for (int i = 1; i &lt; sparseArr.length; i++) &#123; System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); //在读取稀疏数组后几行的数据（从第二行开始),并赋值给原始的二维数组 //现根据首行获取原始二维数组的情况 int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]]; //进行赋值 从第二行开始 for (int i = 1; i &lt; sparseArr.length; i++) &#123; //将非0数据根据赋值给新的二维数组 chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //打印恢复后的二维数组 System.out.println(); System.out.println("恢复后的二维数组为:"); for (int[] ints : chessArr2) &#123; for (int anInt : ints) &#123; System.out.printf("%d\t",anInt); &#125; System.out.println(); &#125; &#125;&#125; 队列 普通队列 队列介绍 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即:先存入队列的数据，要先取出。后存入的妖后取出。 示意图 数组模拟队列的思路 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量 因为队列的输出、输入分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后的下标, front会随着数据输出而改变，而 rear 则是随着和数据输入而改变，如图所示: 当我们将数据存入队列时成为”addQueue”,addQueue的处理需要 思路分析: 将尾指针后移: rear + 1 ，当 front == rear 表示队列为空 若尾指针 rear 小于队列的最大下标 maxSize -1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize - 1 [队列满] 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package cn.cxjd.Queues;/** * 〈一句话功能简述〉&lt;br&gt; * 〈队列的实现〉 * * @author yxm * @create 2019-10-23 * @since 1.0.0 *//*队列本身是有序列表，若使用数组的结构来存储队列的数据， 其中 maxSize 是该队 列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front 及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear 则是随着数据输入而改变 */public class Queue &#123; public static void main(String[] args) &#123; &#125; class ArrarQucue &#123; // 表示数组的最大容量 private int maxSize; // 队列头 private int front; // 队列尾 private int rear; //该数据用于存放数据 模拟队列 private int[] arr; public ArrarQucue(int maxSize) &#123; this.maxSize = maxSize; arr = new int[maxSize]; // 指向队列头部，分析出front是指向队列头的前一个位置 front = -1; // 指向队列尾 指向队列尾的数据(就是队列最后一个数据) rear = -1; &#125; //判断队列是否为满 因为是从0开始计数 所以需要maxSize-1 public boolean isFull() &#123; return rear == maxSize - 1; &#125; //判断队列是否为空 当头跟尾巴想重 即满 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueuc(int n) &#123; // 判断是否为满 if (this.isFull()) &#123; System.out.println("队列满，不能加入数据"); return; &#125; // 指向队列尾 初始值为-1 需要先加再 再存 rear++; arr[rear] = n; &#125; // 获取队列的数据，出队列 public int getQeue() &#123; //判断队列是否为空 if (this.isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列为空 不能添加数据"); &#125; // front 后移 因为指向前一位 先++ 再获取 front++; return arr[front]; &#125; //显示队列的所有数据 public void showQueue() &#123; //遍历 if (this.isEmpty()) &#123; System.out.println("队列尾空 无数据"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf("arr[%d]=%d\n", arr[i]); &#125; &#125; //显示队列的头数据，注意不是取出数据 public int headQueue() &#123; //判断是否为空 if (this.isEmpty()) &#123; throw new RuntimeException("队列为空 没有数据"); &#125; return arr[front + 1]; &#125; &#125;&#125; 环形队列 ​ 对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的结构。(通过去模的方式来实现) 分析说明 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意(rear + 1)% maxSize == front (满) rear == font (空) 示意图: 思路如下 front变量的含义进行调整:front就指向队列的第一个元素，也就是一说arr[front] 就是队列的第一个元素 front 的初始值为0 Rear 变量的含义进行调整:rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值为0 当队列为满时，条件是(rear+1)%maxSzie = front [满] 队列尾空的条件， rear == front [空] 当这样定义时候，队列中有效的数据个数为: (rear + maxSize - front)%maxSize 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package cn.cxjd.Queues;/** * 〈一句话功能简述〉&lt;br&gt; * 〈数组实现环形队列〉 * * @author yxm * @create 2019-10-24 * @since 1.0.0 *//*对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)分析说明:1) 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]2) rear == front [空]判断有效个数 : (rear + maxSize)%maxSize */public class CircleArrayQueue &#123; // 表示数组的最大容量 private int maxSize; // front 指向队列的第一个元素 arr[front]表示为队列的第一个元素 private int front; // rear指向队列的最后一个元素的后一个位置 因为喜欢空出一个空间做约定 private int rear; // 该数据用于存放数据 模拟队列 private int[] arr; public CircleArrayQueue(int maxSize) &#123; this.maxSize = maxSize; arr = new int[maxSize]; &#125; // 判断杜烈是否为满 public boolean isFull() &#123; // 先进行后移 并取余 如果等于 front 则表示满 因为约定进行一个空间的空余 return (rear + 1) % maxSize == front; &#125; // 判断是否为空 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueue(int n) &#123; // 先判断队列是否为满 if (this.isFull()) &#123; System.out.println("队列满 无法添加数据"); return; &#125; // 因为rear指向的是最后一个元素的后一个位置 故直接进行添加操作 arr[rear] = n; //因为之前已经判断了是否为满 所以这里将rear后移没有问题 需要考虑到取余 &#125; // 获取队列的数据 出队列 public int getQueue() &#123; // 判断队列是否为空 if (this.isEmpty()) &#123; throw new RuntimeException("队列空 不能取数据"); &#125; // front是指向队列的第一个元素 // 1、 首先把front对应的值保存到一个临时变量中 // 2、 再将front后移 考虑取模 // 返回之前保存的临时变量 int value = arr[front]; front = (front + 1) / maxSize; return value; &#125; // 显示队列的所有的数据 public void showQueue() &#123; // 先看判断空 if (this.isEmpty()) &#123; System.out.println("队列为空 没有数据"); return; &#125; // 思路: 从 front 开始遍历 遍历 有效个数个元素 for (int i = front; i &lt; front + this.size(); i++) &#123; // 尽管是环形队列 下标索引还是不变的 所以 还需要进行去模得到正确的值 System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]); &#125; &#125; // 求出当前队列有效数据的个数 public int size() &#123; return (rear + maxSize - front) % maxSize; &#125; // 显示队列的头数据 注意不是取出 public int headQueue() &#123; //判断是否为空 if (this.isEmpty()) &#123; throw new RuntimeException("队列为空 没有数据"); &#125; return arr[front]; &#125;&#125; ##]]></content>
      <categories>
        <category>数据结构与希望</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构-线性表]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[# 前言 线性表是零个或多个具有相同类型的数据元素的有限序列。主要分为：顺序存储结构、链式存储结构，在链式存储结构中又主要分为：单链表、静态链表、循环链表、双向链表 线性表 线性表(List):零个或多个数据元素的有限序列 序列： 元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有切只有一个前驱和后继。 所以 线性表元素的个数n（n&gt;=0）定义为线性表的长度。当n=0时，称为空表。 线性表的抽象数据类型 在讲这个地方之前我想对抽象数据类型进行一个解释，因为之前也不理解抽象数据类型 抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。抽象数据类型是与表示无关的数据类型，是一个数据模型及定义在该模型上的一组运算。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。 是不是感觉晦涩难懂，简单点，就是这个线性表应该具有哪样的操作 线性表的数据类型定义如下： 线性表的顺序存储结构 顺序存储定义定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素 顺序存储方式 在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中 12345678910#define MAXSIZE 20 /* 存储空间初始分配量 */typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */typedef struct&#123; ElemType data[MAXSIZE]; /* 数组，存储数据元素 */ int length; /* 线性表当前长度 */&#125;SqList; 描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 线性表额最大存储容量：数组长度MaxSize。 线性表的当前长度：length ## 数组长度与线性表长度区别 ​ 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。 ​ 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 顺序存储结构的插入与删除 获取元素操作 12345678910111213141516171819202122232425Status GetElem(SqList L,int i,ElemType *e)&#123; // 判断是否为空 或者数组下标越界 if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125;//Demo /* 因为只有传入指针才能对方法外变量的值做改变 故传入的是地址， 首先定义一个 int 类型变量 e 然后将其地址传入(&amp;e) 此时e指向了结构体中数组所在下标的地址 此时 方法外的变量e的值就进行了改变*/int main()&#123; SqList L; ElemType e; GetElem(L,5,&amp;e); printf("第5个元素的值为：%d\n",e);&#125; ## 插入操作 插入算法的思路： 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(创建一个新的数组，初始化长度加一，然后根据插入点，插入前复制原数组，插入后新数组下标加1)。 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。 将要插入元素填入位置i处。 表长加1 实现代码如下： 123456789101112131415161718192021222324252627/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length) /* 若插入数据位置不在表尾 */ &#123; // 从后往前移动 for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125;//demofor(j=1;j&lt;=5;j++) i=ListInsert(&amp;L,1,j); printf("在L的表头依次插入1～5后：L.data="); //在L的表头依次插入1～5后：L.data=5 4 3 2 1 删除操作 删除算法的思路： 如果删除位置不合理，抛出异常 取出删除元素； 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置 表长减1 实现代码如下： 1234567891011121314151617181920212223242526272829/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(SqList *L,int i,ElemType *e) &#123; int k; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; if (i&lt;L-&gt;length) /* 如果删除不是最后位置 */ &#123; for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125;//demo k=ListLength(L); /* k为表长 */ for(j=k+1;j&gt;=k;j--) &#123; i=ListDelete(&amp;L,j,&amp;e); /* 删除第j个数据 */ if(i==ERROR) printf("删除第%d个数据失败\n",j); else printf("删除第%d个的元素值为：%d\n",j,e); &#125; 线性表顺序存储结构的优缺点 线性表的链式存储结构 线性表链式存储结构定义 ​ 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的存储元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些存储元素可以存在内存未被占用的任意位置。 ​ 在以前的顺序结构中，数据元素只需要存储数据元素信息就ok了，因为它们的地址是连续的，跟着地址找，一个连着一个，而链式存储结构中，除了要存储数据元素信息外，还要存储它的后续元素的存储地址。 ​ 因此，为了表示每个数据元素ai与其直接后续数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后续的信息(即直接后续的存储位置)。 ​ 存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。指针域中存储的信息呗称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。 ​ n个结点（ai的存储映像）链结成一个链表，即为线性表(a1,a2…..an)的链式存储结构，因为此链表中的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。 链表中第一个结点的存储位置叫做头指针 线性链表中的最后一个结点指针为NULL(“^”) (注：头指针是指向第一个结点的 而不是第一个结点的指针域，说白了 头指针是第一个结点的地址) ​ 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点称为头结点，头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针(就是头指针)。 头指针与头结点的异同 ​ 我个人认为带有头结点的单链表图好像其中头指针的位置画错了，不敢确认，按照定义与理解，头指针应该是排除再链表外的东西(个人理解)，经过请教佩哥，佩哥牛鼻！！！！！，佩哥肯定了我的想法，爱他！！！，可以查看相关文章。 相关文章 线性表链式存储结构代码描述 在单链表中，我们在C语言中可用结构指针来描述 12345678910111213141516#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0#define MAXSIZE 20 /* 存储空间初始分配量 */typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList; /* 定义LinkList */ ​ 结点由存放数据元素的数据域和存放后续结点地址的指针域组成。假设 p 是指针域指向线性表第i个元素的指针(ai-1的指针域说白了)，则该结点ai的数据域我们可以用p-&gt;data表示，p-&gt;data的值是一个数据元素，结点ai的指针域可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向第i+1个元素，即指向ai+1的指针。 ​ 如果p-&gt;data=ai,那么p-&gt;next-&gt;data=ai+1。 ## 单链表的读取 ​ 由于单链表的地址不是连续的，所以遍历单链表比较困难，实现获取第i个元素的数据的操作GetElem。 获得第i个数据的算法思路: - 声明一个指针p指向链表第一个结点，初始化j从1开始； - 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； - 若到链表末尾p为空，则说明第i个结点不存在； - 否则查找成功，返回结点p的数据。代码实现如下：O(n) 1234567891011121314151617181920212223242526/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L,int i,ElemType *e)&#123; int j; LinkList p; /* 声明一结点p */ p = L-&gt;next; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p &amp;&amp; j&lt;i) /* p不为空或者计数器j还没有等于i时，循环继续 */ &#123; p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if ( !p || j&gt;i ) return ERROR; /* 第i个元素不存在 */ *e = p-&gt;data; /* 取第i个元素的数据 */ return OK;&#125;// Demo LinkList L; ElemType e; Status i; int j,k; GetElem(L,5,&amp;e); printf("第5个元素的值为：%d\n",e); 由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就不方便使用for来控制循环。其主要核心思想就是“工作指针后移”，这其实也是很多算法的常用技术。 单链表的插入与删除 单链表的插入 链表的插入与删除的效率是非常高的，插入只需要在插入点前结点的指针指向新插入的结点，将插入结点的指针指向后续结点即可，删除也是同样的道理，但我们要考虑到这些步骤的先后顺序，如果稍有顺序错误，可就GG了~ 假设存储元素e的结点是s，要实现结点p、p-&gt;next和s之间逻辑关系的变化，只需将结点s插入到结点p和p-&gt;next之间即可。 不用惊动其他结点，只需要让s-&gt;next和p-&gt;next的指针做一点改变即可。 s-&gt;next=p-&gt;next; p-&gt;next=s 第一句代码是让p的后继结点改成s的后继结点，再把结点s变成p的后继结点。 ok，看似很简单啊，但是我们先看看指向的关系，其实里面的顺序关系是非常重要的。 在第一行代码执行完，有2个指针指向p-&gt;next 当第二句代码执行完后，原本指向p-&gt;next的指针断开了与ai+1的链接，指向了s，成功将s插入。 ok，那么如果先执行第二句会怎么样呢，由于你把p-&gt;next指向了s，那么你就会找不到原本的p-&gt;next了，他就丢了，你无法去表示它了，哟呵，完犊子了，链表断了！ 单链表第i个数据插入结点的算法思路： 声明一指针p指向链表头结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累积加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，在系统中生成一个空结点； 将数据元素e赋值给s-&gt;data; 单链表的插入标准语句s-&gt;next=p-&gt;next; p-&gt;next=s 返回成功 12345678910111213141516171819202122232425262728293031/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */Status ListInsert(LinkList *L,int i,ElemType e)&#123; int j; LinkList p,s; // 指向单链表的头结点 p = *L; j = 1; while (p &amp;&amp; j &lt; i) /* 寻找第i个结点 */ &#123; // 指针向后移动 p = p-&gt;next; ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-&gt;data = e; s-&gt;next = p-&gt;next; /* 将p的后继结点赋值给s的后继 */ p-&gt;next = s; /* 将s赋值给p的后继 */ return OK;&#125;// Demo printf("初始化L后：ListLength(L)=%d\n",ListLength(L)); for(j=1;j&lt;=5;j++) i=ListInsert(&amp;L,1,j); printf("在L的表头依次插入1～5后：L.data=");// 在L的表头依次插入1～5后：L.data=5 4 3 2 1 ListTraverse(L); 在这段算法代码中，我们用到了c语言的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中找了一块空地，准备用来存放数据e的s结点。 单链表的删除 设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。 ​ 我们所要做的就是一步，p-&gt;next=p-&gt;next-&gt;next，用q来取代p-&gt;next, 单链表第i个数据删除结点的算法思路： 声明一个结点p指向链表第一个结点，初始化j从1开始 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，将想删除的结点p-&gt;next赋值给q; 单链表的删除标准语句p-&gt;next=q-&gt;next; 将q结点中的数据赋值给e，作为返回； 释放q结点； 返回成功 1234567891011121314151617181920212223242526272829303132/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */Status ListDelete(LinkList *L,int i,ElemType *e) &#123; int j; LinkList p,q; p = *L; j = 1; while (p-&gt;next &amp;&amp; j &lt; i) /* 遍历寻找第i个元素 */ &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j &gt; i) return ERROR; /* 第i个元素不存在 */ q = p-&gt;next; p-&gt;next = q-&gt;next; /* 将q的后继赋值给p的后继 */ *e = q-&gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK;&#125;// Demok=ListLength(L); /* k为表长 */ for(j=k+1;j&gt;=k;j--) &#123; i=ListDelete(&amp;L,j,&amp;e); /* 删除第j个数据 */ if(i==ERROR) printf("删除第%d个数据失败\n",j); else printf("删除第%d个的元素值为：%d\n",j,e); &#125; ​ 这段算法代码里，我们又用到了另一个C语言的标准很熟free。它的作用就是让系统回收一个Node结点，释放内存。分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。 ​ 我们发现增删都需要进行查询，但是链表的查询的时间复杂度都是O(n),这样比起来可能它们并没有什么优势，但是当我们进行多个结点的插入时，对于顺序构造需要移动n-i个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。 ​ 显然，对于插入或删除数据越复杂的操作，单链表的效率优势就越明显。 单链表的整表创建 ​ 之前的顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。对于每个单链表来说，它所占用空间的大小和位置是不需要预先分配规定的，可以根据系统的情况和实际的需求即使生成。 ​ 所以，创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始化状态起，依次建立各元素结点，并逐个插入链表。 ​ 单链表整表的创建算法思路: 声明一指针p和计数器变量i； 初始化一空链表L; 让L的头结点的指针指向NULL，即建立一个带头结点的单链表; 循环: 生成一个新结点赋值给P； 随机生成一数字赋值给p的数字域p-&gt;data; 将p插入到头结点与前一 新结点之间。 实现代码算法如下： 12345678910111213141516171819202122232425 /* 随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */ void CreateListHead(LinkList *L, int n) &#123; LinkList p; int i; srand(time(0)); /* 初始化随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; /* 先建立一个带头结点的单链表 */ for (i=0; i&lt;n; i++) &#123; p = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */ p-&gt;data = rand()%100+1; /* 随机生成100以内的数字 */ // 将新插入的结点链接到之前结点的前面 p-&gt;next = (*L)-&gt;next; //由此判断一个链表的地址指向应该是头指针的指向 // 是通过头指针往后插 (*L)-&gt;next = p; /* 插入到表头 */ &#125; &#125; // DemoCreateListHead(&amp;L,20); printf("整体创建L的元素(头插法)："); //清空L后：ListLength(L)=0 // 整体创建L的元素(头插法)：4 96 47 38 31 9 95 91 70 77 84 67 96 79 21 83 78 88 29 46 ​ 这段算法代码里，我们其实用的插队的方法，就是始终让新结点在第一的位置。我也可以把这种算法简称为头插法。这个算法主要是通过p-&gt;next = (L)-&gt;next 将新创建结点与前一结点想链，并接到前一结点前面，通过 (L)-&gt;next = p 将头结点与先加入结点相链 ​ 但是我们通常是将新结点放到最后。我们吧每次新结点都插在终端结点的后面，这种算法称之为尾插法。 实现代码算法如下： 1234567891011121314151617181920212223242526272829303132* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n) &#123; LinkList p,r; int i; srand(time(0)); /* 初始化随机数种子 */ *L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */ // 现在应该没元素 所以是头指针 也是末尾 没毛病 r=*L; /* r为指向尾部的结点 */ for (i=0; i&lt;n; i++) &#123; p = (Node *)malloc(sizeof(Node)); /* 生成新结点 */ p-&gt;data = rand()%100+1; /* 随机生成100以内的数字 */ r-&gt;next=p; /* 将表尾终端结点的指针指向新结点 */ // 这是将r这个结点后移了 r = p; /* 将当前的新结点定义为表尾终端结点 */ &#125; r-&gt;next = NULL; /* 表示当前链表结束 */&#125;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD =======// Demoi=ClearList(&amp;L); printf("\n删除L后：ListLength(L)=%d\n",ListLength(L)); CreateListTail(&amp;L,20); printf("整体创建L的元素(尾插法)："); ListTraverse(L);// 删除L后：ListLength(L)=0// 整体创建L的元素(尾插法)：46 29 88 78 83 21 79 96 67 84 77 70 91 95 9 31 38 47 96 4 ​ 注意L与r的关系，L是指整个单链表，而r是指向尾结点的变量，r会随着循环不断变化结点(r-&gt;next=pr = p;),而L则是随着循环增长尾一个多结点的链表。 ​ r-&gt;next = p 的意思是将刚才的表尾终端结点r的指针指向新结点p，将新创建的结点接到后面。 ​ ​ 而r-&gt;next=p可能不太好理解，ok，首先分析下执行完上面那条语句后的r p 关系，r现在不是最后一个了 p 才是，但是我们需要一直让r当最后一个，p又是每个循环新创建的东西，所以现在我们需要将r往后挪个窝，让r重新回到最后。这行代码就是这个目的了！ ​ 本来r是在ai-1元素的结点，可现在它已经不是最后的结点了，现在最后的结点是ai，所以应该让将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。 ​ 循环结束后，应该让这个节点的指针域为NULL，因此有 “r-&gt;next = NULL”,以便以后遍历时可以确认其是尾部。 单链表的整表删除 ​ 当我们不使用这个链表的时候，我们需要将它销毁，就是说白了释放内存空间。 ​ 单链表整表删除的算法思路如下: 1. 声明一个结点p和q； 2. 将第一个结点复制给p; 3. 循环: - 将下一结点赋值给q; - 释放p; - 将q赋值给p;实现代码算法如下: 123456789101112131415/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p,q; // 如果 p = (*L) 则为一个头指针 (指向第一个结点) p=(*L)-&gt;next; /* p指向第一个结点 */ while(p) /* 没到表尾 */ &#123; q=p-&gt;next; free(p); p=q; &#125; (*L)-&gt;next=NULL; /* 头结点指针域为空 */ return OK;&#125; ​ q变量是作为一个临时变量存放p的，因为当执行”free(p)“时，p的指针域中的地址也没了，其他就比较简单，循环后依旧让尾指针的指针域为NULL。 单链表结构与顺序存储结构优缺点 结论: 若线性表需要频繁查找，很少进行插入和删除操作时，使用顺序存储结构。 若要频繁插入和删除时，使用单链表节后 当线性表中元素个数变化较大或根本不知道有多大时，最好用单链表结构。 事先知道线性表的大致长处，使用顺序存储结构。 ## 循环链表 ​ 单链表由于每个结点只存储了向后的指针，到了尾标识就停止了向后链的操作，当中某一结点就无法找到它的前驱结点，不能返回。 ​ 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。 ​ 循环链表的出现解决了如果我们不是从头指针指向第一结点仍然能访问每一个结点。 ​ 为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，并不是说循环链表必须要头结点。 ​ 其实，循环链表和单链表的主要差异在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环为结束。 ​ 在单链表中，我们可以使用头结点，用O(1)的时间访问第一个节点，但对于要访问到最后一个结点，却需要O(n)时间，因为需要将链表全部扫描一遍。 ​ 我们通过指向终端结点的尾指针来循环链表，此时查找开始结点和终端结点都很方便。 ​ 从s图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其复杂度也为O(1)。 ​ 当我们要将两个循环链表合并成一个表时，有了尾指针就非常简单了。下面两个循环链表，它们的尾指针分别是rearA和rearB。 ​ 要想将它们合并，只需要如下操作。 12345p=rearA-&gt;next; // 保存A表的头结点 即1rearA-&gt;next=rearB-&gt;next-&gt;next; // 将本指向B表的第一个结点(不是头结点) 赋值给rearA-&gt;next 即2(头结点)q=rearB-&gt;next;rearB-&gt;next=p; //将原A表的头结点赋值给rearB-&gt;next 即3free(q) // 释放q &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 双向l建表 ​ 我们在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。 ​ 双向链表是在单链表的每个结点中，再设置一个指向其他前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 12345678// 线性表的双向链表存储结构typedef struct DulNode&#123; ElemType data; // 直接前驱指针 struct DuLNode *prior; // 直接后继指针 struct DuLNode *next;&#125; DulNode, *DuLinkList; ======= 双向链表 ​ 我们在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为O(1)。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。 123456789// 线性表的双向链表存储结构typedef struct DulNode&#123; ElemType data; // 直接前驱指针 struct DulNode *prior; // 直接后继指针 struct DuLNode *next;&#125; DulNode *DuLinkList; ​ 既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。双向链表的循环带头结点的空链表与非空链表如图所示。 ​ 由于这是双向链表，那么对于链表中的某一个结点P，它的后继的前驱结点，与前驱的后继都是自己。 p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next ​ 双向链表是单链表中拓展出来的结构，它的很多操作是和单链表相同的，例如：求长度的ListLength，查找元素的GetElem等，这些操作都只要设计一个方向的指针，但在插入与删除需要涉及一个结点的两边结点操作时，情况就不相同了。 ​ 插入操作不复杂，需要注意顺序。假设存储元素e的结点为s,要实现将结点s插入到结点p和p-&gt;next之间需要下面几步。 1234s -&gt; prior = p; // 把p赋值给s的前驱，如图1s -&gt; next = p -&gt; next //把p-&gt;next赋值给s的后端，如图2p -&gt; next -&gt; prior = s // 把s赋值给p-&gt;next的前驱，如图3p -&gt; next = s // 把s赋值给p的后端，如图4 ​ 关键在于它们的顺序，由于第2步和第3步都用到了p-&gt;next。如果第4步先执行，则会使得p-&gt;next提前边变成了s，使得插入的工作完不成。 ​ 顺序:(我感觉的话最先弄得是插入的结点自身的东西然后因为你获取的是p结点 所以先该跟p有关的也就是p-&gt;next 有关的东西，然后最后再改p本身，因为如果你先动了p,那么p-&gt;next就搞不定了) 1. 先搞定s的前驱和后继 2. 搞定后结点的前驱 3. 解决前结点的后续 123p-&gt;prior-&gt;next=p-&gt;next //把p-&gt;next赋值给我p-&gt;prior的后继 如图1p-&gt;next-&gt;prior=p-&gt;prior //把p-&gt;prior赋值给p-&gt;next的前驱 如图2free(p) //释放结点p ​ 双向链表由于每个接待你都需要记录两份指针，所以再空间上要占用略多一些，但使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。 ## 总结回顾 ​ ​ 线性表是零个或多个具有相同类型的数据元素的有限序列。链表比较快速的插入与删除。 b68ff727ae8177de918a107402988034fe81212e]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构-概述]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[前言 数据结构与算法算是程序的灵魂，本系列文章是根据《大话数据结构》与《算法》书本内容所写的内容总结的读书笔记，加上自己的一定理解。 数据结构绪论 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合 基本概念与术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。 数据元素：书组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构(存储结构) 逻辑结构 逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构 集合结构中的数据元素除了通属于一个集合外，它们之间没有其他关系。各个数据元素是平等的，它们的共同属性是“同属于一个集合”，类比于数学中的集合 线性结构(一对一) 树形结构(一对多) 图形结构(多对多) 注意事项： 将每一个数据元素看做一个结点，用圆圈表示 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示 物理结构 是指数据的逻辑结构在计算机中的存储形式。 数据的存储结构应正确反映数据元素之间的逻辑关系，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。 数据元素的存储结构形式有两种：顺序存储和链式存储 顺序存储结构 是把数据元素存放在 地址连续 的存储单元里，其数据之间的逻辑关系和物理关系是一致的。 链式存储结构 是把元素存放在 任意 的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到向管理数据元素的位置。 算法 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法的特性：有穷性、确定性、可行性、输入、输出 算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求 算法的度量方法：事后统计方法、事前分析估算方法 推导大O阶：(最高阶次方去常数项) 用常数1取代运行时间中所有加法常数 在修改后的运行次数函数中，只保留最高阶段 如果最高阶项存在且不是1，则去除与整个项相乘的常数 常见的时间复杂度多消耗时间的大小排序：]]></content>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[holiday summary(3)]]></title>
    <url>%2F2019%2F08%2F20%2Fholiday-summary-3%2F</url>
    <content type="text"><![CDATA[前言 ​ 在快乐了几天后决定今天把假期总结的东西写完，看看剩的技术还挺多的，就稍微提提好了。肥宅快乐，嗝~ 授权管理框架 Shiro架构与功能介筛 1.认证与授权相关基本概念 两个基本的概念 安全实体：系统需要保护的具体对象数据 权限：系统相关的功能操作，例如基本的CRUD Authentication：身份认证/登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web支持，可以非常容易的集成到Web环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率； Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 2.Shiro四大核心功能:Authentication,Authorization,Cryptography,Session Management 3.Shiro三个核心组件：Subject, SecurityManager 和 Realms. Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器； Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。 Spring Security简介 ​ Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。它与Spring MVC有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。 它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。 Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。 业务对象或者方法的安全：控制方法访问权限的。 AuthenticationManager：处理来自于框架其他部分的认证请求。 AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。 AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。 UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。 Spring Security 简介 ​ Spring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于 Spring 的应用程序提供身份验证和授权支持。它与 Spring MVC 有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作 “认证” 与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。 它的设计是基于框架内大范围的依赖的，可以被划分为以下几块。 Web/Http 安全：这是最复杂的部分。通过建立 filter 和相关的 service bean 来实现框架的认证机制。当访问受保护的 URL 时会将用户引入登录界面或者是错误提示界面。 业务对象或者方法的安全：控制方法访问权限的。 AuthenticationManager：处理来自于框架其他部分的认证请求。 AccessDecisionManager：为 Web 或方法的安全提供访问决策。会注册一个默认的，但是我们也可以通过普通 bean 注册的方式使用自定义的 AccessDecisionManager。 AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。 UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。 Shiro 和 Spring Security 比较 Shiro 比 Spring 更容易使用，实现和最重要的理解 Spring Security 更加知名的唯一原因是因为品牌名称 “Spring” 以简单而闻名，但讽刺的是很多人发现安装 Spring Security 很难 然而，Spring Security 却有更好的社区支持 Apache Shiro 在 Spring Security 处理密码学方面有一个额外的模块 Spring-security 对 spring 结合较好，如果项目用的 springmvc ，使用起来很方便。但是如果项目中没有用到 spring，那就不要考虑它了。 Shiro 功能强大、且 简单、灵活。是 Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行 Docker 跟Docker能装的一些能用到的技术 ​ 这里就主要提一下Docker就好了，因为里面的几种技术我也没有过多的了解(Docker也没咋玩会)。那让我们先瞅瞅里面的几项技术好了 Redis Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists），集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 RabbitMQ RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。 MongoDB MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 laticsearch ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 工具 工具这里根据功能两两分组，讲解一下，就好啦。 Mybatis Plus &amp; PageHelper &gt;​ **这两个工具都是对持久层框架Mybatis的增强，旨在简化持久层开发。**Mybatis Plus​ 对于SPring Boot，官方提供了Start，较好的整合了Mybatis Plus，直接在pom.xml中导入对应的依赖即可。 123456&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt;&lt;/dependency&gt; MyBatis-Plus（简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生 PageHelper123456&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; ​ 为啥用这个插件呢？因为他代码实现分页就一行代码。在进行查询前插入一个静态方法即可。 PageHelper.startPage（pageNum ， pageSize，这个方法就是类似我们数据库操作的limit start ， count 就完事了！ Swagger2 &amp;&amp; PostMan Swagger2​ Swagger是根据我们写的接口动态生成一个html界面，供前台测试用，他不仅可以看接口(这里推荐用restful风格的接口！！！！)的作用，最关键是可以进行测试（下面的一款是专门用来测接口的）。而且动态生成的页面，改代码的时候，直接改对应注解就行了，对于后端来说比较友好~~ ​ 首先是引入依赖，在pom.xml文件中引入依赖。 123456&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 然后是Swagger配置类 12345678910111213141516171819@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .pathMapping("/") .select() .apis(RequestHandlerSelectors.basePackage("cn.cxjd.demo.controller")) .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder() .title("轻大软创门户网站API文档") .description("含有3大模块接口:管理员模块，新闻模块，新闻分类模块") .version("1.0") .contact(new Contact("联系后端开发者", "", "877495283@qq.com")) .build()); &#125;&#125; 配置类一定要写@EnableSwagger2这个注解哦，大概就是开启swagger的功能的意思吧。 123456789101112131415161718@Api(value = "涉及用户的接口")@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @PostMapping("/user") @ApiOperation(value = "用户注册", notes = "传入user对象(包含username与password即可)") @ApiImplicitParams(&#123;@ApiImplicitParam(name = "user", value = "用户实体", required = true,dataType = "User",paramType = "body")&#125;) public RespBean addUser(@RequestBody User user) &#123; int register = userService.register(user); if (register == 1) &#123; return new RespBean("error", "该用户名已存在"); &#125; else if (register == 0) &#123; return new RespBean("success", "创建成功"); &#125; return null; &#125; 具体的注解使用方法参考下这篇博客 postMan postman是一款用来测试接口的软件，在Chrome中搜索下载就好了，具体就不在这里说了~~ FastJson &amp;&amp; Druid 来，先上一下这两个技术的maven依赖 12345678910111213&lt;!-- fastjson的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.59&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid 的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt;&lt;/dependency&gt; 从这依赖都可以看出来了，这属于阿里开发的东西喽，然后了解不多，都是跟着网上看的，网址放着，等开学用到了再仔细研究写心得好了。 W3C fastJson druid教学]]></content>
      <tags>
        <tag>感悟</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Holiday summary(二)]]></title>
    <url>%2F2019%2F08%2F17%2FHoliday-summary-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言 跟着上一篇的框架结构大概的总结完了，这次总结图里左边的内容，让我们看看都有啥吧。 其他 ​ Maven 、git 算是2个编程比较常用的工具吧，但是为了有区别一点还是单独拉出来了。 Maven**Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。Maven简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。**Maven主要做了两件事： 统一开发规范与工具 统一管理jar包 Maven常用指令 Maven项目结构​ 若要使用 Maven，那么项目的目录结构必须符合 Maven 的规范，其目录结构如下： ​ Maven 基本命令 -v: 查询 Maven 版本 本命令用于检查 maven 是否安装成功。 Maven 安装完成之后，在命令行输入 mvn -v，若出现 maven 信息，则说明安装成功。 compile：编译 将 java 源文件编译成 class 文件 test: 测试项目 执行 test 目录下的测试用例 package: 打包 将项目打成 jar 包 clean: 删除 target 文件夹 install: 安装 将当前项目放到 Maven 的本地仓库中。供其他项目使用 Maven的仓库 Maven 仓库用来存放 Maven 管理的所有 Jar 包。分为：本地仓库 和 中央仓库。 本地仓库：Maven 本地的 Jar 包仓库。 中央仓库： Maven 官方提供的远程仓库。 当项目编译时，Maven 首先从本地仓库中寻找项目所需的 Jar 包，若本地仓库没有，再到 Maven 的中央仓库下载所需 Jar 包。 坐标 在 Maven 中，坐标是 Jar 包的唯一标识，Maven 通过坐标在仓库中找到项目所需的 Jar 包，通过官方依赖仓库去寻找 如下代码中，groupId 和 artifactId 构成了一个 Jar 包的坐标。 123456789101112&lt;dependency&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; groupId: 所需 Jar 包的项目名 artifactId: 所需 Jar 包的模块名 version: 所需 Jar 包的版本号 依赖范围 scope在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 compile ：默认范围，用于编译 provided：类似于编译，但支持你期待 jdk 或者容器提供，类似于 classpath runtime: 在执行时需要使用 test: 用于 test 任务时使用 system: 需要外在提供相应的元素。通过 systemPath 来取得 systemPath: 仅用于范围为 system。提供相应的路径 optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 传递依赖 与 排除依赖 传递依赖：如果我们的项目引用了一个 Jar 包，而该 Jar 包又引用了其他 Jar 包，那么在默认情况下项目编译时，Maven 会把直接引用和简洁引用的 Jar 包都下载到本地。 排除依赖：如果我们只想下载直接引用的 Jar 包，那么需要在 pom.xml 中做如下配置：(将需要排除的 Jar 包的坐标写在中) 12345678910111213141516&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/exclusion&gt;&lt;/exclusions&gt;&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 依赖冲突 ​ 若项目中多个 Jar 同时引用了相同的 Jar 时，会产生依赖冲突，但 Maven 采用了两种避免冲突的策略，因此在 Maven 中是不存在依赖冲突的。 路径优先 1234本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar本项目——&gt;C.jar——&gt;X.jar本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar本项目——&gt;C.jar——&gt;X.jar 本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar 本项目——&gt;C.jar——&gt;X.jar 若本项目引用了 A.jar，A.jar 又引用了 B.jar，B.jar 又引用了 X.jar，并且 C.jar 也引用了 X.jar。 在此时，Maven 只会引用引用路径最短的 Jar。 声明优先 若引用路径长度相同时，在 pom.xml 中谁先被声明，就使用谁。 聚合 什么是聚合？ 将多个项目同时运行就称为聚合。 如何实现聚合？ 只需在 pom 中作如下配置即可实现聚合： 12345678&lt;modules&gt; &lt;module&gt;web-connection-pool&lt;/module&gt; &lt;module&gt;web-java-crawler&lt;/module&gt;&lt;/modules&gt;&lt;modules&gt; &lt;module&gt;web-connection-pool&lt;/module&gt; &lt;module&gt;web-java-crawler&lt;/module&gt;&lt;/modules&gt; 继承 什么是继承？ 在聚合多个项目时，如果这些被聚合的项目中需要引入相同的 Jar，那么可以将这些 Jar 写入父 pom 中，各个子项目继承该 pom 即可。 如何实现继承？ 父 pom 配置：将需要继承的 Jar 包的坐标放入标签即可。 1234567891011121314151617181920&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子pom配置: 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;父pom所在项目的groupId&lt;/groupId&gt; &lt;artifactId&gt;父pom所在项目的artifactId&lt;/artifactId&gt; &lt;version&gt;父pom所在项目的版本号&lt;/version&gt;&lt;/parent&gt; &lt;parent&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;parent&gt; &lt;groupId&gt;父pom所在项目的groupId&lt;/groupId&gt; &lt;artifactId&gt;父pom所在项目的artifactId&lt;/artifactId&gt; &lt;version&gt;父pom所在项目的版本号&lt;/version&gt;&lt;/parent&gt; &lt;parent&gt; &lt;artifactId&gt;resource-search&lt;/artifactId&gt; &lt;groupId&gt;cn.missbe.web.search&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; git git是什么​ Git是目前世界上最先进的分布式版本控制系统。 工作原理 / 流程： Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 SVN与Git的最主要的区别 ​ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 ​ Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 创建仓库(repository) 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 首先创建一个空文件夹 通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 执行后会在当前目录下生成.git文件(可能是以隐藏文件的形式) 把文件添加到仓库 第一步，在当前路径下创建文件 readme.txt 第二步，用命令git add告诉Git，把文件添加到仓库： $git add redme.txt 用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &#39;wrote a file&#39; 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 当然也可以通过git add .添加路径下的所用文件进入.git里 可以不用一个一个添加 小结初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 版本回滚 ​ 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 使用git log查看提交 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset：（如果用commit_id进行回滚操作，可以只用写部分id但要确定结果唯一） 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区与暂存区 工作区: 就是你在电脑里能看到的目录，就是你放在.git的同级目录下除了.git文件(怎么有点拗口) 版本库（Repository）:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 命令git checkout – readme.txt意思就是，把readme.txt`文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 添加远程库 ​ 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； ​ 添加后，远程库的名字就是origin，这是 Git 默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 ​ 关联后，使用命令git push -u origin master第一次推送 master 分支的所有内容； 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git 不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 ​ 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； ​ 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 分支管理]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Holiday summary(一)]]></title>
    <url>%2F2019%2F08%2F15%2Fholiday%20summary(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 如今，我在空调里吃着🍉，享受着别人马上要结束，而我刚刚开始的暑假生活。俗话说的好，假期都是用来超越别人的(我可不干这种事情，主要我太懒)。暑假一个月，说少不少，说多不多，但在平常的学习上很少有时间可以进行这样集中的编程知识的学习，不时成为锤炼自己的好时机。假期确实提升了很多，有必要进行一些梳理，进行一些总结。当然本次只是给一些技术的进行大概的总结，涉及的知识不会太深。 看看学了什么 让我们首先以一张思维导图开始这篇博文哇 好专业 666鸭,图里包含了这个暑假学到或者了解到当然不可能面面俱到。右边是框架的学习，左边是较为细一点反正自己能理解的一个划分东西还算比较多，够唠一会的了。 框架学习 框架学习之SSM框架​ 作为一个9102年学框架的后端Java开发人员，当然要从SSM框架学起(学校还在教着SSH),SSM框架即为Spring、SPring MVC、Mybatis。框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。 Spring Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。 Spring的核心思想是IoC（控制反转），面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 ​ (上面的粘贴自百度)在我的理解里，Spring 主要分为2部分(IOC与AOP)，IOC就是帮你创建对象的，而不用每一个都自己new，通过依赖注入实现程序之间的解耦。框架的出现大多都是提供良好的封装性、实现程序的高内聚与低耦合。 ​ AOP 即 Aspect Oriented Program 面向切面编程。首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP AOP 的目的 AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 我的理解 ​ AOP的是让开发人员更专注于核心业务的处理，而不用在核心业务的周围围绕着周边业务，增大代码量，让代码的可读性变差，耦合度增加。 Spring MVC​ SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。 ​ pring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。Spring MVC 是 Spring 产品组合的一部分，它享有 Spring IoC容器紧密结合Spring松耦合等特点，因此它有Spring的所有优点。 mybatis​ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 ​ 页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。(三层架构) 框架学习之Spring Boot Spring Boot 作为以后后端开发的使用框架，在Spring、Spring MVC 基础上减少了大量的配置，作为一种开箱即用的框架，大大简化了开发人员的开发流程。 首先分享一些比较好的学习连接资源 Spring Boot 官方文档 Spring Boot 中文索引 Spring Boot 教程汇总 江南一点雨 Spring Boot 系列文章 纯洁的微笑 Spring Boot 系列文章 什么是Spring Boot呢？​ 什么是Spring Boot？他跟SPring又有什么关系?怎么又来了一种新的框架？相信无数初学者都曾想过这些问题。首先Spring Boot并非是一种全新的框架。Boot即为启动的意思，旨在快速启动你的Spring项目并通过一些自动配置来减少人为的主动配置。并且Spring Boot 对一些主流框架都有整合的Start,他就像一个框架届的Maven，通过对框架的整合，让开发变得简单起来。 Spring boot的四个主要特性 独立运行的Spring项目：Spring Boot可以以jar包的形式来运行，运行一个Spring Boot项目我们只需要通过java -jar xx.jar类运行。非常方便。 内嵌Servlet容器：Spring Boot可以内嵌Tomcat，这样我们无需以war包的形式部署项目。 提供starter简化Maven配置：使用Spring或者SpringMVC我们需要添加大量的依赖，而这些依赖很多都是固定的，这里Spring Boot 通过starter能够帮助我们简化Maven配置。 自动配置Spring 准生产的应用监控 无代码生成和xml配置 总结 暂时先大概的说下这2个后端框架吧，只是大概的讲讲这些框架的有什么作用以及它们的应用，之后再写写那些中间件,溜啦😉😉😉😉~]]></content>
      <tags>
        <tag>感悟</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[just one year]]></title>
    <url>%2F2019%2F08%2F13%2Fjust-one-year%2F</url>
    <content type="text"><![CDATA[前言 ​ 不知不觉已经来轻大一年了，去年的我还对编程懵懂无知，曾经为自己下了一个IDE在控制台上输出了“hello world”而开心不已，如今我已经开始写接口文档，进行前后端的分离开发。是时候在一个深夜(凌晨两点)去回忆一下，这一年的日子，去想想得失，想想时间带来了什么。 去年暑假​ 为什么选做一个程序员呢？可能比较喜欢搞点好东西，获取一些酷酷的软件、插件就像如同获得了宝藏一样，让我开心不已，经常为了折腾某一个软件去折腾好几天(比如搞这个花里胡哨的博客折腾了我3天)。确定了想要学软件后，我开始私聊了一些学长咨询。可能这也是一切的起点吧，我知道了当时学校有一个实验室叫软件创新基地。当时的我就立志想进软创。故事就由此展开了。​ 开始去B站上找了浙江大学的视频看，还傻傻的拿了笔记本写了笔记，后来因为去打工，算是搁置了，只看到了循环？之后打工的经历或许也改变了我，它让我变得现实了，待人接物也大不相同了。``` 初识 （9月-11月)​ 一切都那么新鲜，对什么事情都充满了好奇，什么都想尝试，比如吃一口苹果。这一次我为自己的新鲜感与欠妥当付出了代价，这个甜甜的苹果的滋味知道如今仍然在嘴中回荡只是略带苦涩。可一切都没有重来的余地，何况曾今的*也给过我满嘴的芬芳。 ​ 聊些技术有关的吧。在知道软创有考核时，当时被安利买了 《C prime plus》的我每天都在6点钟去看书，默默为它做准备，是这一年来去图书馆最勤的时候。如我所愿，我通过了面试。可这不意味着安稳，一次一次考核，身边的空位开始变多，不敢松懈，不敢停下。一本厚厚的书也被我做足了笔记，没有电脑就自己推演结果，有电脑就在电脑上执行一次。一步一步，到了指针等什么乱七八糟的东西，令人头疼、头秃。之后进行了C语言实训项目的提前编程。说实话，刚开始的时候，我大概有 3、4天都不知道从何下手，翻翻CSDN、问问谷歌。先编写了骚气的功能界面(唉，骚气慢慢的我)，可是输入的验证却难住了我，判断用户的输入，进行提示反馈。从百度的加上我自己考虑的，大概脑子里有个谱了，添加、显示、更新、删除，最开始的CRUD的实现。万事开头难，这个项目费事程度比我以后碰到bug解决时间都长，可一切都值得的。 Time to change(12月-2月)​ 初入茅庐的我，起初觉得学完了C语言，好像感到自己已经精通了编程一样，有些飘飘然。而Java作为一门以后用来吃饭的语言，显然不仅仅只需要掌握语法，编程也不仅仅只是编程语言的学习，事实上开发中的问题总会接踵而至。学习OOP语言，在没有面向对象思想的我一时间难以理解，尤其是构造方法，子父类等等。在接触新事物的时候，这些都是难免的，在自己试错自己找到解决方法后对知识的牢记与成就感是他人直接告诉你结果的感觉是截然不同的。诚然，试错是成长路上不可或缺的一部。 ​ 在越过了OOP的坎后，后面几大章也并不轻松(虽然学校一点都不讲),IO、集合、多线程、网络编程，说实话，这些知识当时因为学的太快并没有留下很深印象(毕竟一个半月学会一门编程语音显得并没有那么轻松)，不过在当时也算是掌握的算不错，当然在下学期(大二上)，如果有功夫的话是需要好好回顾的，毕竟Java SE是基础。 ​ 好了又到了做项目的时候。项目所需的知识总和你掌握的知识有一定的差距，这些短板也会在项目中补齐。当时刚做项目的时候，感觉链接数据库(JDBC)都是一个难点，索性找到了一个黑马的管家婆(这名字土爆了)的视频，跟着学习。我一直觉得程序猿跟画家一样，开始时候进行描摹，从别人的画中找到感觉，再进行自己的创作。收获颇多的可能不是会根据老师讲的可以完成自己的项目，而是视频中的MVC思想，让我对分层进行了了解(我想会抽个文章写一下MVC与三层架构的那些事)。虽说凭借着MAC的美学设计，不用加任何修饰，程序的界面简洁优雅(吹爆MBP)，也算是第一次进行了可视化程序。点点按按的总比命令行好，虽然程序员的原则是能用键盘的事情绝不用鼠标，笑。 ​ 有些事情总算没有了挽回的余地，事实上，一些事情早都可以预料却不能坦然面对，总之，各自安好。可是真的安好了嘛？我开始不推心置腹，开始冷眼旁边，开始置身事外，我真的不明白或者看不透嘛？可能就是看的太透才会这样。一切的一切都Don’t Care，它好像一颗慢性毒药，一点一点再暗暗杀死我，而我却品尝着这令人上瘾的滋味。 得失 (3月-6月)​ well，下学期就放一个章节说好了。学完了Java SE，开始了Java Web的内容。我觉得还是明确个方向学习Java Web 是比较好的(我一辈子不要写标签！！！！)，但是在Java web中也算踩坑严重吧，因为一些事情的耽误，学的比较拖拉，导致又反反复复学习，最后学了大概来来回回有3遍，可能加深印象了？web作为框架的基础，是有必要学习的，当时急切的想要有后端的开发能力(框架方便啊)，所以急于求成，现在也有点后悔，项目也做了稀巴烂，几个月都感觉压力与失望，比较丧。 不过也有好的一面不是嘛？失去了一些东西后，更有精力专注于自己的事情上，每天做规划，几点到几点锻炼腹肌，几点到几点撸铁，晚上每天带着耳机去看着带着晚霞的体育场，带着耳机跑5km,那种每天回想起来一切都按自己计划执行，每天没有辜负自己的完美生活令自己开心不已，每天都对明天充满期待，体脂率一点点下降，肌肉率一点点上升，感觉生活充满了期望。(哦，看看现在，天天敲代码，摸着自己的小肚子) 总结一年的时光，感觉自己学会了很多，失去了很多，得到了许多，经历了许许多多的美好，也丧了很长时间。可这就是生活，起起伏伏伏伏伏伏伏伏伏伏伏伏，希望自己可以继续朝着自己向往的生活努力，向着自己想成为的人而努力。等待下一个一年。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
