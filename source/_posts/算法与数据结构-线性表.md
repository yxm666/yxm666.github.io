---
title: 算法与数据结构-线性表
date: 2019-09-09 16:21:23
tags:
	- 算法与数据结构
categories:
	- 算法与数据结构
---

#　前言

---

>  线性表是零个或多个具有相同类型的数据元素的有限序列。主要分为：顺序存储结构、链式存储结构，在链式存储结构中又主要分为：单链表、静态链表、循环链表、双向链表

![线性表结构图](https://i.loli.net/2019/09/09/Diw7kV58EF9WhKU.png)



# 线性表

---

线性表(List):零个或多个数据元素的有限序列

序列：

- 元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有切只有一个前驱和后继。

![线性表的数学定义](https://i.loli.net/2019/09/09/2E1KdbwhgXHoNuS.png)

所以 线性表元素的个数n（n>=0）定义为线性表的长度。当n=0时，称为空表。

## 线性表的抽象数据类型

---

>在讲这个地方之前我想对抽象数据类型进行一个解释，因为之前也不理解抽象数据类型
>
>抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。抽象数据类型是与表示无关的数据类型，是一个数据模型及定义在该模型上的一组运算。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。
>
>是不是感觉晦涩难懂，简单点，就是这个线性表应该具有哪样的操作

线性表的数据类型定义如下：

![](https://i.loli.net/2019/09/09/AwyXQltUBdoL2nb.png)

![](https://i.loli.net/2019/09/09/dgfFO85mj7pqNAE.png)

## 线性表的顺序存储结构

---

## 顺序存储定义

定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素

![线性表的顺序存储示意图](https://i.loli.net/2019/09/09/cnxCt1dWyEG7S2s.png)

## 顺序存储方式

  在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中

```c
#define MAXSIZE 20 /* 存储空间初始分配量 */

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */

typedef struct
{
	ElemType data[MAXSIZE];        /* 数组，存储数据元素 */
	int length;                    /* 线性表当前长度 */
}SqList;

```

描述顺序存储结构需要三个属性：

- 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。
- 线性表额最大存储容量：数组长度MaxSize。
- 线性表的当前长度：length

##　数组长度与线性表长度区别

​	数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。

​	线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。	

## 顺序存储结构的插入与删除

---

## 获取元素操作

---

```c
Status GetElem(SqList L,int i,ElemType *e)
{
    // 判断是否为空 或者数组下标越界
    if(L.length==0 || i<1 || i>L.length)
            return ERROR;
    *e=L.data[i-1];

    return OK;
}

//Demo 
/*
	因为只有传入指针才能对方法外变量的值做改变 故传入的是地址，
	首先定义一个 int 类型变量 e 然后将其地址传入(&e)
	此时e指向了结构体中数组所在下标的地址
	此时 方法外的变量e的值就进行了改变
*/
int main()
{
    SqList L;
    ElemType e;
   
    GetElem(L,5,&e);
    printf("第5个元素的值为：%d\n",e);
}
```

　##　插入操作

---

插入算法的思路：

- 如果插入位置不合理，抛出异常
- 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(创建一个新的数组，初始化长度加一，然后根据插入点，插入前复制原数组，插入后新数组下标加1)。
- 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。
- 将要插入元素填入位置i处。
- 表长加1

实现代码如下：

```c
/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(SqList *L,int i,ElemType e)
{ 
	int k;
	if (L->length==MAXSIZE)  /* 顺序线性表已经满 */
		return ERROR;
	if (i<1 || i>L->length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
		return ERROR;

	if (i<=L->length)        /* 若插入数据位置不在表尾 */
	{
        // 从后往前移动
		for(k=L->length-1;k>=i-1;k--)  /* 将要插入位置之后的数据元素向后移动一位 */
			L->data[k+1]=L->data[k];
	}
	L->data[i-1]=e;          /* 将新元素插入 */
	L->length++;

	return OK;
}

//demo
for(j=1;j<=5;j++)
            i=ListInsert(&L,1,j);
    printf("在L的表头依次插入1～5后：L.data=");
	//在L的表头依次插入1～5后：L.data=5 4 3 2 1
```



## 删除操作

---

删除算法的思路：

- 如果删除位置不合理，抛出异常
- 取出删除元素；
- 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
- 表长减1

实现代码如下：

```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(SqList *L,int i,ElemType *e) 
{ 
    int k;
    if (L->length==0)               /* 线性表为空 */
		return ERROR;
    if (i<1 || i>L->length)         /* 删除位置不正确 */
        return ERROR;
    *e=L->data[i-1];
    if (i<L->length)                /* 如果删除不是最后位置 */
    {
        for(k=i;k<L->length;k++)/* 将删除位置后继元素前移 */
			L->data[k-1]=L->data[k];
    }
    L->length--;
    return OK;
}

//demo
 k=ListLength(L); /* k为表长 */
    for(j=k+1;j>=k;j--)
    {
            i=ListDelete(&L,j,&e); /* 删除第j个数据 */
            if(i==ERROR)
                    printf("删除第%d个数据失败\n",j);
            else
                    printf("删除第%d个的元素值为：%d\n",j,e);
    }
```



## 线性表顺序存储结构的优缺点

---



![优缺点](https://s2.ax1x.com/2019/09/09/ntOaff.png)







# 线性表的链式存储结构

---

## 线性表链式存储结构定义

---

​	线性表的链式存储结构的特点是用一组<u>任意</u>的存储单元存储线性表的存储元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些存储元素可以存在内存未被占用的任意位置。

![链式存储结构](http://yanxuan.nosdn.127.net/59b6e49d78d061ed0d3a00867070b68c.png)

![链式存储结构](https://s2.ax1x.com/2019/09/09/ntO77R.png)

​	在以前的顺序结构中，数据元素只需要存储数据元素信息就ok了，因为它们的地址是连续的，跟着地址找，一个连着一个，而链式存储结构中，除了要存储数据元素信息外，还要存储它的后续元素的存储地址。

​	因此，为了表示每个数据元素ai与其直接后续数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后续的信息(即直接后续的存储位置)。

​	存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。指针域中存储的信息呗称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。

​	n个结点（ai的存储映像）链结成一个链表，即为线性表(a1,a2.....an)的链式存储结构，因为此链表中的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。

![链式存储结构示意图](https://s2.ax1x.com/2019/09/09/nNSbAH.png)

- 链表中第一个结点的存储位置叫做头指针
- 线性链表中的最后一个结点指针为NULL("^")

![无头结点的头指针](https://s2.ax1x.com/2019/09/09/nNpVg0.png)

![带头结点的头指针](https://s2.ax1x.com/2019/09/09/nNpl59.png)

(注：头指针是指向第一个结点的 而不是第一个结点的指针域，说白了 头指针是第一个结点的地址)

​	有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点称为头结点，头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针(就是头指针)。

![](http://yanxuan.nosdn.127.net/552e2bbe034fe13d2b5118829b281893.png)

## 头指针与头结点的异同

![异同](http://yanxuan.nosdn.127.net/82a72e174f28a9b9707dac5ee359785a.png)

​	我个人认为带有头结点的单链表图好像其中头指针的位置画错了，不敢确认，按照定义与理解，头指针应该是排除再链表外的东西(个人理解)，经过请教佩哥，佩哥牛鼻！！！！！，佩哥肯定了我的想法，爱他！！！，可以查看相关文章。

[相关文章](https://blog.csdn.net/weixin_41413441/article/details/79063738)

## 线性表链式存储结构代码描述

---



![不带头结点的单链表](http://yanxuan.nosdn.127.net/b9a8b219dcfe85bd6e924d339274c95a.png)

![](http://yanxuan.nosdn.127.net/5d2fc6d07ae72fd62e1aed7dde0d25bf.png)

![](http://yanxuan.nosdn.127.net/504853f74a73204cfbe582412d49046b.png)

在单链表中，我们在C语言中可用结构指针来描述

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXSIZE 20 /* 存储空间初始分配量 */

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */

typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList; /* 定义LinkList */
```

​	结点由存放数据元素的数据域和存放后续结点地址的指针域组成。假设 p 是指针域指向线性表第i个元素的指针(ai-1的指针域说白了)，则该结点ai的数据域我们可以用p->data表示，p->data的值是一个数据元素，结点ai的指针域可以用p->next来表示，p->next的值是一个指针。p->next指向第i+1个元素，即指向ai+1的指针。

​	如果p->data=ai,那么p->next->data=ai+1。

![](http://yanxuan.nosdn.127.net/4b90a93b3b685d5d8da52771011e44ff.png)

## 

## 单链表的读取

---

​	由于单链表的地址不是连续的，所以遍历单链表比较困难，实现获取第i个元素的数据的操作GetElem。

获得第i个数据的算法思路:

	- 声明一个指针p指向链表第一个结点，初始化j从1开始；
	- 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
	- 若到链表末尾p为空，则说明第i个结点不存在；
	- 否则查找成功，返回结点p的数据。

代码实现如下：O(n)

```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L,int i,ElemType *e)
{
	int j;
	LinkList p;		/* 声明一结点p */
	p = L->next;		/* 让p指向链表L的第一个结点 */
	j = 1;		/*  j为计数器 */
	while (p && j<i)  /* p不为空或者计数器j还没有等于i时，循环继续 */
	{   
		p = p->next;  /* 让p指向下一个结点 */
		++j;
	}
	if ( !p || j>i ) 
		return ERROR;  /*  第i个元素不存在 */
	*e = p->data;   /*  取第i个元素的数据 */
	return OK;
}

// Demo
 LinkList L;
 ElemType e;
 Status i;
 int j,k;
 GetElem(L,5,&e);
 printf("第5个元素的值为：%d\n",e);
```

  由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就不方便使用for来控制循环。其主要核心思想就是“工作指针后移”，这其实也是很多算法的常用技术。

## 单链表的插入与删除

---

  ### 单链表的插入

  链表的插入与删除的效率是非常高的，插入只需要在插入点前结点的指针指向新插入的结点，将插入结点的指针指向后续结点即可，删除也是同样的道理，但我们要考虑到这些步骤的先后顺序，如果稍有顺序错误，可就GG了~

  假设存储元素e的结点是s，要实现结点p、p->next和s之间逻辑关系的变化，只需将结点s插入到结点p和p->next之间即可。

![单链表的插入](https://s2.ax1x.com/2019/09/10/nNLY9K.png)

  不用惊动其他结点，只需要让s->next和p->next的指针做一点改变即可。

`s->next=p->next; p->next=s`

  第一句代码是让p的后继结点改成s的后继结点，再把结点s变成p的后继结点。

ok，看似很简单啊，但是我们先看看指向的关系，其实里面的顺序关系是非常重要的。

- 在第一行代码执行完，有2个指针指向p->next

![连个指针指向一个结点](http://yanxuan.nosdn.127.net/76e85ca560e1ac0bc1c40f044dd5736c.png)

- 当第二句代码执行完后，原本指向p->next的指针断开了与ai+1的链接，指向了s，成功将s插入。

![成功插入](http://yanxuan.nosdn.127.net/3a2e1e2cc24cf1d6efa7e3158d440c0d.png)

  ok，那么如果先执行第二句会怎么样呢，由于你把p->next指向了s，那么你就会找不到原本的p->next了，他就丢了，你无法去表示它了，哟呵，完犊子了，链表断了！

单链表第i个数据插入结点的算法思路：

- 声明一指针p指向链表头结点，初始化j从1开始
- 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累积加1；
- 若到链表末尾p为空，则说明第i个结点不存在；
- 否则查找成功，在系统中生成一个空结点；
- 将数据元素e赋值给s->data;
- 单链表的插入标准语句s->next=p->next; p->next=s
- 返回成功

```c
/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(LinkList *L,int i,ElemType e)
{ 
	int j;
	LinkList p,s;
  // 指向单链表的头结点
	p = *L;   
	j = 1;
	while (p && j < i)     /* 寻找第i个结点 */
	{
    // 指针向后移动
		p = p->next;
		++j;
	} 
	if (!p || j > i) 
		return ERROR;   /* 第i个元素不存在 */
	s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */
	s->data = e;  
	s->next = p->next;      /* 将p的后继结点赋值给s的后继  */
	p->next = s;          /* 将s赋值给p的后继 */
	return OK;
}

// Demo
 printf("初始化L后：ListLength(L)=%d\n",ListLength(L));
    for(j=1;j<=5;j++)
            i=ListInsert(&L,1,j);
    printf("在L的表头依次插入1～5后：L.data=");
// 在L的表头依次插入1～5后：L.data=5 4 3 2 1
    ListTraverse(L); 
```

  在这段算法代码中，我们用到了c语言的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中找了一块空地，准备用来存放数据e的s结点。



### 单链表的删除

----

  设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。

![单链表的删除](http://yanxuan.nosdn.127.net/390e13dfac0970d384dbcd678fa60a00.png)

​	我们所要做的就是一步，p->next=p->next->next，用q来取代p->next,

![删除结点举例](https://s2.ax1x.com/2019/09/10/nUS6de.png)

单链表第i个数据删除结点的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 若到链表末尾p为空，则说明第i个结点不存在；
4. 否则查找成功，将想删除的结点p->next赋值给q;
5. 单链表的删除标准语句p->next=q->next;
6. 将q结点中的数据赋值给e，作为返回；
7. 释放q结点；
8. 返回成功

```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(LinkList *L,int i,ElemType *e) 
{ 
	int j;
	LinkList p,q;
	p = *L;
	j = 1;
	while (p->next && j < i)	/* 遍历寻找第i个元素 */
	{
        p = p->next;
        ++j;
	}
	if (!(p->next) || j > i) 
	    return ERROR;           /* 第i个元素不存在 */
	q = p->next;
	p->next = q->next;			/* 将q的后继赋值给p的后继 */
	*e = q->data;               /* 将q结点中的数据给e */
	free(q);                    /* 让系统回收此结点，释放内存 */
	return OK;
}

// Demo
k=ListLength(L); /* k为表长 */
    for(j=k+1;j>=k;j--)
    {
            i=ListDelete(&L,j,&e); /* 删除第j个数据 */
            if(i==ERROR)
                    printf("删除第%d个数据失败\n",j);
            else
                    printf("删除第%d个的元素值为：%d\n",j,e);
    }
```

​	这段算法代码里，我们又用到了另一个C语言的标准很熟free。它的作用就是让系统回收一个Node结点，释放内存。分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。

​	我们发现增删都需要进行查询，但是链表的查询的时间复杂度都是O(n),这样比起来可能它们并没有什么优势，但是当我们进行多个结点的插入时，对于顺序构造需要移动n-i个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。

​	显然，对于插入或删除数据越复杂的操作，单链表的效率优势就越明显。





## 单链表的整表创建

---

​	之前的顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。对于每个单链表来说，它所占用空间的大小和位置是不需要预先分配规定的，可以根据系统的情况和实际的需求即使生成。

​	所以，创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始化状态起，依次建立各元素结点，并逐个插入链表。

​	单链表整表的创建算法思路:

1. 声明一指针p和计数器变量i；

2. 初始化一空链表L;

3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表;

4. 循环:

   - 生成一个新结点赋值给P；
   - 随机生成一数字赋值给p的数字域p->data;
   - 将p插入到头结点与前一 新结点之间。

   

   实现代码算法如下：

   

   ```c
   /*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */
   void CreateListHead(LinkList *L, int n) 
   {
   	LinkList p;
   	int i;
   	srand(time(0));                         /* 初始化随机数种子 */
   	*L = (LinkList)malloc(sizeof(Node));
   	(*L)->next = NULL;                      /*  先建立一个带头结点的单链表 */
   	for (i=0; i<n; i++) 
   	{
   		p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */
   		p->data = rand()%100+1;             /*  随机生成100以内的数字 */
           // 将新插入的结点链接到之前结点的前面
   		p->next = (*L)->next;
           //由此判断一个链表的地址指向应该是头指针的指向
           // 是通过头指针往后插 
   		(*L)->next = p;						/*  插入到表头 */
	}
   }

   // Demo
CreateListHead(&L,20);
       printf("整体创建L的元素(头插法)：");
   //清空L后：ListLength(L)=0
   // 整体创建L的元素(头插法)：4 96 47 38 31 9 95 91 70 77 84 67 96 79 21 83 78 88 29 46
   ```
   
   ​	这段算法代码里，我们其实用的插队的方法，就是始终让新结点在第一的位置。我也可以把这种算法简称为头插法。这个算法主要是通过p->next = (*L)->next  将新创建结点与前一结点想链，并接到前一结点前面，通过 (*L)->next = p 将头结点与先加入结点相链
   
   ![头插法](https://s2.ax1x.com/2019/09/10/nUYV39.png)
   
   ​	但是我们通常是将新结点放到最后。我们吧每次新结点都插在终端结点的后面，这种算法称之为尾插法。
   

实现代码算法如下：

```c
*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */
void CreateListTail(LinkList *L, int n) 
{
	LinkList p,r;
	int i;
	srand(time(0));                      /* 初始化随机数种子 */
	*L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */
    // 现在应该没元素 所以是头指针 也是末尾 没毛病
	r=*L;                                /* r为指向尾部的结点 */
	for (i=0; i<n; i++) 
	{
		p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */
		p->data = rand()%100+1;           /*  随机生成100以内的数字 */
		r->next=p;                        /* 将表尾终端结点的指针指向新结点 */
        // 这是将r这个结点后移了
		r = p;                            /* 将当前的新结点定义为表尾终端结点 */
	}
	r->next = NULL;                       /* 表示当前链表结束 */
}

<<<<<<< HEAD
   
=======

// Demo
i=ClearList(&L);
    printf("\n删除L后：ListLength(L)=%d\n",ListLength(L));
    CreateListTail(&L,20);
    printf("整体创建L的元素(尾插法)：");
    ListTraverse(L);
// 删除L后：ListLength(L)=0
// 整体创建L的元素(尾插法)：46 29 88 78 83 21 79 96 67 84 77 70 91 95 9 31 38 47 96 4

```

​		注意L与r的关系，L是指整个单链表，而r是指向尾结点的变量，r会随着循环不断变化结点(r->next=pr = p;),而L则是随着循环增长尾一个多结点的链表。

​	r->next = p 的意思是将刚才的表尾终端结点r的指针指向新结点p，将新创建的结点接到后面。

​	

![将新创建结点接到尾部结点的后面](http://yanxuan.nosdn.127.net/cfd37c9ffc79b7bcc22ecb7ee705066c.png)

​	而r->next=p可能不太好理解，ok，首先分析下执行完上面那条语句后的r p 关系，r现在不是最后一个了 p 才是，但是我们需要一直让r当最后一个，p又是每个循环新创建的东西，所以现在我们需要将r往后挪个窝，让r重新回到最后。这行代码就是这个目的了！

 

![将r重新定位到尾结点](http://yanxuan.nosdn.127.net/1391cbfbbd885a304dc92a50db0b0df5.png)

​	本来r是在ai-1元素的结点，可现在它已经不是最后的结点了，现在最后的结点是ai，所以应该让将p结点这个最后的结点赋值给r。此时r又是最终的尾结点了。

​	循环结束后，应该让这个节点的指针域为NULL，因此有 “r->next = NULL”,以便以后遍历时可以确认其是尾部。



## 单链表的整表删除

---

​	当我们不使用这个链表的时候，我们需要将它销毁，就是说白了释放内存空间。

​	单链表整表删除的算法思路如下:

	1. 声明一个结点p和q；
 	2. 将第一个结点复制给p;
 	3. 循环:
     - 将下一结点赋值给q;
     - 释放p;
     - 将q赋值给p;



实现代码算法如下:

```c
/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
Status ClearList(LinkList *L)
{ 
	LinkList p,q;
    // 如果 p = (*L) 则为一个头指针 (指向第一个结点)
	p=(*L)->next;           /*  p指向第一个结点 */
	while(p)                /*  没到表尾 */
	{
		q=p->next;
		free(p);
		p=q;
	}
	(*L)->next=NULL;        /* 头结点指针域为空 */
	return OK;
}
```

​	q变量是作为一个临时变量存放p的，因为当执行”free(p)“时，p的指针域中的地址也没了，其他就比较简单，循环后依旧让尾指针的指针域为NULL。



## 单链表结构与顺序存储结构优缺点

---

![对比](http://yanxuan.nosdn.127.net/b18c488abfb1c35050cffdb1a936e9c0.png)

结论:

- 若线性表需要频繁查找，很少进行插入和删除操作时，使用顺序存储结构。
- 若要频繁插入和删除时，使用单链表节后
- 当线性表中元素个数变化较大或根本不知道有多大时，最好用单链表结构。
- 事先知道线性表的大致长处，使用顺序存储结构。

##　循环链表

---

​	单链表由于每个结点只存储了向后的指针，到了尾标识就停止了向后链的操作，当中某一结点就无法找到它的前驱结点，不能返回。

​	将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

​	循环链表的出现解决了如果我们不是从头指针指向第一结点仍然能访问每一个结点。

​	为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，并不是说循环链表必须要头结点。

![](http://yanxuan.nosdn.127.net/fcee62ee89cd0dac30639410af14e522.png)

​	其实，循环链表和单链表的主要差异在于循环的判断条件上，原来是判断p->next是否为空，现在则是p->next不等于头结点，则循环为结束。

​	在单链表中，我们可以使用头结点，用O(1)的时间访问第一个节点，但对于要访问到最后一个结点，却需要O(n)时间，因为需要将链表全部扫描一遍。

​	我们通过指向终端结点的尾指针来循环链表，此时查找开始结点和终端结点都很方便。

![尾指针](https://s2.ax1x.com/2019/09/10/naKWod.png)

​	从s图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear->next->next，其复杂度也为O(1)。

​	当我们要将两个循环链表合并成一个表时，有了尾指针就非常简单了。下面两个循环链表，它们的尾指针分别是rearA和rearB。

![](https://s2.ax1x.com/2019/09/10/naKLwQ.png)

​	要想将它们合并，只需要如下操作。

![](/Users/yxm/Library/Application Support/typora-user-images/image-20190910230951228.png)

```c
p=rearA->next;  // 保存A表的头结点 即1
rearA->next=rearB->next->next; // 将本指向B表的第一个结点(不是头结点) 赋值给rearA->next 即2(头结点)
q=rearB->next;
rearB->next=p; //将原A表的头结点赋值给rearB->next 即3
free(q)  // 释放q
```

