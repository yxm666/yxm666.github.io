---
title: '''算法与数据结构-线性表'''
date: 2019-09-09 16:28:56
tags:
	- 算法与数据结构
categories:
	- 算法与数据结构
---

#　前言

---

>  线性表是零个或多个具有相同类型的数据元素的有限序列。主要分为：顺序存储结构、链式存储结构，在链式存储结构中又主要分为：单链表、静态链表、循环链表、双向链表

![线性表结构图](https://i.loli.net/2019/09/09/Diw7kV58EF9WhKU.png)



# 线性表

---

线性表(List):零个或多个数据元素的有限序列

序列：

- 元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有切只有一个前驱和后继。

![线性表的数学定义](https://i.loli.net/2019/09/09/2E1KdbwhgXHoNuS.png)

所以 线性表元素的个数n（n>=0）定义为线性表的长度。当n=0时，称为空表。

## 线性表的抽象数据类型

---

>在讲这个地方之前我想对抽象数据类型进行一个解释，因为之前也不理解抽象数据类型
>
>抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。抽象数据类型是与表示无关的数据类型，是一个数据模型及定义在该模型上的一组运算。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型。
>
>是不是感觉晦涩难懂，简单点，就是这个线性表应该具有哪样的操作

线性表的数据类型定义如下：

![](https://i.loli.net/2019/09/09/AwyXQltUBdoL2nb.png)

![](https://i.loli.net/2019/09/09/dgfFO85mj7pqNAE.png)

## 线性表的顺序存储结构

---

## 顺序存储定义

定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素

![线性表的顺序存储示意图](https://i.loli.net/2019/09/09/cnxCt1dWyEG7S2s.png)

## 顺序存储方式

  在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中

```c
#define MAXSIZE 20 /* 存储空间初始分配量 */

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */

typedef struct
{
	ElemType data[MAXSIZE];        /* 数组，存储数据元素 */
	int length;                    /* 线性表当前长度 */
}SqList;

```

描述顺序存储结构需要三个属性：

- 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。
- 线性表额最大存储容量：数组长度MaxSize。
- 线性表的当前长度：length

##　数组长度与线性表长度区别

​	数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。

​	线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。	

## 顺序存储结构的插入与删除

---

## 获取元素操作

---

```c
Status GetElem(SqList L,int i,ElemType *e)
{
    // 判断是否为空 或者数组下标越界
    if(L.length==0 || i<1 || i>L.length)
            return ERROR;
    *e=L.data[i-1];

    return OK;
}

//Demo 
/*
	因为只有传入指针才能对方法外变量的值做改变 故传入的是地址，
	首先定义一个 int 类型变量 e 然后将其地址传入(&e)
	此时e指向了结构体中数组所在下标的地址
	此时 方法外的变量e的值就进行了改变
*/
int main()
{
    SqList L;
    ElemType e;
   
    GetElem(L,5,&e);
    printf("第5个元素的值为：%d\n",e);
}
```

　##　插入操作

---

插入算法的思路：

- 如果插入位置不合理，抛出异常
- 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(创建一个新的数组，初始化长度加一，然后根据插入点，插入前复制原数组，插入后新数组下标加1)。
- 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。
- 将要插入元素填入位置i处。
- 表长加1

实现代码如下：

```c
/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(SqList *L,int i,ElemType e)
{ 
	int k;
	if (L->length==MAXSIZE)  /* 顺序线性表已经满 */
		return ERROR;
	if (i<1 || i>L->length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
		return ERROR;

	if (i<=L->length)        /* 若插入数据位置不在表尾 */
	{
        // 从后往前移动
		for(k=L->length-1;k>=i-1;k--)  /* 将要插入位置之后的数据元素向后移动一位 */
			L->data[k+1]=L->data[k];
	}
	L->data[i-1]=e;          /* 将新元素插入 */
	L->length++;

	return OK;
}

//demo
for(j=1;j<=5;j++)
            i=ListInsert(&L,1,j);
    printf("在L的表头依次插入1～5后：L.data=");
	//在L的表头依次插入1～5后：L.data=5 4 3 2 1
```



## 删除操作

---

删除算法的思路：

- 如果删除位置不合理，抛出异常
- 取出删除元素；
- 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
- 表长减1

实现代码如下：

```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(SqList *L,int i,ElemType *e) 
{ 
    int k;
    if (L->length==0)               /* 线性表为空 */
		return ERROR;
    if (i<1 || i>L->length)         /* 删除位置不正确 */
        return ERROR;
    *e=L->data[i-1];
    if (i<L->length)                /* 如果删除不是最后位置 */
    {
        for(k=i;k<L->length;k++)/* 将删除位置后继元素前移 */
			L->data[k-1]=L->data[k];
    }
    L->length--;
    return OK;
}

//demo
 k=ListLength(L); /* k为表长 */
    for(j=k+1;j>=k;j--)
    {
            i=ListDelete(&L,j,&e); /* 删除第j个数据 */
            if(i==ERROR)
                    printf("删除第%d个数据失败\n",j);
            else
                    printf("删除第%d个的元素值为：%d\n",j,e);
    }
```



## 线性表顺序存储结构的优缺点

---



![优缺点](http://yanxuan.nosdn.127.net/9eb30a08ef7bfddc3c734d3475833d7c.png)







# 线性表的链式存储结构

---

## 线性表链式存储结构定义

---

​	线性表的链式存储结构的特点是用一组<u>任意</u>的存储单元存储线性表的存储元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些存储元素可以存在内存未被占用的任意位置。

![链式存储结构](http://yanxuan.nosdn.127.net/59b6e49d78d061ed0d3a00867070b68c.png)

​	在以前的顺序结构中，数据元素只需要存储数据元素信息就ok了，因为它们的地址是连续的，跟着地址找，一个连着一个，而链式存储结构中，除了要存储数据元素信息外，还要存储它的后续元素的存储地址。

​	因此，为了表示每个数据元素ai与其直接后续数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后续的信息(即直接后续的存储位置)。

​	存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。指针域中存储的信息呗称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。

​	n个结点（ai的存储映像）链结成一个链表，即为线性表(a1,a2.....an)的链式存储结构，因为此链表中的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。

![链式存储结构示意图](http://yanxuan.nosdn.127.net/581fc16cbaf35869f4f9317bb9a819ec.png)

- 链表中第一个结点的存储位置叫做头指针
- 线性链表中的最后一个结点指针为NULL("^")

![原图有错误](http://yanxuan.nosdn.127.net/02aa31ccd2651e4704bdf610dfb51f9f.png)

(注：头指针是指向第一个结点的 而不是第一个结点的指针域，说白了 头指针是第一个结点的地址)

​	有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点称为头结点，头结点的数据域可以不存储任何信息，头结点的指针域存储指向第一个结点的指针(就是头指针)。

![](http://yanxuan.nosdn.127.net/552e2bbe034fe13d2b5118829b281893.png)

## 头指针与头结点的异同

![异同](http://yanxuan.nosdn.127.net/82a72e174f28a9b9707dac5ee359785a.png)

​	我个人认为带有头结点的单链表图好像其中头指针的位置画错了，不敢确认，按照定义与理解，头指针应该是排除再链表外的东西(个人理解)，经过请教佩哥，佩哥牛鼻！！！！！，佩哥肯定了我的想法，爱他！！！，可以查看相关文章。

(相关文章)[https://blog.csdn.net/weixin_41413441/article/details/79063738]

## 线性表链式存储结构代码描述

---



![不带头结点的单链表](http://yanxuan.nosdn.127.net/b9a8b219dcfe85bd6e924d339274c95a.png)

![](http://yanxuan.nosdn.127.net/5d2fc6d07ae72fd62e1aed7dde0d25bf.png)

![](http://yanxuan.nosdn.127.net/504853f74a73204cfbe582412d49046b.png)

在单链表中，我们在C语言中可用结构指针来描述

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

#define MAXSIZE 20 /* 存储空间初始分配量 */

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */

typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList; /* 定义LinkList */
```

​	结点由存放数据元素的数据域和存放后续结点地址的指针域组成。假设 p 是指针域指向线性表第i个元素的指针(ai-1的指针域说白了)，则该结点ai的数据域我们可以用p->data表示，p->data的值是一个数据元素，结点ai的指针域可以用p->next来表示，p->next的值是一个指针。p->next指向第i+1个元素，即指向ai+1的指针。

​	如果p->data=ai,那么p->next->data=ai+1。

![](http://yanxuan.nosdn.127.net/4b90a93b3b685d5d8da52771011e44ff.png)

