---
title: 递归
date: 2019-11-04 12:32:15
tags:
	- 算法与数据结构
categories:
	- 算法与数据结构
---

# **前言**

  **递归是一种依靠Java语言特性的一种栈操作，因为在Java中，方法被下压入栈 然后再被取出，只要理解了栈的先进后出原理，觉得理解递归并不是很难。**

# **递归**

## **递归的应用场景**

**迷宫问题(回溯)、递归(Recursion)**

**![递归](https://tva1.sinaimg.cn/large/006y8mN6ly1g8lwkmfzmnj30io0hqwi4.jpg)**

## **递归的概念**

**简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时**
**可以让代码变得简洁。**

## **递归调用机制**

**1) 打印问题**
**2) 阶乘问题**
**3) 使用图解方式说明了递归的调用机制**

**![递归调用机制](https://tva1.sinaimg.cn/large/006y8mN6ly1g8lwmsjq8lj31b60msat6.jpg)**

**个人理解:**

- **当main线程进行时，会在栈中下压一个main线程，main中调用了test(4)方法，test(4)方法进行下压入栈、之后依次为test(3)、test2，此时调用完成 再从test(2)进行执行方法体直到结束，此时test(2)应为出栈，依次再将test(3)、test(4)、main出栈，此时，程序结束。**
- **当传入的参数为基础对象,只会进行值传递，变量不传递，当传递为数组等引用变量，则会类似于C中的指针传递。**

## **代码演示**

```java
package com.atguigu.recursion; public class RecursionTest {
public static void main(String[] args) {
// TODO Auto-generated method stub //通过打印问题，回顾递归调用机制 //test(4);
int res = factorial(3);
System.out.println("res=" + res); }
//打印问题.
  public static void test(int n) { if (n > 2) {
test(n - 1); } //else {
System.out.println("n=" + n); // }
}
//阶乘问题
public static int factorial(int n) {
if (n == 1) { return 1;
} else {
return factorial(n - 1) * n; // 1 * 2 * 3
} }
}
```

## **递归能解决什么样的问题**

**递归用于解决什么样的问题**
**1) 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 2) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.**
**3) 将用栈解决的问题-->第归代码比较简洁**

## **递归需要遵守的重要规则**

**递归需要遵守的重要规则**
**1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)**
**2) 方法的局部变量是独立的，不会相互影响,比如n变量**
**3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.**
**4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)**
**5) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕**

# **迷宫问题 代码实现**

```java
package cn.cxjd.recursion;

/**
 * 〈一句话功能简述〉<br>
 * 〈迷宫回溯问题〉
 *
 * @author yxm
 * @create 2019-11-04
 * @since 1.0.0
 */
public class MiGong {
    public static void main(String[] args) {
        // 创建一个二维数组 模拟迷宫
        // 地图
        int[][] map = new int[8][7];
        // 使用1表示墙
        // 上下全部设置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部设置为1
        for (int i = 1; i < 7; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        map[3][1] = 1;
        map[3][2] = 1;
        System.out.println("地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }


    /**
     * @Author: 远见卓识
     * @Description:
     * 1、 map表示地图
     * 2、 i j 表示从地图的哪个位置开始出发(1,1)
     * 3、如果小球能到map[6][5] 位置 则说明通路找到
     * 4、约定: 当map[i][j]为0表示该点没有走过 当为1表示为墙 2 表示通路可走 3 表示该店已经走过 但不走不通
     * 5、在走迷宫时，需要确定一个策略(方法) 下->右->上->左 如果该点走不通 再回溯
     * @Date: 2019-11-04
     * @Param map: 表示地图
     * @Param i: 从哪个位置开始找
     * @Param j:
     * @return: boolean 如果找到通路 就返回true 否则返回false
     **/

    public static boolean setWay(int[][] map, int i, int j) {
        if (map[6][5] == 2) {
            // 通路已经找到
            return true;
        } else {
            if (map[i][j] == 0) {
                //如果当前这个节点还没有走过
                // 按照策略： 下->右->上->左 走

                // 假定 该点是可以走通
                map[i][j] = 2;

                // 向下走
                if (setWay(map, i + 1, j)) {
                    return true;
                    // 向右走
                } else if (setWay(map, i, j + 1)) {
                    return true;
                    // 向上走
                } else if (setWay(map, i - 1, j)) {
                    return true;
                    // 向左走
                } else if (setWay(map, i, j - 1)) {
                    return true;
                } else {
                    // 说明该点是走不通 是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {
                // 如果map[i][j] != 0 可能是1 ， 2 ，3
                return false;
            }
        }
    }



}

```



## **对迷宫问题的讨论**

**1) 小球得到的路径，和程序员设置的找路策略有关即:找路的上下左右的顺序相关**
**2) 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 3) 测试回溯现象**
**4) 思考: 如何求出最短路径? 思路-》代码实现。**

---

# **递归-八皇后问题(回溯算法)**

## **八皇后问题介绍**

**八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出:在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。**

## **八皇后问题算法思路分析**

**1) 第一个皇后先放第一行第一列**
**2) 第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都**
**放完，找到一个合适**
**3) 继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确**
**解**
**4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，**
**全部得到.**
**5) 然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤**
**6) 示意图:**

**![八皇后问题算法思路分析](https://tva1.sinaimg.cn/large/006y8mN6ly1g8m4ktzzyyj30y60kgngm.jpg)**

### **说明**

**理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =**
**{0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列**

## 算法实现

```java
package cn.cxjd.recursion;

/**
 * 〈一句话功能简述〉<br>
 * 〈八皇后问题〉
 *
 * @author yxm
 * @create 2019-11-04
 * @since 1.0.0
 */
public class Queen8 {
    // 定义一个max表示共有多少个皇后
    int max = 8;
    // 定义数组 array 保存皇后位置的结果 比如 arr={0,4,7,5,2,6,1,3}
    int[] array = new int[max];
    static int count = 0;
    static int judgeCount = 0;

    public static void main(String[] args) {
      //测试一把 ， 8 皇后是否正确
			Queue8 queue8 = new Queue8();
			queue8.check(0);
			System.out.printf("一共有%d 解法", count); 
      System.out.printf("一共判断冲突的次数%d 次", judgeCount); // 1.5w

    }

    /**
     * @Author: 远见卓识
     * @Description: 编写一个方法 放置第n个皇后
     * @Date: 2019-11-04
     * @Param n: 放置第n个皇后
     * @return: void
     **/
// check 是 每依次递归时，进入到check中都有for(int i = 0;i<max; i++)

    private void check(int n) {
        // n = 8  n 从 0开始 表示已经放置到第9个皇后
        if (n == max) {
            print();
            return;
        }

        // 依次放入到皇后 并判断是否冲突
        for (int i = 0; i < max; i++) {
            // 先把当前这个皇后n，放到该行的第1列
            array[n] = i;
            //判断当前放置第n个皇后到第i列时 是否冲突
            // 不冲突
            if (judge(n)) {
                // 接着放n+1个皇后 即开始递归
                check(n + 1);
            }
            // 如果冲突 就继续执行 array[n] = i 即 将第n个皇后 放置在本行的的后移一个位置
        }

    }

    private void print() {
        // 只有每次将8个皇后都排序完成后 才调用print方法 所以用来累加次数
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "");
        }
        System.out.println();
    }

    /**
     * @Author: 远见卓识
     * @Description: 查看当我们放置第n个皇后 就去检测该皇后是否和前面已经摆放的皇后冲突
     * @Date: 2019-11-04
     * @Param n: 表示第n个皇后
     * @return: boolean
     **/

    private boolean judge(int n) {
        // 判断进行了多少次调用
        judgeCount++;
        for (int i = 0; i < n; i++) {
            /**
             * 1、 array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列
             * 2、 Math.abs(n - i) == Math.abs(array[n] - array[i]
             * 表示判断第n个皇后是否和第i个皇后是否在同一斜线 类似于求k 求45度的tan
             * 因为没一个n都在递增 所以没有必要判断统一化
             */
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }

}

```

个人理解:

- 主要算法部分在其中的check()方法上
- 看似没有进行回溯，但是每当8个皇后进行完毕后，会通过for循环将最后一个皇后位置遍历移动
- 当最后一个移动完后 会依次出栈，最终第一个位置也会移动
- 最后得到所有的结果