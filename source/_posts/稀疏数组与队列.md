---
title: 稀疏数组与队列
date: 2019-10-25 15:03:09
tags:	
	- 数据结构与算法
categories:
	- 数据结构与希望
---

# **前言**

​	好了，好久没有更新博客了，现在跟着韩顺平的数据结构学习，主要也是实验室太忙了，自己也有一些事，以后周更要坚持住。这次记录的是稀疏数组与队列，队列又分有普通队列与环形队列。



# 稀疏数组

---

## **适用情况**

  **在一些情况下，二维数组会有大部分的数据无用，比如没有意义的0，我们这时候可以使用稀疏数组进行存储该二维数组。**

## **处理方法**

- **记录数组一共有几行几列，有多少不同的值**
- **把具有不同值得元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模**

**![稀疏数组转换](https://s2.ax1x.com/2019/10/25/KddlNj.png)**

## **应用实例**

---

1. **使用稀疏数组，来保留类似的前面的二维数组(棋盘、地图)**
2. **把稀疏数组存盘，并且可以从新恢复原来的二维数组**

## **思路分析**

---

### **二维数组 转 稀疏数组的思路**

1. **遍历原始二维数组，得到有效的数据个数 sum (因为创建的稀疏数组的大小需要根据有效个数进行创建)**
2. **根据sum就可以创建洗漱漱 sparseArr int[sum + 1] [3]      (sum+1 是因为第一行需要存储原二维数组的行 列 有效个数 3 作为列数是存储有效元素的信息 前2个是用来存储原二维数组的 行 列 的信息 第三个是存储元素的值)**
3. **将二维数组的有效数据存入稀疏数组**

### 稀疏数组转原始的二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]
2. 在读取稀疏数组后几行的数据，并赋值给原始的二维数组

---

## 代码实现

```java
package cn.cxjd.sparseArray;

/**
 * 〈一句话功能简述〉<br>
 * 〈稀疏数组的实现〉
 *
 * @author yxm
 * @create 2019-10-23
 * @since 1.0.0
 */
/*当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
        稀疏数组的处理方法是:
        1) 记录数组一共有几行几列，有多少个不同的值
        2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模


1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
 2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
3) 整体思路分析
 */
public class SparseArray {
    public static void main(String[] args) {
        // 创建一个原始的二维数组11 * 11
        int[][] chessArr1 = new int[11][11];
        //设置其中不为0的值
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;

        // 先输出原始二维数组
        // 两次for循环 直接打印
        System.out.println("原始二维数组");
        for (int[] ints : chessArr1) {
            for (int i : ints) {
                System.out.printf("%d\t", i);
            }
            System.out.println();
        }
        // 将二维数组转换为细数数组
        // 1、先遍历二维数组 得到非0的 数据个数 用来为新创建
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                // 如果这个元素不为0 则sum++
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }

        // 创建对应的稀疏数组
        // ssum+1 第一行 依次存储 多少行 多少列  有多少个数不为0
        // 3 : 依次存储为 行号 列号 值
        int[][] sparseArr = new int[sum + 1][3];
        // 将稀疏数组的第一行 存入
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        //遍历二维数组，将非0的值存放到sparseArr中

        // count 用来记录获取的是第几个非0数据
        int count = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    //用来记录非0数据在二维数组中的位置
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    // 第3个值用来存值
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        //打印变换成功的稀疏数组
        System.out.println();
        System.out.println("细数数组为:-------");
        // 从第一行打印
        for (int i = 1; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }
        System.out.println();

        //在读取稀疏数组后几行的数据（从第二行开始),并赋值给原始的二维数组

        //现根据首行获取原始二维数组的情况
        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];

        //进行赋值 从第二行开始
        for (int i = 1; i < sparseArr.length; i++) {
            //将非0数据根据赋值给新的二维数组
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        //打印恢复后的二维数组
        System.out.println();
        System.out.println("恢复后的二维数组为:");
        for (int[] ints : chessArr2) {
            for (int anInt : ints) {
                System.out.printf("%d\t",anInt);
            }
            System.out.println();
        }
    }


}

```

---

# 队列

---

## 普通队列

---

### 队列介绍

1. 队列是一个有序列表，可以用数组或是链表来实现。
2. 遵循先入先出的原则。即:先存入队列的数据，要先取出。后存入的妖后取出。
3. 示意图![队列示意图](https://s2.ax1x.com/2019/10/25/KdIqsO.png)

### 数组模拟队列的思路

---

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量
- 因为队列的输出、输入分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后的下标, front会随着数据输出而改变，而 rear 则是随着和数据输入而改变，如图所示:

![队列示意图](https://s2.ax1x.com/2019/10/25/KdIqsO.png)

- 当我们将数据存入队列时成为"addQueue",addQueue的处理需要

思路分析:

1. 将尾指针后移: rear + 1 ，当 front == rear  表示队列为空
2. 若尾指针 rear 小于队列的最大下标 maxSize -1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。
3. rear == maxSize - 1           [队列满]

## 代码实现

```java
package cn.cxjd.Queues;

/**
 * 〈一句话功能简述〉<br>
 * 〈队列的实现〉
 *
 * @author yxm
 * @create 2019-10-23
 * @since 1.0.0
 */
/*
队列本身是有序列表，若使用数组的结构来存储队列的数据，
 其中 maxSize 是该队 列的最大容量。
 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量
front 及 rear 分别记录队列前后端的下标，
front 会随着数据输出而改变，而 rear 则是随着数据输入而改变
 */

public class Queue {
    public static void main(String[] args) {

    }

    class ArrarQucue {
        // 表示数组的最大容量
        private int maxSize;
        // 队列头
        private int front;
        // 队列尾
        private int rear;
        //该数据用于存放数据 模拟队列
        private int[] arr;

        public ArrarQucue(int maxSize) {
            this.maxSize = maxSize;
            arr = new int[maxSize];
            // 指向队列头部，分析出front是指向队列头的前一个位置
            front = -1;
            // 指向队列尾 指向队列尾的数据(就是队列最后一个数据)
            rear = -1;
        }

        //判断队列是否为满 因为是从0开始计数 所以需要maxSize-1
        public boolean isFull() {
            return rear == maxSize - 1;
        }

        //判断队列是否为空 当头跟尾巴想重 即满
        public boolean isEmpty() {
            return rear == front;
        }

        // 添加数据到队列
        public void addQueuc(int n) {
            // 判断是否为满
            if (this.isFull()) {
                System.out.println("队列满，不能加入数据");
                return;
            }
            // 指向队列尾 初始值为-1 需要先加再 再存
            rear++;
            arr[rear] = n;
        }

        // 获取队列的数据，出队列
        public int getQeue() {
            //判断队列是否为空
            if (this.isEmpty()) {
                // 通过抛出异常
                throw new RuntimeException("队列为空 不能添加数据");
            }
            // front  后移 因为指向前一位 先++ 再获取
            front++;
            return arr[front];
        }

        //显示队列的所有数据
        public void showQueue() {
            //遍历
            if (this.isEmpty()) {
                System.out.println("队列尾空 无数据");
                return;
            }
            for (int i = 0; i < arr.length; i++) {
                System.out.printf("arr[%d]=%d\n", arr[i]);
            }
        }

        //显示队列的头数据，注意不是取出数据
        public int headQueue() {
            //判断是否为空
            if (this.isEmpty()) {
                throw new RuntimeException("队列为空 没有数据");
            }
            return arr[front + 1];
        }


    }
}

```

# 环形队列

---

​	对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的结构。(通过去模的方式来实现)

## 分析说明

1. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意(rear + 1)% maxSize == front (满)
2. rear == font (空)
3. 示意图![UTOOLS1572319307171.png](https://img03.sogoucdn.com/app/a/100520146/5ee6717cf7bf5573402330bd2561d906):![环形队列示意图](https://user-gold-cdn.xitu.io/2019/10/25/16e021cfabedfc73?w=942&h=358&f=png&s=126501)



## 思路如下

1. front变量的含义进行调整:front就指向队列的第一个元素，也就是一说arr[front] 就是队列的第一个元素 front 的初始值为0
2. Rear 变量的含义进行调整:rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值为0
3. 当队列为满时，条件是(rear+1)%maxSzie = front     [满]
4. 队列尾空的条件， rear == front [空]
5. 当这样定义时候，队列中有效的数据个数为: (rear + maxSize - front)%maxSize   

```java
package cn.cxjd.Queues;

/**
 * 〈一句话功能简述〉<br>
 * 〈数组实现环形队列〉
 *
 * @author yxm
 * @create 2019-10-24
 * @since 1.0.0
 */
/*
对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)
分析说明:
1) 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的
时候需要注意 (rear + 1) % maxSize == front 满]
2) rear == front [空]
判断有效个数 : (rear + maxSize)%maxSize
 */

public class CircleArrayQueue {
    // 表示数组的最大容量
    private int maxSize;
    // front 指向队列的第一个元素 arr[front]表示为队列的第一个元素
    private int front;
    // rear指向队列的最后一个元素的后一个位置 因为喜欢空出一个空间做约定
    private int rear;
    // 该数据用于存放数据 模拟队列
    private int[] arr;


    public CircleArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
    }

    // 判断杜烈是否为满
    public boolean isFull() {
        // 先进行后移 并取余 如果等于 front 则表示满 因为约定进行一个空间的空余
        return (rear + 1) % maxSize == front;
    }

    // 判断是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n) {
        // 先判断队列是否为满
        if (this.isFull()) {
            System.out.println("队列满 无法添加数据");
            return;
        }
        // 因为rear指向的是最后一个元素的后一个位置 故直接进行添加操作
        arr[rear] = n;
        //因为之前已经判断了是否为满 所以这里将rear后移没有问题 需要考虑到取余
    }

    // 获取队列的数据 出队列
    public int getQueue() {
        // 判断队列是否为空
        if (this.isEmpty()) {
            throw new RuntimeException("队列空 不能取数据");
        }
        // front是指向队列的第一个元素
        // 1、 首先把front对应的值保存到一个临时变量中
        // 2、 再将front后移 考虑取模
        // 返回之前保存的临时变量

        int value = arr[front];
        front = (front + 1) / maxSize;
        return value;
    }

    // 显示队列的所有的数据
    public void showQueue() {
        // 先看判断空
        if (this.isEmpty()) {
            System.out.println("队列为空 没有数据");
            return;
        }
        // 思路: 从 front 开始遍历 遍历 有效个数个元素
        for (int i = front; i < front + this.size(); i++) {
            // 尽管是环形队列 下标索引还是不变的 所以 还需要进行去模得到正确的值
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 求出当前队列有效数据的个数
    public int size() {
        return (rear + maxSize - front) % maxSize;
    }

    // 显示队列的头数据 注意不是取出
    public int headQueue() {
        //判断是否为空
        if (this.isEmpty()) {
            throw new RuntimeException("队列为空 没有数据");
        }
        return arr[front];
    }




}

```







## 





