---
title: 链表
date: 2019-10-28 22:55:07
tags:
	- 数据结构与算法
Categories:
	- 数据结构与算法
---

# 前言

---

​	高产似母猪，我又来更新我的博客，今天学了链表呢，说实话还是有点绕呢，现在开始吧，奥利给！！！！

# 链表

---

## 链表简介

​	单链表是有序的列表，但地址不一定是相连的。

![单链表](https://i.loli.net/2019/10/29/uI8RZ2gjXKfEH93.png)
小结:

1) 链表是以节点的方式来存储,是链式存储
2) 每个节点包含 data 域， next 域:指向下一个节点.
3) 如图:发现链表的各个节点不一定是连续存储.
4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 

单链表(带头结点) 逻辑结构示意图如下

![K2aMon.png](https://s2.ax1x.com/2019/10/29/K2aMon.png)



## 单链表的应用实例

​	使用带head头的单向链表实现 - 水浒英雄排行榜管理完成对英雄人物的增删改查操作。

1、 第一种方法在在添加英雄时，直接添加到链表的尾部

![UTOOLS1572316011049.png](https://img03.sogoucdn.com/app/a/100520146/04fbfa8e22c6c8f41e2996f58183b896)

2、 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)

思路的分析示意图:

![UTOOLS1572316059149.png](https://img01.sogoucdn.com/app/a/100520146/f4ac2dfdf55b7aa6479747d59565c5cf)

3、 1）先找到该节点，通过遍历 2)temp.name = newHeroNode.name;temp.nickname = newHeroNode.nickname

4、 删除结点2

思路分析的示意图:

![UTOOLS1572316090993.png](https://img03.sogoucdn.com/app/a/100520146/3f353cea89860a90a9fbac3a6f78ec64)

## 代码实现

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈HeroNode 作为链表的一个节点〉
 *
 * @author yxm
 * @create 2019-10-26
 * @since 1.0.0
 */
public class HeroNode {
    // 序号
    public int no;
    // 英雄名称
    public String name;
    // 英雄昵称
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈链表的实现〉
 *
 * @author yxm
 * @create 2019-10-26
 * @since 1.0.0
 *
 * 1) 链表是以节点的方式来存储,是链式存储
 * 2) 每个节点包含 data 域， next 域:指向下一个节点.
 * 3) 如图:发现链表的各个节点不一定是连续存储.
 * 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
 */
public class LinkedList {
    // 先初始化一个头结点 头结点不要动 不存放具体的数据
    private HeroNode head = new HeroNode(0, "", "");

    //添加节点到单向链表
    /*
    1、 找到当前链表的最后节点
    2、 将最后这个节点的next指向新的节点
     */

    public void add(HeroNode heroNode) {
        // 因为head 作为头结点 不能移动 因此我们需要一个辅助指针遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后 如果后续指针不为空 则继续遍历
        while (temp.next != null) {
            // 将temp后移
            temp = temp.next;
        }

        // 当退出while 循环时， temp就指向了链表的最后
        // 此时 将要加入的结点放入到temp的 next域 中
        temp.next = heroNode;
    }

    // 第二种方法在添加英雄时，根据英雄的排名将英雄插入到指定位置 如果有这个排名则显示添加失败 并给出提示
    public void addbyOrder(HeroNode heroNode) {
        // 因为头节点不能动，因此我们让然通过一个辅助指针来找到添加的位置
        // 因为单链表 我们找的temp是位于添加位置前的一个节点 否则插入不了
        // 添加节点 兴许一个节点都没 所以不需要后移
        HeroNode temp = head;
        // flag标志添加的标志是否存在 默认为false
        boolean flag = false;

        while (temp.next != null) {
            // 位置摘到 就在 temp的后面
            if (temp.next.no > heroNode.no) {
                break;
                // 说明希望添加的hearNode 的编号已经存在
            } else if (temp.next.no == heroNode.no) {
                flag = true;
                break;
            }
            // 后移 遍历当前链表
            temp = temp.next;
        }

        // 判断flag的值
        if (flag) {
            // 表明 改heroNode的 No已经存在无法添加
            System.out.printf("准备插入的英雄编号%d 已经存在了 不能加入\n", heroNode.no);
        } else {
            // 插插入到链表中,temp 的后面 注意插入的顺序
            // 插入等操作先不动 temp 先动 插入的元素 将heroNode 放到 temp的 next 现在有两个元素在 temp的后面
            heroNode.next = temp.next;
            // 现在在切断 temp与原本的后面的元素的联系
            temp.next = heroNode;
        }
    }

    // 修改结点的信息，根据no编号来修改 no不能做修改
    // 根据newHeroNode 的 no来修改
    public void update(HeroNode newHeroNode) {
        // 判断是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的结点 根据 no编号

        // 定义一个辅助变量
        HeroNode temp = head.next;
        // 表示是否找到了该结点
        boolean flag = false;
        while (temp != null) {
            if (temp.no == newHeroNode.no) {
                // 找到 改变标志
                flag = true;
                break;
            }
            temp = temp.next;
        }

        // 根据 flag 判断是否找到要修改的节点
        if (flag) {
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else {
            System.out.printf("没有找到 编号%d 的节点，不能修改", newHeroNode.no);
        }
    }

    //删除节点
    /*
    1、 head不能动 因此我们需要一个temp辅助节点找到待删除节点的前一个节点
    2、 说明我们在比较时 是 temp.next.no 与 需要删除的节点的no进行比较
     */

    public void del(int no) {
        HeroNode temp = head;
        //标志是否找到待删除的节点
        boolean flag = false;

        while (temp.next == null) {
            if (temp.next.no == no) {
                // 找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            //  temp后移
            temp = temp.next;
        }

        if (flag) {
            // 找到 可以删除
            temp.next = temp.next.next;
        } else {
            System.out.printf("要删除的 %d 节点不存在\n",no);
        }
    }

    // 显示链表
    public void list() {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }

        // 因为头结点不能动 因此我们需要一个辅助节点进行遍历
        HeroNode temp = head.next;
        while (temp != null) {
            // 输出节点信息
            System.out.println(temp);
            temp = temp.next;
        }
    }


}

```

## 单链表面试题

### 去单链表中有效节点的个数

```java
// 求单链表中有效结点的个数


    // 方法: 获取单链表的节点的个数(如果是带头结点的链表，需要不统计头结点)
    public static int getLength(HeroNode head) {
        // 空链表
        if (head.next == null) {
            return 0;
        }
        int length = 0;
        //  定义一个辅助变量 这里没有统计头结点
        HeroNode cur = head.next;
        while (cur != null) {
            length++;
            // 将cur向后移
            cur = cur.next;
        }
        return length;
    }
```

### 查找单链表中的倒数第K个结点

```java
/ 查找单链表中的倒数第K个结点

    /*
    1、 编写一个方法 接受 head 节点 同时接受一个index
    2、 index 表示倒数第index 个节点
    3、 先把链表从头到尾遍历 得到链表的总长度 getLength
    4、 得到size后 我们从链表的第一个开始遍历(size-index)个 就可以得到
    5、 如果找到了，则返回该结点，否则返回null
     */

    public static HeroNode findLastIndexNode(HeroNode head, int index) {
        // 如果链表为空 返回null
        if (head.next == null) {
            return null;
        }
        // 第一个遍历得到链表的长度(节点个数)
        int size = getLength(head);
        // 第二次遍历 size-index 位置 就是我们倒数的第K个节点
        // 先做一个index的校验
        if (index <= 0 || index > size) {
            return null;
        }
        // 定义辅助遍历 for循环定位到倒数的index
        HeroNode cur = head.next;
        for (int i = 0; i < size - index; i++) {
            cur = cur.next;
        }
        return cur;
    }
```

### 单链表的反转

![UTOOLS1572316191334.png](https://img04.sogoucdn.com/app/a/100520146/f05ac9175cd5fe51e7931f9b278e82ac)

![UTOOLS1572316217618.png](https://img03.sogoucdn.com/app/a/100520146/174d350bc6a280369e2d714cabc87290)

```java
//单链表的反转

    /*
    1、 先定义一个节点 reverHead = new HeroNode()
    2、 从头到尾遍历原来的链表 每遍历一个节点 就将其取出 并放出在新的链表reverse的最前端
    3、 原来的链表的head.next = reversehead.next
     */

    public static void reverseList(HeroNode head) {
        // 如果当前链表为空 或者只有一个节点 无需反转 直接返回
        if (head.next == null || head.next.next == null) {
            return;
        }

        // 定义一个辅助指针 帮助我们遍历原来的链表
        HeroNode cur = head.next;
        // 指向当前节点[cur]的下一个节点
        HeroNode next = null;
        HeroNode reverseHead = new HeroNode(0, "", "");
        // 遍历原来的链表 每遍历一个节点 就将其取出 并放在新的链表 reverseHead 的最前端
        while (cur != null) {
            // 先暂时保存当前节点的下一节点 因为后面需要
            next = cur.next;
            // 将cur的下一个节点指向新的链表的最前端
            cur.next = reverseHead.next;
            // 将 cur 连接到新的链表上
            reverseHead.next = cur;
            // 让cur后移
            cur = next;
        }

        // 将head.next 指向 reverseHead.next 实现单链表的反转
        head.next = reverseHead.next;
    }
```

## 从尾到头打印链表

思路分析图解

![UTOOLS1572316234793.png](https://img04.sogoucdn.com/app/a/100520146/cf899701b30ff332705786ada547df8e)

```java
package cn.cxjd.LinkedList;

import java.util.Stack;

/**
 * 〈一句话功能简述〉<br>
 * 〈栈的模拟实现〉
 *
 * @author yxm
 * @create 2019-10-27
 * @since 1.0.0
 */
public class StackTest {
    public static void main(String[] args) {

    }
    // 利用栈这种数据结构 将各个节点压入到栈中 然后利用栈的先进后出的特点 实现了逆序打印的效果

    public static void reversePrint(HeroNode head) {
        if (head.next == null) {
            // 空链表 不能打印
            return;
        }

        // 创建要给一个栈 将各个节点压入栈
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur = head.next;

        // 将链表的所有节点压入栈
        while (cur != null) {
            stack.push(cur);
            // 后移 这样就可以压入下一个节点
            cur = cur.next;
        }

        // 将栈中的节点打印 pop 出栈
        while (stack.size() > 0) {
            // stack 的特点是先进后出
            System.out.println(stack.pop());
        }
    }

}

```

---

# 双向链表的操作分析和实现

​	使用带head头的双向链表实现 -水浒英雄传

管理单向链表的缺点分析:

1. 单向链表，查找打方向只能是一个方向，而双向链表可以向前或者向后查找
2. 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，宗师找到temp,temp是待删除节点的前一个节点
3. 分析了双向链表如何完成遍历，添加，修改和删除的思路

![UTOOLS1572316249848.png](https://img03.sogoucdn.com/app/a/100520146/0f7df60edcf4484d1fd71a0172c4429e)

对上图的说明:

1. 遍历 和单链表一样，只是可以向前 也可以向后查找
2. 添加(默认添加到双向链表的最后)
   1. 先找到双向链表的最后这个节点(通过辅助指针循环遍历 此时temp 指向最后一个节点)
   2. temp.next = newHeroNode
   3. newHeroNode.pre = temp
3. 修改 思路和原来的单向链表一样
4. 删除
   1. 因为是双向链表 因此我们可以实现自我删除某个节点
   2. 直接从要删除的这个节点，比如 temp
   3. temp.pre.next = temp.next    (将temp的前一个节点的后指针指向temp的下一个)
   4. temp.next.pre = temp.pre （temp的下一个节点的前指针指向temp的前一个节点）

### 代码实现

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈双向链表〉
 *
 * @author yxm
 * @create 2019-10-27
 * @since 1.0.0
 */
public class DoubleLinkList {

    // 先初始化一个头结点 头结点不要动 不存放具体数据
    private HeroNode2 head = new HeroNode2(0, "", "");

    // 返回头结点
    public HeroNode2 getHead() {
        return head;
    }

    // 遍历双向链表的方法
    // 显示链表
    public void list() {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }

        // 因为头结点 不能动 因此需要一个辅助变量来遍历
        HeroNode2 temp = head.next;
        while (temp != null) {
            System.out.println(temp);
            // 将temp 后移
            temp = temp.next;
        }
    }

    // 添加一个节点到双向链表的最后
    public void add(HeroNode2 heroNode) {
        // 因为head节点不能动 因此我们需要一个辅助节点temp 遍历
        HeroNode2 temp = head;
        // 遍历链表 找到最后
        while (temp.next != null) {
            temp = temp.next;
        }
        // 当退出while循环时 temp就指向了链表的最后

        // 形成一个双向链表
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    // 修改一个节点的内容 可以看大佬双向链表的节点内容修改和单向链表一样
    // 只是 节点类型换成 HeroNode2
    public void update(HeroNode2 newHeroNode) {
        //判断是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点 根据no编号
        // 定义一个辅助变量
        HeroNode2 temp = head.next;
        // 判断是否找到该节点
        boolean flag = false;
        while (temp != null) {
            if (temp.no == newHeroNode.no) {
                // 找到该节点
                flag = true;
                break;
            }
            temp = temp.next;
        }

        // 根据 flag 判断是否找到要修改的节点
        if (flag) {
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else {
            //没有找到
            System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);

        }
    }

    // 从双向链表中删除一个节点
    // 说明
    // 1、 对于双向链表 我们可以直接找到要删除的这个节点
    // 2、 找到后 自我删除即可
    public void del(int no) {
        if (head.next == null) {
            // 判断当前链表是否为空
            System.out.println("链表为空 无法删除");
            return;
        }

        // 辅助变量
        HeroNode2 temp = head.next;
        // 标志是否找到待删除的节点
        boolean flag = false;
        while (temp != null) {
            if (temp.no==no) {
                // 找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            temp = temp.next;
        }

        // 判断flag
        if (flag) {
            // 找到 可以删除
            // 单向链表 temp.next = temp.next.next
            // 前一个节点后一个节点指向 当前节点的后一个节点
            temp.pre.next = temp.next;
            // 如果是最后一个则不需要对后一个节点的前指针进行设置 否则会出现空指针异常
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.printf("要删除的%d 节点不存在\n", no);
        }
    }


}

```

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈双向链表的节点类〉
 *
 * @author yxm
 * @create 2019-10-27
 * @since 1.0.0
 */
public class HeroNode2 {
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点 默认为null
    public HeroNode2 next;
    // 指向前一个节点 默认为null
    public HeroNode2 pre;

    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```



测试双向链表:

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈双向链表测试〉
 *
 * @author yxm
 * @create 2019-10-28
 * @since 1.0.0
 */
public class DoubleLinkListTest {
    public static void main(String[] args) {
        System.out.println("测试");

        // 添加节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");

        // 创建一个双向链表
        DoubleLinkList doubleLinkList = new DoubleLinkList();
        doubleLinkList.add(hero1);
        doubleLinkList.add(hero2);
        doubleLinkList.add(hero3);
        doubleLinkList.add(hero4);

        doubleLinkList.list();

        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkList.update(newHeroNode);
        System.out.println("修改后");
        doubleLinkList.list();

        doubleLinkList.del(4);
        System.out.println("删除后");
        doubleLinkList.list();

    }

}

```

# 单向环形链表 应用场景

## Josephu(约瑟夫、约瑟夫环)问题

Josephu 问题为:设编号为 1，2，... n 的 n 个人围坐一圈，约定编号为 k(1<=k<=n)的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。
提示:用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。

## 单向环形链表介绍

![UTOOLS1572316270875.png](https://img01.sogoucdn.com/app/a/100520146/fc0c453a6b1453b54b5a0f6e0ada28e8)

## Josephu 问题

示意图:

![UTOOLS1572316290901.png](https://img03.sogoucdn.com/app/a/100520146/1904bfbf409e0ede9d839cd975332280)

Josephu 问题为:

​	设编号为 1，2，... n 的 n 个人围坐一圈，约定编号为 k(1<=k<=n)的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。

提示:

用一个不带头结点的循环链表来处理 Josephu 问题:先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

创建环形链表的思路图解

![UTOOLS1572316311586.png](https://img04.sogoucdn.com/app/a/100520146/b79fe6134efe08d441d4f2330fbd442d)

约瑟夫问题-小孩出圈的思路分析图

![UTOOLS1572316328460.png](https://img02.sogoucdn.com/app/a/100520146/39cf5231a65fc9c1cbba30f8b622094e)

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈约瑟夫问题 单向环形链表〉
 *
 * @author yxm
 * @create 2019-10-28
 * @since 1.0.0
 */
public class Josephu {
    public static void main(String[] args) {
        //  测试一把 看看构建环形链表 遍历是否Ok
        Josephu josephu = new Josephu();
        josephu.addBoy(5);
        josephu.showBoy();
    }

    // 创建first 节点 当前没有编号
    private Boy first = null;

    public void addBoy(int nums) {
        if (nums < 1) {
            System.out.println("num的值不正确");
            return;
        }
        // 创建辅助指针 帮助构建环形链表
        Boy curBoy = null;
        // 使用for循环创建我们的链表
        for (int i = 0; i < nums; i++) {
            // 根据编号创建小孩节点
            Boy boy = new Boy(i);
            // 如果是第一个小孩
            if (i == 0) {
                first = boy;
                // 构成环
                first.setNext(first);
                // 让curBoy指向第一个小孩
                curBoy = first;
            } else {
                // 如果不是第一个小孩
                // 将新增的节点填入环形链表
                curBoy.setNext(boy);
                // 将环重新连接起来
                boy.setNext(first);
                // 辅助变量后移
                curBoy = boy;
            }
        }
    }

    // 遍历当前环形链表
    public void showBoy() {
        // 判断链表是否为空
        if (first == null) {
            System.out.println("链表为空");
            return;
        }
        // 因为first 不能动 因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy = first;
        while (true) {
            System.out.printf("小孩的编号为%d\n", curBoy.getNo());
            // 说明已经遍历完毕
            if (curBoy.getNext() == first) {
                break;
            }
            // curBoy 后移
            curBoy = curBoy.getNext();
        }
    }

    // 根据用户的输入 计算出小孩出圈的顺序
    /*
    @param : starNo 表示从第几个小孩开始数
    @ param : countNum 表示数几下
    @param: nims 表示最初由多少个小孩在圈中
     */

    public void countBoy(int startNo, int countNum, int nums) {
        if (first == null || startNo < 1 || startNo > nums) {
            System.out.println("参数输入有误");
            return;
        }
        // 创建要给辅助指针，帮助小孩出圈
        Boy helper = first;
        // 将helper 指向最后一个节点
        while (helper.getNext() != null) {
            helper = helper.getNext();
        }
        // 小孩报数前 先让first 和 helper 移动 k-1次
        for (int i = 0; i < startNo - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        // 当小孩报数时 让first 和 helper 指针同时的移动 m-1次 然后出圈
        while (helper != first) {
            // 让 first 和 helper 指针同时移动 countNum-1
            for (int i = 0; i < countNum - 1; i++) {
                // 将 first 与 helper 后移 移动后的first节点即为要出圈的小孩
                first = first.getNext();
                helper = helper.getNext();
            }
            // 这时 first 指向的节点 就是要出圈的小孩节点
            System.out.printf("小孩%d出圈\n", first.getNo());
            // 这时将first指向的小孩节点出圈
            // first后移 helper 在一定意义上是前一个 将他的后指针指向移动后的first
            first = first.getNext();
            helper.setNext(first);

        }
        System.out.printf("最后留在圈中的小孩编号为%d\n", first.getNo());
    }


}


```

```java
package cn.cxjd.LinkedList;

/**
 * 〈一句话功能简述〉<br>
 * 〈Boy类 作为单向环形链表的一个节点〉
 *
 * @author yxm
 * @create 2019-10-28
 * @since 1.0.0
 */
public class Boy {
    // 编号
    private int no;
    // 指向下一个节点 默认为null
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }
}

```

