---
title: 栈
date: 2019-11-03 10:32:21
tags:
	- 算法与数据结构
categories:
	- 算法与数据结构

---

# **前言**

**栈确实学了半天，倒不是栈难，是各种计算器听起来头比较大，所以，今天梳理下好了。**

---

# **栈的介绍**

**1) 栈的英文为(stack)**
**2) 栈是一个先入后出(FILO-FirstInLastOut)的有序列表。**
**3) 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的**
**一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。**
**4) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元**
**素最先删除，最先放入的元素最后删除**
**5) 图解方式说明出栈(pop)和入栈(push)的概念**

**![出栈与入栈示意图](https://tva1.sinaimg.cn/large/006y8mN6ly1g8kodokt0nj31g80b2dlt.jpg)**

## **栈的应用场景**

**1) 子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以 回到原来的程序中。**
**2) 处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆 栈中。**
**3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。**
**4) 二叉树的遍历。**
**5) 图形的深度优先(depth一first)搜索法。**

## 栈的快速入门

1) 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。
2) 实现思路分析,并画出示意图

![数组模拟示意图](https://tva1.sinaimg.cn/large/006y8mN6ly1g8kofvtluhj31420fkahg.jpg)

一点解释:

- 栈为先入后出 通过一个指针来进行遍历
- 入栈的时候 先将栈顶上移再填入元素
- 出栈操作时需要返回出栈元素 所以需要一个临时变量记录元素 再将栈顶下移

## 代码实现

```java
package cn.cxjd.stack;

/**
 * 〈一句话功能简述〉<br>
 * 〈数组模拟栈结构〉
 *
 * @author yxm
 * @create 2019-10-29
 * @since 1.0.0
 */
public class ArrayStack {
    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        this.stack = new int[maxSize];
    }

    // 判断栈是否为满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    // 判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int value) {
        // 先判断栈是否满
        if (this.isFull()) {
            System.out.println("栈满");
            return;
        }
        stack[++top] = value;
    }

    // 出栈 -pop
    public int pop() {
        if (this.isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        return stack[top--];
    }

    // 遍历栈
    public void list() {
        //  判断是否为空
        if (this.isEmpty()) {
            System.out.println("没有数据");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }
}

```

# 栈实现综合计算器(中缀表达式)

![中缀表达式实现图](https://tva1.sinaimg.cn/large/006y8mN6ly1g8konhkvjjj31cq0k4k8c.jpg)

思路:

	- 如果是一个数字，则进行入数字栈的操作
 - 如果是一个符号栈:
   	- 如果栈为空 就直接入栈
    - 如果符号栈有操作符 进行比较 :
      	- 如果当前操作符的优先级小于或等于栈中的操作符 从数栈中POP出两个数 再从符号栈中pop出一个符号 进行运算 将得到的结果入数栈 将当前的操作符入符号栈 
      	- 如果当前的操作符的优先级大于栈中的操作符 就直接入符号栈

- 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
- 最后在数栈只有一个数字，就是表达式的结果

```java
package com.atguigu.stack; public class Calculator {
public static void main(String[] args) { //根据前面老师思路，完成表达式的运算
String expression = "7*2*2-5+1-5+3-4"; // 15//如何处理多位数的问题? //创建两个栈，数栈，一个符号栈
ArrayStack2 numStack = new ArrayStack2(10);
ArrayStack2 operStack = new ArrayStack2(10);
//定义需要的相关变量
int index = 0;//用于扫描
int num1 = 0;
int num2 = 0;
  int oper = 0;
int res = 0;
char ch = ' '; //将每次扫描得到 char 保存到 ch String keepNum = ""; //用于拼接 多位数 //开始 while 循环的扫描 expression while(true) {
//依次得到 expression 的每一个字符
ch = expression.substring(index, index+1).charAt(0); //判断 ch 是什么，然后做相应的处理 if(operStack.isOper(ch)) {//如果是运算符
//判断当前的符号栈是否为空 if(!operStack.isEmpty()) {
//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符, 就需要从数栈中 pop 出两个数,
号栈
//在从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符
if(operStack.priority(ch) <= operStack.priority(operStack.peek())) { num1 = numStack.pop();
num2 = numStack.pop();
oper = operStack.pop();
res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch);
} else {
  //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
operStack.push(ch); }
}else { //如果为空直接入符号栈.. operStack.push(ch); // 1 + 3
}
} else { //如果是数，则直接入数栈
//numStack.push(ch - 48); //? "1+3" '1' => 1
//分析思路
//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
//2. 在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号
//3. 因此我们需要定义一个变量 字符串，用于拼接 //处理多位数
keepNum += ch;
//如果 ch 已经是 expression 的最后一位，就直接入栈 if (index == expression.length() - 1) {
numStack.push(Integer.parseInt(keepNum)); }else{
//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是 index++
  if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = "1" 或者 "123" numStack.push(Integer.parseInt(keepNum));
//重要的!!!!!!, keepNum 清空
keepNum = "";
} }
}
//让 index + 1, 并判断是否扫描到 expression 最后. index++;
if (index >= expression.length()) {
break; }
}
//当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行. while(true) {
//如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if(operStack.isEmpty()) {
break; }
num1 = numStack.pop();
num2 = numStack.pop();
oper = operStack.pop();
res = numStack.cal(num1, num2, oper);
numStack.push(res);//入栈 }
//将数栈的最后数，pop 出，就是结果
int res2 = numStack.pop();
System.out.printf("表达式 %s = %d", expression, res2);
} }
//先创建一个栈,直接使用前面创建好 //定义一个 ArrayStack2 表示栈, 需要扩展功能 class ArrayStack2 {
private int maxSize; // 栈的大小
private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top 表示栈顶，初始化为-1
//构造器
public ArrayStack2(int maxSize) {
this.maxSize = maxSize;
stack = new int[this.maxSize]; }
//增加一个方法，可以返回当前栈顶的值, 但是不是真正的 pop public int peek() {
return stack[top]; }
//栈满
public boolean isFull() {
return top == maxSize - 1; }
//栈空
public boolean isEmpty() {
return top == -1; }
//入栈-push
public void push(int value) {
//先判断栈是否满 if(isFull()) {
System.out.println("栈满");
return; }
top++;
stack[top] = value; }
//出栈-pop, 将栈顶的数据返回 public int pop() {
//先判断栈是否空 if(isEmpty()) {
//抛出异常
throw new RuntimeException("栈空，没有数据~"); }
int value = stack[top]; top--;
return value;
}
//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() {
if(isEmpty()) { System.out.println("栈空，没有数据~~"); return;
} //需要从栈顶开始显示数据 for(int i = top; i >= 0 ; i--) {
System.out.printf("stack[%d]=%d\n", i, stack[i]); }
}
//返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 //数字越大，则优先级就越高.
public int priority(int oper) {
if(oper == '*' || oper == '/'){ return 1;
} else if (oper == '+' || oper == '-') { return 0;
} else {
return -1; // 假定目前的表达式只有 +, - , * , /
} }
//判断是不是一个运算符 public boolean isOper(char val) {
return val == '+' || val == '-' || val == '*' || val == '/'; }
//计算方法
public int cal(int num1, int num2, int oper) {
int res = 0; // res 用于存放计算的结果 switch (oper) {
case '+':
res = num1 + num2;
break; case '-':
res = num2 - num1;// 注意顺序
break; case '*':
res = num1 * num2;
break; case '/':
res = num2 / num1;
break; default:
break; }
return res; }
}
```

---

## 逆波兰计算器

1) 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果
2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。

 3) 思路分析

```
例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
1.从左至右扫描，将 3 和 4 压入堆栈;
2.遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3.将 5 入栈;
4.接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;
5.将 6 入栈;
6.最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
```

```java
package com.atguigu.stack;
import java.util.ArrayList; 
import java.util.List; 
import java.util.Stack;

public class PolandNotation {
public static void main(String[] args) { //先定义给逆波兰表达式
//(30+4)×5-6 =>304+5 × 6-=>164
// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / + //测试
//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -";
String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
//思路
//1. 先将 "34+5 × 6-"=> 放到ArrayList中
//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
List<String> list = getListString(suffixExpression); System.out.println("rpnList=" + list);
int res = calculate(list); System.out.println("计算的结果是=" + res);
}
//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中 public static List<String> getListString(String suffixExpression) {
//将 suffixExpression 分割
String[] split = suffixExpression.split(" "); List<String> list = new ArrayList<String>();
  for(String ele: split) { list.add(ele);
}
return list;
}
//完成对逆波兰表达式的运算 
/*
* 1)从左至右扫描，将 3 和 4 压入堆栈;
2)遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3)将 5 入栈;
4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;
5)将 6 入栈;
6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
*/
public static int calculate(List<String> ls) {
// 创建给栈, 只需要一个栈即可 Stack<String> stack = new Stack<String>(); // 遍历 ls
for (String item : ls) {
// 这里使用正则表达式来取出数
if (item.matches("\\d+")) { // 匹配的是多位数
// 入栈 stack.push(item);
  } else {
// pop 出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0;
if (item.equals("+")) {
res = num1 + num2;
} else if (item.equals("-")) {
res = num1 - num2;
} else if (item.equals("*")) { res = num1 * num2;
} else if (item.equals("/")) { res = num1 / num2;
} else {
throw new RuntimeException("运算符有误");
}
//把 res 入栈 stack.push("" + res);
}
}
//最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop());
} }
```



## 中缀表达式转换为后缀表达式

### 具体步骤如下

1) 初始化两个栈:运算符栈 s1 和储存中间结果的栈 s2; 2) 从左至右扫描中缀表达式;
3) 遇到操作数时，将其压 s2;
4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级:
1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈; 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1;
3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较;
5) 遇到括号时:
(1) 如果是左括号“(”，则直接压入 s1
(2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 

6) 重复步骤 2 至 5，直到表达式的最右边
7) 将 s1 中剩余的运算符依次弹出并压入 s2
8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

---

![举例说明](https://tva1.sinaimg.cn/large/006y8mN6ly1g8l14k7ox3j31dg0je1kx.jpg)

```java
package com.atguigu.stack;
import java.util.ArrayList; import java.util.List; import java.util.Stack;
public class PolandNotation {
public static void main(String[] args) {
//完成将一个中缀表达式转成后缀表达式的功能 //说明
//1.1+((2+3)×4)-5=> 转成 123+4 × +5 –
  //2. 因为直接对 str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的 List // 即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
//3. 将得到的中缀表达式对应的 List => 后缀表达式对应的 List
// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]
String expression = "1+((2+3)*4)-5";//注意表达式
List<String> infixExpressionList = toInfixExpressionList(expression); System.out.println("中缀表达式对应的 List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList); System.out.println("后缀表达式对应的 List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–]
System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ?
/*
//先定义给逆波兰表达式
//(30+4)×5-6 =>304+5 × 6-=>164
// 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
//测试
//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -";
String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
//思路
//1. 先将 "34+5 × 6-"=> 放到ArrayList中
//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
List<String> list = getListString(suffixExpression); System.out.println("rpnList=" + list);
int res = calculate(list); System.out.println("计算的结果是=" + res);
*/ }
//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] //方法:将得到的中缀表达式对应的 List => 后缀表达式对应的 List public static List<String> parseSuffixExpreesionList(List<String> ls) {
//定义两个栈
Stack<String> s1 = new Stack<String>(); // 符号栈
//说明:因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
//Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈 s2
List<String> s2 = new ArrayList<String>(); // 储存中间结果的 Lists2
//遍历 ls
for(String item: ls) {
//如果是一个数，加入 s2 if(item.matches("\\d+")) {
  s2.add(item);
} else if (item.equals("(")) {
s1.push(item);
} else if (item.equals(")")) {
//如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这
while(!s1.peek().equals("(")) { s2.add(s1.pop());
}
s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号 } else {
//当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1) 与 s1 中新的栈顶运算符相比较
//问题:我们缺少一个比较优先级高低的方法
while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {
s2.add(s1.pop()); }
//还需要将 item 压入栈
s1.push(item); }
}
//将 s1 中剩余的运算符依次弹出并加入 s2 while(s1.size() != 0) {
s2.add(s1.pop()); }
return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List }
//方法:将 中缀表达式转成对应的 List
// s="1+((2+3)×4)-5";
public static List<String> toInfixExpressionList(String s) {
//定义一个 List,存放中缀表达式 对应的内容 List<String> ls = new ArrayList<String>();
int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串 String str; // 对多位数的拼接
char c; // 每遍历到一个字符，就放入到 c
do {
//如果 c 是一个非数字，我需要加入到 ls if((c=s.charAt(i)) < 48 || (c=s.charAt(i)) > 57) {
ls.add("" + c);
i++; //i 需要后移
} else { //如果是一个数，需要考虑多位数
str = ""; //先将 str 置成"" '0'[48]->'9'[57]
while(i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {
str += c;//拼接
i++; }
ls.add(str); }
  }while(i < s.length());
return ls;//返回 }
//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中 public static List<String> getListString(String suffixExpression) {
//将 suffixExpression 分割
String[] split = suffixExpression.split(" "); List<String> list = new ArrayList<String>(); for(String ele: split) {
list.add(ele); }
return list; }
//完成对逆波兰表达式的运算 
/*
* 1)从左至右扫描，将 3 和 4 压入堆栈;
2)遇到+运算符，因此弹出 4 和 3(4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈; 3)将 5 入栈;
4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈;
5)将 6 入栈;
6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
*/

public static int calculate(List<String> ls) {
// 创建给栈, 只需要一个栈即可 Stack<String> stack = new Stack<String>(); // 遍历 ls
for (String item : ls) {
// 这里使用正则表达式来取出数
if (item.matches("\\d+")) { // 匹配的是多位数
// 入栈
stack.push(item); } else {
// pop 出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0;
if (item.equals("+")) {
res = num1 + num2;
} else if (item.equals("-")) {
res = num1 - num2;
} else if (item.equals("*")) { res = num1 * num2;
} else if (item.equals("/")) { res = num1 / num2;
} else {
throw new RuntimeException("运算符有误");
}
//把 res 入栈
  stack.push("" + res); }
}
//最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop());
} }
//编写一个类 Operation 可以返回一个运算符 对应的优先级 class Operation {
private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2;
//写一个方法，返回对应的优先级数字 public static int getValue(String operation) {
int result = 0; switch (operation) { case "+":
result = ADD;
break; case "-":
result = SUB;
                                    break; case "*":
result = MUL;
break; case "/":
result = DIV;
break; default:
System.out.println("不存在该运算符");
break; }
return result; }
}
```

